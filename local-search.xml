<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>react-router 传递参数</title>
    <link href="/2021/11/18/react-router%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0/"/>
    <url>/2021/11/18/react-router%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="react-router-传递参数"><a href="#react-router-传递参数" class="headerlink" title="react-router 传递参数"></a>react-router 传递参数</h1><p>React 路由第6版和第5版路由组件传递参数区别还是比较大的。V5 中传递参数主要依赖路由组件的  <em><code>history</code></em> 、  <em><code>location</code></em>  和 <em><code>match</code></em> 三个属性。</p><p>但是 V6 中，路由组件自身不具有这三个重要属性。V6 中主要依赖的是官方提供的 hooks 来解决传参问题。</p><h2 id="传递-Parmas-参数"><a href="#传递-Parmas-参数" class="headerlink" title="传递 Parmas 参数"></a>传递 Parmas 参数</h2><p>V5:</p><figure class="highlight jsx"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jsx">&#123;<span class="hljs-comment">/* 传递 params 参数 */</span>&#125;<br>&lt;Link to=&#123;<span class="hljs-string">`/home/message/detail/<span class="hljs-subst">$&#123;messageObj.id&#125;</span>/<span class="hljs-subst">$&#123;messageObj.title&#125;</span>`</span>&#125;&gt;<br>    &#123; messageObj.title &#125;<br>&lt;/Link&gt;<br>&#123;<span class="hljs-comment">/* 声明接收的 params 参数 */</span>&#125;<br>&lt;Switch&gt;<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/home/message/detail/:id/:title&quot;</span> <span class="hljs-attr">component</span>=<span class="hljs-string">&#123;</span> <span class="hljs-attr">Detail</span> &#125;/&gt;</span></span> <br>&lt;/Switch&gt;<br><br>&#123;<span class="hljs-comment">/* 路由组件接收 params 参数 */</span>&#125;<br><span class="hljs-keyword">const</span> &#123;id,title&#125; = <span class="hljs-built_in">this</span>.props.match.params  || &#123;&#125;<br></code></pre></div></td></tr></table></figure><p>V6：</p><figure class="highlight jsx"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jsx">&#123;<span class="hljs-comment">/*向路由传递 params 参数*/</span>&#125;<br>&lt;Link to=&#123;<span class="hljs-string">`detail/<span class="hljs-subst">$&#123;messageObj.id&#125;</span>/<span class="hljs-subst">$&#123;messageObj.title&#125;</span>`</span>&#125;&gt;<br>    &#123;messageObj.title&#125;<br>&lt;/Link&gt;<br>&#123;<span class="hljs-comment">/* 声明接收的 params 参数 */</span>&#125;<br>&lt;Routes&gt;<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;detail/:id/:title&quot;</span> <span class="hljs-attr">element</span>=<span class="hljs-string">&#123;</span>&lt;<span class="hljs-attr">Detail</span>/&gt;</span>&#125;/&gt;</span><br>&lt;/Routes&gt;<br><br>&#123;<span class="hljs-comment">/* 路由组件（函数式组件）接收 params 参数 */</span>&#125;<br><span class="hljs-keyword">import</span> &#123;useParams&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react-router-dom&quot;</span>;<br><span class="hljs-keyword">const</span> &#123;id, title&#125; = useParams() || &#123;&#125;;<br></code></pre></div></td></tr></table></figure><p>V5中，路由路径必须在子路由路径前完整写上主路由路径。而 V6 中，直接写子路由路径，<strong>不能</strong>添加主路由路径，子路由前面也不能添加 <code>/</code></p><p>接收参数时，V5 的 params 参数存储在路由组件的 match 属性中。而 V6 中，需要从官方提供的 <em>useParams</em> 中获取参数。因此，V6 中路由组件一般要使用函数式来写。</p><h2 id="传递-Search-参数"><a href="#传递-Search-参数" class="headerlink" title="传递 Search 参数"></a>传递 Search 参数</h2><p>V5</p><figure class="highlight jsx"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jsx">&#123;<span class="hljs-comment">/* 传递 search 参数 */</span>&#125;<br>&lt;Link to=&#123;<span class="hljs-string">`/home/message/detail?id=<span class="hljs-subst">$&#123;messageObj.id&#125;</span>&amp;title=<span class="hljs-subst">$&#123;messageObj.title&#125;</span>`</span>&#125;&gt;&#123; messageObj.title &#125;<br>&lt;/Link&gt;<br>&#123;<span class="hljs-comment">/* 声明接收的 search 参数 */</span>&#125;<br>&lt;Routes&gt;<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/home/message/detail&quot;</span> <span class="hljs-attr">component</span>=<span class="hljs-string">&#123;Detail&#125;</span> /&gt;</span></span><br>&lt;/Routes&gt;<br><br>&#123;<span class="hljs-comment">/* 路由组件接收 search 参数 */</span>&#125;<br><span class="hljs-keyword">import</span> qs <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;querystring&#x27;</span><br><span class="hljs-keyword">const</span> search = <span class="hljs-built_in">this</span>.props.location.search.slice(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">const</span> &#123;id,title&#125; = qs.parse(search) || &#123;&#125;<br></code></pre></div></td></tr></table></figure><p>V5中，接收search只用写路径即可，不用特殊声明，因为参数已经在传递时的url中写好了。</p><p>路由组件接收 search 参数，是一段 urlencoded 格式化字符串，保存在组件的location属性中:</p><figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros">?<span class="hljs-attribute">id</span>=01&amp;title=message1<br></code></pre></div></td></tr></table></figure><p>可以看出 search 参数就是 url 的 query 参数。</p><p>因此要先用 <code>qs.parse()</code> 方法将 search 参数转化成一个参数对象,才能使用:</p><figure class="highlight dts"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dts">&#123;<br><span class="hljs-symbol">id:</span><span class="hljs-number">01</span>,<br><span class="hljs-symbol">title:</span>message1<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在V6中，官方提供了 useLocation ，可用于获取 search 属性和随后将介绍的 state 属性，比较方便。</p><figure class="highlight jsx"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jsx">&#123;<span class="hljs-comment">/*向路由传递 search 参数*/</span>&#125;<br>&lt;Link to=&#123;<span class="hljs-string">`detail/?id=<span class="hljs-subst">$&#123;messageObj.id&#125;</span>&amp;title=<span class="hljs-subst">$&#123;messageObj.title&#125;</span>`</span>&#125;&gt;<br>    &#123;messageObj.title&#125;<br>&lt;/Link&gt;<br>&#123;<span class="hljs-comment">/* 声明接收的 params 参数 */</span>&#125;<br>&lt;Routes&gt;<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;detail&quot;</span> <span class="hljs-attr">element</span>=<span class="hljs-string">&#123;</span>&lt;<span class="hljs-attr">Detail</span>/&gt;</span>&#125;/&gt;</span><br>&lt;/Routes&gt;<br><br>&#123;<span class="hljs-comment">/* 路由组件（函数式组件）接收 search 参数 */</span>&#125;<br><span class="hljs-keyword">import</span> &#123;useLocation&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react-router-dom&quot;</span>;<br><span class="hljs-keyword">const</span> search = useLocation().search.slice(<span class="hljs-number">1</span>);<br><span class="hljs-keyword">const</span> &#123;id, title&#125; = qs.parse(search) || &#123;&#125;;<br></code></pre></div></td></tr></table></figure><h2 id="传递-State-参数"><a href="#传递-State-参数" class="headerlink" title="传递 State 参数"></a>传递 State 参数</h2><p>与 search 参数和 params 参数不同，state 参数不会在 url 上有所体现。他会保存在路由器 history 对象的 location 中。V5 state 直接可以在路由组件的 location 中找到，而 V6 需要通过 useLocation 获取。</p><p>V5</p><figure class="highlight jsx"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jsx">&#123;<span class="hljs-comment">/* 传递 state 参数，必须写出成对象形式 */</span>&#125;<br>&lt;Link to=&#123;&#123;<br>        <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/home/message/detail&quot;</span>,<br>            <span class="hljs-attr">state</span>: &#123;<br>                <span class="hljs-attr">id</span>: messageObj.id,<br>                    <span class="hljs-attr">title</span>: messageObj.title<br>            &#125;<br>    &#125;&#125;&gt;&#123;messageObj.title&#125;&lt;/Link&gt;<br>&#123;<span class="hljs-comment">/* 声明接收的 state 参数 */</span>&#125;<br>&lt;Routes&gt;<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/home/message/detail&quot;</span> <span class="hljs-attr">component</span>=<span class="hljs-string">&#123;Detail&#125;</span> /&gt;</span></span><br>&lt;/Routes&gt;<br><br>&#123;<span class="hljs-comment">/* 路由组件接收 search 参数 */</span>&#125;<br><span class="hljs-keyword">const</span> &#123; id, title &#125; = <span class="hljs-built_in">this</span>.props.location.state || &#123;&#125;<br></code></pre></div></td></tr></table></figure><p>V5中，state参数传递与另两种方法不同，必须写成对象形式，作为对象赋值给 Link 的 <code>to</code>。</p><p>V6中，则要分别设置 Link 的 <code>to</code> 和 <code>state</code>。从这可以看出，V6 的写法更易读，合乎直觉。</p><p>V6</p><figure class="highlight jsx"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jsx">&#123;<span class="hljs-comment">/* 向路由传递 state 参数 */</span>&#125;<br>&lt;Link to=&#123;<span class="hljs-string">&quot;detail&quot;</span>&#125; state=&#123;&#123;<br>        <span class="hljs-attr">id</span>: messageObj.id,<br>            <span class="hljs-attr">title</span>: messageObj.title<br>    &#125;&#125;&gt;&#123;messageObj.title&#125;&lt;/Link&gt;<br>&#123;<span class="hljs-comment">/* 接收 search 或 state 参数 */</span>&#125;<br>&lt;Routes&gt;<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;detail&quot;</span> <span class="hljs-attr">component</span>=<span class="hljs-string">&#123;Detail&#125;</span> /&gt;</span></span><br>&lt;/Routes&gt;<br><br>&#123;<span class="hljs-comment">/* 路由组件（函数式组件）接收 state 参数 */</span>&#125;<br><span class="hljs-keyword">import</span> &#123;useLocation&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react-router-dom&quot;</span>;<br><span class="hljs-keyword">const</span> &#123;id, title&#125; = useLocation().state || &#123;&#125;;<br></code></pre></div></td></tr></table></figure><p>尽管 state 不会出现在 url 上，但刷新浏览器参数还是会保留，路由组件不会丢失。</p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>react</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>自定义 Promise</title>
    <link href="/2021/11/02/%E8%87%AA%E5%AE%9A%E4%B9%89%20Promise/"/>
    <url>/2021/11/02/%E8%87%AA%E5%AE%9A%E4%B9%89%20Promise/</url>
    
    <content type="html"><![CDATA[<h1 id="自定义-Promise"><a href="#自定义-Promise" class="headerlink" title="自定义 Promise"></a>自定义 Promise</h1><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"><span class="hljs-built_in">window</span></span>) </span>&#123;<br>    <span class="hljs-keyword">const</span> PENDING = <span class="hljs-string">&quot;pending&quot;</span>;<br>    <span class="hljs-keyword">const</span> RESOLVED = <span class="hljs-string">&quot;resolved&quot;</span>;<br>    <span class="hljs-keyword">const</span> REJECTED = <span class="hljs-string">&quot;rejected&quot;</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">MyPromise</span>(<span class="hljs-params">executor</span>) </span>&#123;<br>        <span class="hljs-keyword">const</span> self = <span class="hljs-built_in">this</span>;<br>        self.status = PENDING;<br>        self.data = <span class="hljs-literal">undefined</span>;<br>        self.callback = [];      <span class="hljs-comment">// item:&#123;onResolved(),onRejected()&#125;</span><br><br>        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resolve</span>(<span class="hljs-params">value</span>) </span>&#123;<br>            <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>                <span class="hljs-keyword">if</span> (self.status !== PENDING) &#123; <span class="hljs-keyword">return</span>; &#125;<br>                self.status = RESOLVED;<br>                self.data = value;<br>                <span class="hljs-keyword">if</span> (self.callback.length &gt; <span class="hljs-number">0</span>) &#123;<br>                    self.callback.forEach(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> &#123;<br>                        item.onResolved(self.data);<br>                    &#125;)<br>                &#125;<br>            &#125;)<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reject</span>(<span class="hljs-params">reason</span>) </span>&#123;<br>            <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>                <span class="hljs-keyword">if</span> (self.status !== PENDING) &#123; <span class="hljs-keyword">return</span>; &#125;<br>                self.status = REJECTED;<br>                self.data = reason;<br>                <span class="hljs-keyword">if</span> (self.callback.length &gt; <span class="hljs-number">0</span>) &#123;<br>                    self.callback.forEach(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> &#123;<br>                        item.onRejected(self.data);<br>                    &#125;)<br>                &#125;<br>            &#125;)<br>        &#125;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            executor(resolve, reject);<br>        &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>            resolve(error);<br>        &#125;<br>    &#125;<br><br>    MyPromise.prototype.then = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">onResolved, onRejected</span>) </span>&#123;<br>        <span class="hljs-keyword">const</span> self = <span class="hljs-built_in">this</span>;<br><br>        onResolved = <span class="hljs-keyword">typeof</span> onResolved === <span class="hljs-string">&quot;function&quot;</span> ? onResolved : <span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> value;<br>        onRejected = <span class="hljs-keyword">typeof</span> onRejected === <span class="hljs-string">&quot;function&quot;</span> ? onRejected : <span class="hljs-function"><span class="hljs-params">reason</span> =&gt;</span> &#123; <span class="hljs-keyword">throw</span> reason &#125;;<br><br><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MyPromise(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br><br>            <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handle</span>(<span class="hljs-params">callback</span>) </span>&#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-keyword">const</span> result = callback(self.data);<br>                    <span class="hljs-keyword">if</span> (result <span class="hljs-keyword">instanceof</span> MyPromise) &#123;<br>                        result.then(resolve, reject);<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        resolve(result);<br>                    &#125;<br>                &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>                    reject(error);<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (self.status === PENDING) &#123;<br>                self.callback.push(&#123;<br>                    <span class="hljs-function"><span class="hljs-title">onResolved</span>(<span class="hljs-params"></span>)</span> &#123;<br>                        handle(onResolved);<br>                    &#125;,<br>                    <span class="hljs-function"><span class="hljs-title">onRejected</span>(<span class="hljs-params"></span>)</span> &#123;<br>                        handle(onRejected);<br>                    &#125;<br>                &#125;)<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (self.status === RESOLVED) &#123;<br>                <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>                    handle(onResolved);<br>                &#125;)<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>                    handle(onRejected);<br>                &#125;)<br>            &#125;<br>        &#125;)<br>    &#125;<br>    MyPromise.prototype.catch = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">onRejected</span>) </span>&#123;<br>        <span class="hljs-built_in">this</span>.then(<span class="hljs-literal">undefined</span>, onRejected);<br>    &#125;<br><br>    MyPromise.resolve = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MyPromise(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>            <span class="hljs-keyword">if</span> (value <span class="hljs-keyword">instanceof</span> MyPromise) &#123;<br>                value.then(resolve, reject);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                resolve(value);<br>            &#125;<br>        &#125;)<br>    &#125;<br>    MyPromise.reject = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">reason</span>) </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MyPromise(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>            reject(reason);<br>        &#125;)<br>    &#125;<br><br>    MyPromise.all = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">promises</span>) </span>&#123;<br>        <span class="hljs-keyword">const</span> resultValue = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(promises.length);<br>        <span class="hljs-keyword">let</span> resultCount = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MyPromise(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>            promises.forEach(<span class="hljs-function">(<span class="hljs-params">p, index</span>) =&gt;</span> &#123;<br>                MyPromise.resolve(p).then(<br>                    <span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>                        resultCount += <span class="hljs-number">1</span>;<br>                        resultValue[index] = value;<br>                        <span class="hljs-keyword">if</span> (resultCount === promises.length) &#123;<br>                            resolve(resultValue);<br>                        &#125;<br>                    &#125;,<br>                    <span class="hljs-function"><span class="hljs-params">reason</span> =&gt;</span> &#123;<br>                        reject(reason)<br>                    &#125;<br>                );<br>            &#125;)<br>        &#125;)<br>    &#125;<br><br>    MyPromise.race = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">promises</span>) </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MyPromise(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>            promises.forEach(<span class="hljs-function"><span class="hljs-params">p</span> =&gt;</span> &#123;<br>                MyPromise.resolve(p).then(resolve, reject);<br>            &#125;)<br>        &#125;)<br>    &#125;<br><br>    MyPromise.delayResolve = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value, time = <span class="hljs-number">0</span></span>) </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MyPromise(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>            <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>                <span class="hljs-keyword">if</span> (value <span class="hljs-keyword">instanceof</span> MyPromise) &#123;<br>                    value.then(resolve, reject);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    resolve(value);<br>                &#125;<br>            &#125;, time)<br>        &#125;)<br>    &#125;<br><br>    MyPromise.delayReject = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">reason, time = <span class="hljs-number">0</span></span>) </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MyPromise(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>            <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>                reject(reason);<br>            &#125;, time)<br>        &#125;)<br>    &#125;<br><br>    <span class="hljs-built_in">window</span>.MyPromise = MyPromise;<br>&#125;)(<span class="hljs-built_in">window</span>)<br></code></pre></div></td></tr></table></figure><p>测试：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./MyPromise.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript">    <span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> MyPromise(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="javascript">        <span class="hljs-comment">// resolve(1);</span></span><br><span class="javascript">        reject(<span class="hljs-number">2</span>);</span><br><span class="javascript">        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;同步代码&quot;</span>);</span><br><span class="javascript">    &#125;);</span><br><span class="javascript"></span><br><span class="javascript">    <span class="hljs-keyword">const</span> p1 = MyPromise.delayResolve(<span class="hljs-string">&quot;ok&quot;</span>);</span><br><span class="javascript">    <span class="hljs-keyword">const</span> p2 = MyPromise.delayReject(<span class="hljs-string">&quot;fuck&quot;</span>, <span class="hljs-number">200</span>);</span><br><span class="javascript">    <span class="hljs-keyword">const</span> p3 = MyPromise.resolve(MyPromise.delayReject(<span class="hljs-string">&quot;err&quot;</span>));</span><br><span class="javascript">    <span class="hljs-keyword">const</span> n = <span class="hljs-number">1</span>;</span><br><span class="javascript"></span><br><span class="javascript">    MyPromise.race([p2, p3, p1])</span><br><span class="javascript">        .then(</span><br><span class="javascript">        <span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;onResolved&quot;</span>, value),</span><br><span class="javascript">        <span class="hljs-function">(<span class="hljs-params">reason</span>) =&gt;</span> &#123;</span><br><span class="javascript">            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;onRejected&quot;</span>, reason);</span><br><span class="javascript">            <span class="hljs-keyword">throw</span> <span class="hljs-number">404</span>;</span><br><span class="javascript">        &#125;</span><br><span class="javascript">    )</span><br><span class="javascript">        .then(<span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;onResolved&quot;</span>, value))</span><br><span class="javascript">        .catch(<span class="hljs-function">(<span class="hljs-params">reason</span>) =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;onRejected&quot;</span>, reason));</span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScrip 继承2.0</title>
    <link href="/2021/11/01/JavaScrip%202.0/"/>
    <url>/2021/11/01/JavaScrip%202.0/</url>
    
    <content type="html"><![CDATA[<h1 id="JavaScrip-继承2-0"><a href="#JavaScrip-继承2-0" class="headerlink" title="JavaScrip 继承2.0"></a>JavaScrip 继承2.0</h1><h2 id="改变构造函数的原型并不是继承"><a href="#改变构造函数的原型并不是继承" class="headerlink" title="改变构造函数的原型并不是继承"></a>改变构造函数的原型并不是继承</h2><p>假设有两个构造函数 User 和 Person . 现在想让 Person 的实例能够访问 User 的 showName() 方法。此时一种思路：直接将 Person 的原型修改为 User 的原型：</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">User</span>(<span class="hljs-params">name</span>)</span>&#123;<br><span class="hljs-built_in">this</span>.name = name<br>&#125;<br><br>User.prototype.showName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params">name</span>)</span>&#123;<br><span class="hljs-built_in">this</span>.name = name<br>&#125;<br><br><span class="hljs-comment">// 直接将 Person 的原型修改为 User 的原型</span><br>Person.prototype = User.prototype<br><br><span class="hljs-keyword">let</span> person = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;xiaofang&quot;</span>)<br>person.showName()<span class="hljs-comment">//此时可以正常访问</span><br><br><span class="hljs-built_in">console</span>.log(person.constructor === User)<span class="hljs-comment">// true</span><br><span class="hljs-built_in">console</span>.log(person.constructor === Person)<span class="hljs-comment">// false</span><br></code></pre></div></td></tr></table></figure><p>本质上，将 User 直接作为 person 的构造函数，这样 person 就能够访问 User 原型对象的方法。</p><p>但是，这导致了一个问题：假设此时要给所有 person 实例添加一个 age 属性，由于 Person.prototype 指向了 User.prototype ，二者也就是同一个对象。因此给 Person.prototype 添加属性会导致 User 的原型也被添加了这个属性：</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">Person.prototype.age = <span class="hljs-number">18</span><br><span class="hljs-built_in">console</span>.log(Person.prototype)<span class="hljs-comment">// 有age属性</span><br><span class="hljs-built_in">console</span>.log(User.prototype)<span class="hljs-comment">// User的原型也被添加了age属性</span><br></code></pre></div></td></tr></table></figure><p>这显然不是我们想要的。</p><p>真正的继承应该是可以用到父辈的方法，同时自己添加或修改自己方法/属性的时候不会反过来影响父辈。</p><h2 id="继承是原型的继承"><a href="#继承是原型的继承" class="headerlink" title="继承是原型的继承"></a>继承是原型的继承</h2><p>首先为了便于理解，使用 <code>__proto__</code> 的写法来寻找和设置实例对象的原型：</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">let</span> f = &#123;&#125;<br><span class="hljs-comment">// 实际开发中,一下写法是等价的：</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.getPrototypeOf(f))<br>等价于：<br><span class="hljs-built_in">console</span>.log(__proto__)<br><br><span class="hljs-built_in">Object</span>.setPrototype(f,obj)<br>等价于：<br>f.__proto__ = obj<br><span class="hljs-comment">/* getPrototypeOf相当于找实例对象的爸爸，setPrototypeOf相当于指定实例第项的爸爸 */</span><br><br><span class="hljs-comment">// 补充：以上两个方法都是“儿子设置爸爸”，如何用“爸爸”创造“儿子”呢？使用 Object.create()</span><br><span class="hljs-keyword">let</span> f2 = <span class="hljs-built_in">Object</span>.create(f)<br><span class="hljs-comment">// 等价于：</span><br>f2.__proto__ = f<br></code></pre></div></td></tr></table></figure><p>以上代码 <code>setPrototypeOf()</code> 和 <code>Object.create()</code> 二者几乎没有差别，只是前者设置“父亲”，后者设置“儿子”</p><p>由于构造函数和实例之间有这样一对关系：</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">Obj.prototype === obj.__proto__<br></code></pre></div></td></tr></table></figure><p>即：构造函数的“叔叔”是实例对象的“爸爸”。</p><p>正常从原型链访问方法，都是延着父辈这条链访问，只要方法存在于父辈这条链上，就能够访问得到。并且，自己可以修改自己的方法/属性，并不会影响到父辈。</p><p>因此，如果想在继承其他构造函数时，实例对象自己能够添加和修改自身方法/属性，而不影响父辈。就不能去修改构造函数的原型，即不能改变原有“爸爸”。</p><p>正确的做法是，让待继承构造函数的“叔叔”进入实例对象的父亲链，而不是直接作为父亲。</p><p>因此，可以让实例对象的原型继承构造函数的prototype。即：<code>Person.prototype.__proto__ = User.prototype</code>。</p><p>也就是说，不能让构造函数的“叔叔”作为实例对象的“爸爸”，但是可以让他作为实例对象的“爷爷”:</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">Person.prototype.__proto__ = User.prototype<br><span class="hljs-comment">// 即：</span><br>Person.prototype = <span class="hljs-keyword">new</span> User()<br><span class="hljs-comment">// 即：</span><br>Person.prototype = <span class="hljs-built_in">Object</span>.create(User.prototype)<br><span class="hljs-comment">// 亦即：</span><br><span class="hljs-built_in">Object</span>.setPrototype(Person.prototype, User.prototype)<br><br><span class="hljs-comment">// 测试：</span><br>Person.prototype.age = <span class="hljs-number">18</span><br><span class="hljs-keyword">let</span> person = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;xiaofang&quot;</span>)<br><span class="hljs-built_in">console</span>.log(Person.prototype)<span class="hljs-comment">// 有 age 属性</span><br><span class="hljs-built_in">console</span>.log(User.prototype)<span class="hljs-comment">// 没有 age 属性</span><br></code></pre></div></td></tr></table></figure><h2 id="继承的解决方案"><a href="#继承的解决方案" class="headerlink" title="继承的解决方案"></a>继承的解决方案</h2><p>一般使用所谓的<strong>组合模式</strong>来实现继承：</p><p>使用原型链继承原型上的属性和方法，而通过盗用构造函数继承实例属性。 </p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">User</span>(<span class="hljs-params">name</span>)</span>&#123;<br>    <span class="hljs-built_in">this</span>.name = name<br>&#125;<br>User.prototype.showName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params">name,age</span>)</span>&#123;<br>    <span class="hljs-comment">// ① 通过盗用构造函数继承实例属性，防止引用值在关联对象中共享</span><br>    User.call(<span class="hljs-built_in">this</span>,name)<span class="hljs-comment">// 或者：User.apply(this,arguments)</span><br>    <span class="hljs-built_in">this</span>.age = age<br>&#125;<br><br><span class="hljs-comment">// ② 继承方法。浅拷贝,然后让构造函数进入原型链</span><br><span class="hljs-comment">// 设置：Person.prototype.__proto__ = User.prototype</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Temp</span>(<span class="hljs-params"></span>)</span>&#123;&#125;<br>Temp.prototype = User.prototype<br>Person.prototype = <span class="hljs-keyword">new</span> Temp()<br><span class="hljs-comment">// 或者：Person.prototype = Object.create(User.prototype)</span><br><span class="hljs-comment">// 或者：Object.setPrototypeOf(Person.prototype, User.prototype)</span><br><br><span class="hljs-comment">// ③ 设置constructor</span><br><span class="hljs-built_in">Object</span>.defineProperty(Person.prototype,<span class="hljs-string">&quot;constructor&quot;</span>,&#123;<br>    <span class="hljs-attr">value</span>: Person,<br>    <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">false</span><br>&#125;)<br><br>Person.prototype.sayAge = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;&#125;<br><br><span class="hljs-keyword">let</span> person1 = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;xiaofang&quot;</span>,<span class="hljs-number">18</span>)<br></code></pre></div></td></tr></table></figure><h2 id="类构造函数实现继承"><a href="#类构造函数实现继承" class="headerlink" title="类构造函数实现继承"></a>类构造函数实现继承</h2><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name</span>)</span>&#123;<br>    <span class="hljs-built_in">this</span>.name = name    <br>    &#125;<br><span class="hljs-function"><span class="hljs-title">showName</span>(<span class="hljs-params"></span>)</span>&#123;&#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">User</span></span>&#123;<span class="hljs-comment">// extends 关键字自动实现步骤 ② 和 ③</span><br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">age</span>)</span>&#123;<br>        <span class="hljs-built_in">super</span>()<span class="hljs-comment">// 相当于步骤 ①</span><br>        <span class="hljs-built_in">this</span>.age = age<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">sayAge</span>(<span class="hljs-params"></span>)</span>&#123;&#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> person1 = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;xiaofang&quot;</span>,<span class="hljs-number">18</span>)<br></code></pre></div></td></tr></table></figure><h2 id="instanceof-的实现原理"><a href="#instanceof-的实现原理" class="headerlink" title="instanceof 的实现原理"></a>instanceof 的实现原理</h2><p><em><code>instanceof</code></em> 用于判断一个构造函数的原型是否在一个实例对象的原型链上。</p><p>例如， <code>a instanceof B</code> 表示判断 B 的 叔叔是否是 a 的长辈 </p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(person1 <span class="hljs-keyword">instanceof</span> User)<span class="hljs-comment">// true</span><br></code></pre></div></td></tr></table></figure><p>这个关键字的实现原理就是，沿着实例对象的原型链向上攀升，看找不找得到构造函数的“叔叔”。以下使用一个函数来说明 instanceof 关键字的实现原理：</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">checkPrototype</span>(<span class="hljs-params">obj,constructor</span>)</span>&#123;<br><span class="hljs-keyword">if</span>(!obj.__proto__) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    <span class="hljs-keyword">if</span>(obj.__proto__ === <span class="hljs-title">constructor</span>.<span class="hljs-title">prototype</span>) <span class="hljs-title">return</span> <span class="hljs-title">true</span><br>    <span class="hljs-title">return</span> <span class="hljs-title">checkPrototype</span>(<span class="hljs-params">obj.__proto__,constructor</span>)<br>&#125;<br><br>//测试：<br><span class="hljs-title">checkPrototype</span>(<span class="hljs-params">person1, User</span>)// <span class="hljs-title">true</span><br></code></pre></div></td></tr></table></figure><h2 id="instenceof-和-isPrototypeOf-的区别"><a href="#instenceof-和-isPrototypeOf-的区别" class="headerlink" title="instenceof 和 isPrototypeOf() 的区别"></a>instenceof 和 isPrototypeOf() 的区别</h2><ul><li><p><em><code>instanceof</code></em> 用于判断一个构造函数的原型是否在一个实例对象的原型链上。即构造函数的叔叔是否是实例对象“爸爸链”成员</p></li><li><p><em><code>isPrototypeOf()</code></em> 用于判断一个对象是否在另一个对象的原型链上。即一个对象是否是另一个对象的“爸爸链”成员</p></li></ul><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(person1 <span class="hljs-keyword">instanceof</span> User)<span class="hljs-comment">// true</span><br><br><span class="hljs-built_in">console</span>.log(User.isPrototypeOf(person1))<span class="hljs-comment">// false 构造函数和实例对象是堂兄弟关系</span><br><span class="hljs-built_in">console</span>.log(User.prototype.isPrototypeOf(person1))<span class="hljs-comment">// true</span><br><br><span class="hljs-built_in">console</span>.log(User.isPrototypeOf(Person))<span class="hljs-comment">// true</span><br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>rem方案实现页面宽高自适应</title>
    <link href="/2021/10/14/rem%E6%96%B9%E6%A1%88%E5%AE%9E%E7%8E%B0%E5%AE%BD%E9%AB%98%E8%87%AA%E9%80%82%E5%BA%94/"/>
    <url>/2021/10/14/rem%E6%96%B9%E6%A1%88%E5%AE%9E%E7%8E%B0%E5%AE%BD%E9%AB%98%E8%87%AA%E9%80%82%E5%BA%94/</url>
    
    <content type="html"><![CDATA[<h1 id="rem方案实现页面宽高自适应"><a href="#rem方案实现页面宽高自适应" class="headerlink" title="rem方案实现页面宽高自适应"></a>rem方案实现页面宽高自适应</h1><h2 id="问题引入及解决"><a href="#问题引入及解决" class="headerlink" title="问题引入及解决"></a>问题引入及解决</h2><p>最近做大屏项目，有一个现实问题：不同屏幕如何保证页面按 16：9 显示。</p><p>由于不同设备<strong>屏幕尺寸</strong>、<strong>分辨率</strong>不同，或者需要考虑<strong>横竖屏</strong>问题，为了使得web页面在不同移动设备上具有相适应的展示效果，需要在开发过程中使用合理的适配方案来解决这个问题。</p><p>rem方案提供了较好的解决办法：</p><p>根据页面宽高比16:9，</p><ol><li>当设备较宽时，w设备/h设备 &gt; 16/9，此时页面高度即为设备高度</li><li>当设备较高时，w设备/h设备 &lt;= 16/9，此时页面宽度就是设备宽度</li></ol><p>因此，有如下计算方法：</p><p><img src="/2021/10/14/rem%E6%96%B9%E6%A1%88%E5%AE%9E%E7%8E%B0%E5%AE%BD%E9%AB%98%E8%87%AA%E9%80%82%E5%BA%94/1634227164639.png" alt="页面宽高计算方法"></p><p>其中，Wp 为页面有效宽度，Hp 为页面有效高度</p><p>页面左右居中，上下居中，四周留白即可</p><p>然后，在 <head> 中设置字体按比例缩放 1rem = W / 100 ，即可达到效果。</head></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>index.html</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript">        <span class="hljs-comment">// 采用动态rem方案响应页面布局</span></span><br><span class="javascript">        <span class="hljs-keyword">const</span> clientWidth = <span class="hljs-built_in">document</span>.documentElement.clientWidth;</span><br><span class="javascript">        <span class="hljs-keyword">const</span> clientHeight = <span class="hljs-built_in">document</span>.documentElement.clientHeight;</span><br><span class="javascript">        <span class="hljs-keyword">const</span> pageWidth = clientWidth / clientHeight &gt; <span class="hljs-number">16</span> / <span class="hljs-number">9</span> ? clientHeight * <span class="hljs-number">16</span> / <span class="hljs-number">9</span> : clientWidth;</span><br><span class="javascript">        <span class="hljs-keyword">const</span> pageHeight = pageWidth * <span class="hljs-number">9</span> / <span class="hljs-number">16</span>;</span><br><span class="javascript">        <span class="hljs-comment">// 设置 1rem = pageWidth/100</span></span><br><span class="javascript">        <span class="hljs-keyword">const</span> string = <span class="hljs-string">`</span></span><br><span class="hljs-string"><span class="javascript">            &lt;style&gt;</span></span><br><span class="hljs-string"><span class="javascript">                html&#123;</span></span><br><span class="hljs-string"><span class="javascript">                    font-size: <span class="hljs-subst">$&#123;pageWidth / <span class="hljs-number">100</span>&#125;</span>px;</span></span><br><span class="hljs-string"><span class="javascript">                &#125;</span></span><br><span class="hljs-string"><span class="javascript">            &lt;/style&gt;</span></span><br><span class="hljs-string"><span class="javascript">        `</span>;</span><br><span class="javascript">        <span class="hljs-comment">//    将style标签写入页面</span></span><br><span class="javascript">        <span class="hljs-built_in">document</span>.write(string);</span><br><span class="javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;root&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript">    <span class="hljs-comment">// 设置root宽高</span></span><br><span class="javascript">    root.style.width = pageWidth + <span class="hljs-string">&quot;px&quot;</span>;</span><br><span class="javascript">    root.style.height = pageHeight + <span class="hljs-string">&quot;px&quot;</span>;</span><br><span class="javascript">    root.style.background = <span class="hljs-string">&quot;pink&quot;</span>;</span><br><span class="javascript">    <span class="hljs-comment">// 设置root上下居中</span></span><br><span class="javascript">    root.style.marginTop = (clientHeight - pageHeight) / <span class="hljs-number">2</span> + <span class="hljs-string">&quot;px&quot;</span>;</span><br><span class="javascript">    <span class="hljs-comment">// 设置root左右居中（可以直接写在css中）</span></span><br><span class="javascript">    root.style.marginLeft = <span class="hljs-string">&quot;auto&quot;</span>;</span><br><span class="javascript">    root.style.marginRight = <span class="hljs-string">&quot;auto&quot;</span>;</span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h2 id="使用-rem-代替-px"><a href="#使用-rem-代替-px" class="headerlink" title="使用 rem 代替 px"></a>使用 rem 代替 px</h2><p>当使用宽高自适应响应式布局之后，就不能使用 px 单位将每个元素尺寸写死了，此时就需要用 rem 来计算元素的尺寸。</p><p>根据页面与设计稿的尺寸与宽度之比相等，可知：</p><p><img src="/2021/10/14/rem%E6%96%B9%E6%A1%88%E5%AE%9E%E7%8E%B0%E5%AE%BD%E9%AB%98%E8%87%AA%E9%80%82%E5%BA%94/1634569215012.png" alt="使用rem代替px"></p><p>因此，页面尺寸只需通过如下px函数就能计算得到：</p><figure class="highlight scss"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scss"><span class="hljs-keyword">@function</span> px(<span class="hljs-variable">$n</span>) &#123;<br>    <span class="hljs-keyword">@return</span> <span class="hljs-variable">$n</span> / widthDesign * <span class="hljs-number">100rem</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>其中，<code>$n</code> 为设计稿实际尺寸；</p><p>​            常量 <code>widthDesign</code> 为设计稿实际宽度，由实际测量得到。</p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue3 v-model 与 Vue2 的区别</title>
    <link href="/2021/09/15/Vue3%E7%9A%84v-model/"/>
    <url>/2021/09/15/Vue3%E7%9A%84v-model/</url>
    
    <content type="html"><![CDATA[<h1 id="Vue3-v-model-与-Vue2-的区别"><a href="#Vue3-v-model-与-Vue2-的区别" class="headerlink" title="Vue3 v-model 与 Vue2 的区别"></a>Vue3 v-model 与 Vue2 的区别</h1><h2 id="v-model-代替旧的-v-model-和-sync"><a href="#v-model-代替旧的-v-model-和-sync" class="headerlink" title="v-model 代替旧的 v-model 和 .sync"></a>v-model 代替旧的 v-model 和 .sync</h2><p>在 Vue 2.0 发布后，使用 <code>v-model</code> 指令时必须使用名为 <code>value</code> 的 prop。如果出于不同的目的需要使用其他的 prop，他们就必须使用 <code>v-bind.sync</code>。</p><p>此外，由于<code>v-model</code> 和 <code>value</code> 之间的这种编码关系，会出现如何处理原生元素以及自定义元素的问题。</p><p>在 Vue 2.2 中，引入了 <code>model</code> 组件选项，允许组件自定义用于 <code>v-model</code> 的 prop 和事件。但是，仍然只允许在组件上使用一个 <code>v-model</code>。</p><p>在 Vue 3 中，双向数据绑定的 API 已经标准化，以减少开发者在使用 <code>v-model</code> 指令时的混淆，同时更加灵活。</p><h2 id="2-x-语法"><a href="#2-x-语法" class="headerlink" title="2.x 语法"></a>2.x 语法</h2><h3 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a><code>v-model</code></h3><p>在 2.x 中，在组件上使用 <code>v-model</code> 相当于绑定 <code>value</code> prop 并触发 <code>input</code> 事件：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ChildComponent</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;pageTitle&quot;</span> /&gt;</span><br><br><span class="hljs-comment">&lt;!-- 是以下的简写: --&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">ChildComponent</span> <span class="hljs-attr">:value</span>=<span class="hljs-string">&quot;pageTitle&quot;</span> @<span class="hljs-attr">input</span>=<span class="hljs-string">&quot;pageTitle = $event&quot;</span> /&gt;</span><br></code></pre></div></td></tr></table></figure><p>如果想要更改 prop 或事件名称，则需要在 <code>ChildComponent</code> 组件中添加 <code>model</code> 选项：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- ParentComponent.vue --&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">ChildComponent</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;pageTitle&quot;</span> /&gt;</span><br></code></pre></div></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// ChildComponent.vue</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-attr">model</span>: &#123;<br>    <span class="hljs-attr">prop</span>: <span class="hljs-string">&#x27;title&#x27;</span>,<br>    <span class="hljs-attr">event</span>: <span class="hljs-string">&#x27;change&#x27;</span><br>  &#125;,<br>  <span class="hljs-attr">props</span>: &#123;<br>    <span class="hljs-comment">// 这将允许 `value` 属性用于其他用途</span><br>    <span class="hljs-attr">value</span>: <span class="hljs-built_in">String</span>,<br>    <span class="hljs-comment">// 使用 `title` 代替 `value` 作为 model 的 prop</span><br>    <span class="hljs-attr">title</span>: &#123;<br>      <span class="hljs-attr">type</span>: <span class="hljs-built_in">String</span>,<br>      <span class="hljs-attr">default</span>: <span class="hljs-string">&#x27;Default title&#x27;</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>所以，在这个例子中 <code>v-model</code> 是以下的简写：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ChildComponent</span> <span class="hljs-attr">:title</span>=<span class="hljs-string">&quot;pageTitle&quot;</span> @<span class="hljs-attr">change</span>=<span class="hljs-string">&quot;pageTitle = $event&quot;</span> /&gt;</span><br></code></pre></div></td></tr></table></figure><h3 id="v-bind-sync"><a href="#v-bind-sync" class="headerlink" title="v-bind.sync"></a><code>v-bind.sync</code></h3><p>在某些情况下，除了前面用 <code>v-model</code> 绑定 prop 的情况，我们可能需要对某一个 prop 进行“双向绑定”。这时，可以使用 <code>update:myPropName</code> 抛出事件。例如，对于在上一个示例中带有 <code>title</code> prop 的 <code>ChildComponent</code>，我们可以通过下面的方式将分配新 value 的意图传达给父级：</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span>&#123;<br>    <span class="hljs-attr">methods</span>:&#123;<br>        <span class="hljs-function"><span class="hljs-title">x</span>(<span class="hljs-params"></span>)</span>&#123;<br>            <span class="hljs-built_in">this</span>.$emit(<span class="hljs-string">&#x27;update:title&#x27;</span>, newValue)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>然后父组件可以在需要时监听该事件，并更新本地的 data property。例如：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ChildComponent</span> <span class="hljs-attr">:title</span>=<span class="hljs-string">&quot;pageTitle&quot;</span> @<span class="hljs-attr">update:title</span>=<span class="hljs-string">&quot;pageTitle = $event&quot;</span> /&gt;</span><br></code></pre></div></td></tr></table></figure><p>为了方便起见，可以使用 <code>.sync</code> 修饰符来缩写，如下所示：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ChildComponent</span> <span class="hljs-attr">:title.sync</span>=<span class="hljs-string">&quot;pageTitle&quot;</span> /&gt;</span><br></code></pre></div></td></tr></table></figure><h2 id="3-x-语法"><a href="#3-x-语法" class="headerlink" title="3.x 语法"></a>3.x 语法</h2><p>在 3.x 中，自定义组件上的 <code>v-model</code> 相当于传递了 <code>modelValue</code> prop 并接收抛出的 <code>update:modelValue</code> 事件：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ChildComponent</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;pageTitle&quot;</span> /&gt;</span><br><br><span class="hljs-comment">&lt;!-- 是以下的简写: --&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">ChildComponent</span></span><br><span class="hljs-tag">  <span class="hljs-attr">:modelValue</span>=<span class="hljs-string">&quot;pageTitle&quot;</span></span><br><span class="hljs-tag">  @<span class="hljs-attr">update:modelValue</span>=<span class="hljs-string">&quot;pageTitle = $event&quot;</span></span><br><span class="hljs-tag">/&gt;</span><br></code></pre></div></td></tr></table></figure><p>3.x中，一般通过下面的方式将分配新 value 的意图传达给父级</p><p>vue3 中一般不使用 methods 来操作函数，因此不能通过this拿到props，以及对其 $emit,</p><p>而是利用 <code>setup()</code> 方法的两个参数 <em><code>props</code></em> 和 <em><code>context</code></em> 来获取 props 以及绑定事件：</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">setup</span>(<span class="hljs-params">props,context</span>)</span>&#123;<br>        <span class="hljs-keyword">const</span> x = <span class="hljs-function">()=&gt;</span>&#123;<br>            context.emit(<span class="hljs-string">&quot;update:modelValue&quot;</span>, newValue)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>若需要更改 <code>model</code> 的名称，现在可以为 <code>v-model</code> 传递一个<em>参数</em>，以作为组件内 <code>model</code> 选项的替代：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ChildComponent</span> <span class="hljs-attr">v-model:title</span>=<span class="hljs-string">&quot;pageTitle&quot;</span> /&gt;</span><br><br><span class="hljs-comment">&lt;!-- 是以下的简写: --&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">ChildComponent</span> <span class="hljs-attr">:title</span>=<span class="hljs-string">&quot;pageTitle&quot;</span> @<span class="hljs-attr">update:title</span>=<span class="hljs-string">&quot;pageTitle = $event&quot;</span> /&gt;</span><br></code></pre></div></td></tr></table></figure><p>这也可以作为 <code>.sync</code> 修饰符的替代，而且允许我们在自定义组件上使用多个 <code>v-model</code>。</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ChildComponent</span> <span class="hljs-attr">v-model:title</span>=<span class="hljs-string">&quot;pageTitle&quot;</span> <span class="hljs-attr">v-model:content</span>=<span class="hljs-string">&quot;pageContent&quot;</span> /&gt;</span><br><br><span class="hljs-comment">&lt;!-- 是以下的简写： --&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">ChildComponent</span></span><br><span class="hljs-tag">  <span class="hljs-attr">:title</span>=<span class="hljs-string">&quot;pageTitle&quot;</span></span><br><span class="hljs-tag">  @<span class="hljs-attr">update:title</span>=<span class="hljs-string">&quot;pageTitle = $event&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">:content</span>=<span class="hljs-string">&quot;pageContent&quot;</span></span><br><span class="hljs-tag">  @<span class="hljs-attr">update:content</span>=<span class="hljs-string">&quot;pageContent = $event&quot;</span></span><br><span class="hljs-tag">/&gt;</span><br></code></pre></div></td></tr></table></figure><h3 id="v-model-修饰符"><a href="#v-model-修饰符" class="headerlink" title="v-model 修饰符"></a><code>v-model</code> 修饰符</h3><p>除了像 <code>.trim</code> 这样的 2.x 硬编码的 <code>v-model</code> 修饰符外，现在 3.x 还支持自定义修饰符：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ChildComponent</span> <span class="hljs-attr">v-model.capitalize</span>=<span class="hljs-string">&quot;pageTitle&quot;</span> /&gt;</span><br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>比特记账 React 版项目记录</title>
    <link href="/2021/09/01/%E6%AF%94%E7%89%B9%E8%AE%B0%E8%B4%A6%EF%BC%88React%E7%89%88%EF%BC%89%E9%A1%B9%E7%9B%AE%E8%AE%B0%E5%BD%95/"/>
    <url>/2021/09/01/%E6%AF%94%E7%89%B9%E8%AE%B0%E8%B4%A6%EF%BC%88React%E7%89%88%EF%BC%89%E9%A1%B9%E7%9B%AE%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="比特记账-React-版项目记录"><a href="#比特记账-React-版项目记录" class="headerlink" title="比特记账 React 版项目记录"></a>比特记账 React 版项目记录</h1><h2 id="让-React-支持-sass"><a href="#让-React-支持-sass" class="headerlink" title="让 React 支持 sass"></a>让 React 支持 sass</h2><p>React 支持 sass 本身需要 node-sass，但node-sass有两个缺点：下载速度慢，本地编译慢。</p><p>于是决定改用 dart-sass 代替 node-sass 。但是 React 本事又不支持 dart-sass。经过查阅资料和研究，我发现**npm6.9 有一个新功能：<code>package alias</code>**，它可以骗过 React 假装安装 node-sass，而实际使用的是 dart-sass</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">yarn add node-sass@npm:dart-sass<br></code></pre></div></td></tr></table></figure><h2 id="导入组件"><a href="#导入组件" class="headerlink" title="导入组件"></a>导入组件</h2><p>为了使 react 可以直接用@import <code>&quot;xxx/yyy&quot;</code> 来引入 <code>&quot;src/xxx/yyy&quot;</code>  </p><p>需要在 jsconfig.json 或 tsconfig.json 中添加如下配置：</p><figure class="highlight json"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;compilerOptions&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;baseUrl&quot;</span>: <span class="hljs-string">&quot;src&quot;</span><br>  &#125;,<br>  <span class="hljs-attr">&quot;include&quot;</span>: [<span class="hljs-string">&quot;src&quot;</span>]<br>&#125;<br></code></pre></div></td></tr></table></figure><p>配置完成之后 <code>yarn start</code> 重启服务，.scss 和 .tsx 文件就都可以使用这种方法引入了。</p><h2 id="使用-styled-components"><a href="#使用-styled-components" class="headerlink" title="使用 styled-components"></a>使用 styled-components</h2><p>本项目所有的 scss 全部使用 js 代码生成。使用这个插件的好处是元素的 css 样式直接和元素绑定在一起，不用再为元素添加 css 类名。</p><p>安装依赖：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">yarn add styled-components<br>yarn add @types/styled-components<br></code></pre></div></td></tr></table></figure><h2 id="svg-symbols"><a href="#svg-symbols" class="headerlink" title="svg symbols"></a>svg symbols</h2><h2 id="React-自定义-loader-修改-svg-源文件"><a href="#React-自定义-loader-修改-svg-源文件" class="headerlink" title="React 自定义 loader 修改 .svg 源文件"></a>React 自定义 loader 修改 .svg 源文件</h2><h3 id="用loader-解析-svg-文件"><a href="#用loader-解析-svg-文件" class="headerlink" title="用loader 解析 .svg 文件"></a>用<code>loader</code> 解析 .svg 文件</h3><p>引入 <code>.svg</code> 图标可以直接将 <code>import</code> 导入的变量作为参数传给 <img> 的 <code>src</code> ,这样实际上是引入的图片，不是标签。但是用这种方法引入的话，修改 <code>.svg</code> 源代码就比较麻烦。比如要修改 <code>svg</code> 的 <code>fill</code> 属性，如果直接修改 <code>svg</code> 的 <code>fill</code> 属性，当 svg 颜色较多时，不具有操作性。本项目使用 <code>svg symbols</code> 的方法引入 <code>.svg</code> 图标。需要用到 <code>svg-sprite-loader</code> 让 webpack 可以解析出 <code>.svg</code> 文件。</p><p>这样就只用修改 webpack.config.js 配置，就可以批量需改 <code>.svg</code> 源文件了。</p><p>在 React 中，这种方法需要先 <code>eject</code> </p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">yarn eject# Are you sure you want to eject? This action is permanent.(y/N) y<br></code></pre></div></td></tr></table></figure><hr><h4 id="插曲：出现一个小错误"><a href="#插曲：出现一个小错误" class="headerlink" title="插曲：出现一个小错误"></a>插曲：出现一个小错误</h4><p>运行 <code>yarn eject</code> 之后，重新运行 <code>yarn start</code> 后报错如下：</p><p><img src="/2021/09/01/%E6%AF%94%E7%89%B9%E8%AE%B0%E8%B4%A6%EF%BC%88React%E7%89%88%EF%BC%89%E9%A1%B9%E7%9B%AE%E8%AE%B0%E5%BD%95/%E5%B0%8Fbug.png" alt="小bug"></p><p>我敏锐的观察到这是因为「Cannot find module」，于是我试运行 <code>yarn add @babel/helper-create-regexp-features-plugin</code> ，<code>bug</code> 迎刃而解了。</p><p>当然，这个小 bug 不是重点。</p><p>关键是我找到了一个万能的排错语句，记录下来：</p><figure class="highlight cmake"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cmake">rm -rf node_modules<br>yarn <span class="hljs-keyword">install</span><br></code></pre></div></td></tr></table></figure><hr><p>之后 <code>src</code> 目录下会多出 <code>config</code> 、<code>scripts</code> 等文件夹。</p><p>然后安装 <code>svg-sprite-loader</code> </p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">yarn add svg-sprite-loader -D<br></code></pre></div></td></tr></table></figure><p><code>svgo-loader</code> 可以更方便的修改 <code>.svg</code> 图标相关属性，也要安装：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">yarn add svgo-loader<br></code></pre></div></td></tr></table></figure><p>然后配置 config/webpack.config.js 文件：</p><figure class="highlight json"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs json">module:&#123;<br>    rules:[<br>        &#123;<br>            oneOf:[<br>                &#123;<br>                    test:/\.svg$/,<br>                    use:[<br>                        &#123;loader:&#x27;svg-sprite-loader&#x27;,options:&#123;&#125;&#125;,<br>                        &#123;loader:&#x27;svgo-loader&#x27;,options:&#123;<br>                            plugins:[<br>                                &#123;removeAttrs: &#123;attrs: &#x27;fill&#x27;&#125;&#125;<br>                            ]<br>                        &#125;&#125;<br>                    ]<br>                &#125;<br>            ]<br>        &#125;<br>    ]<br>&#125;<br></code></pre></div></td></tr></table></figure><p>配置完成需要重新 <code>yarn start</code> 。</p><p>然后就可以使用 svg symbols 方法引入 <code>.svg</code> 了。</p><h3 id="引入单个-svg-文件"><a href="#引入单个-svg-文件" class="headerlink" title="引入单个 .svg 文件"></a>引入单个 .svg 文件</h3><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tsx">require(&quot;icons/money.svg&quot;);<br><br>const Nav = () =&gt; &#123;<br>    return (<br>            &lt;ul&gt;<br>                &lt;li&gt;<br>                    &lt;svg fill=&quot;red&quot;&gt;<br>                        &lt;use xlinkHref=&quot;#money&quot;/&gt;<br>                    &lt;/svg&gt;<br>                    &lt;Link to=&quot;/money&quot;&gt;记账&lt;/Link&gt;<br>                &lt;/li&gt;          <br>            &lt;/ul&gt;<br>    );<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="一个-bug"><a href="#一个-bug" class="headerlink" title="一个 bug"></a>一个 bug</h3><p>我发信每次 <code>import</code> 之后必须要使用引入的变量（比如控制台打印变量）才可以用 svg symbols 方法引入 <code>.svg</code> 。 若 <code>import</code> 之后的 js 代码中又没有使用 <code>import</code> 引入的变量，则元素不会被渲染。</p><p>这显然很麻烦，而且控制台打印变量没有任何实际意义，代码也变得不易读。</p><p>查阅资料发现，import引入变量具有 <strong>Tree Shaking</strong> 特性，<code>webpack</code> 打包时会将没有使用的变量删除，从而不会得到编译出所需要的变量。</p><blockquote><p>新的 webpack 4 正式版本，扩展了这个检测能力，通过 <code>package.json</code> 的 <code>&quot;sideEffects&quot;</code> 属性作为标记，向 compiler 提供提示，表明项目中的哪些文件是 “pure(纯的 ES2015 模块)”，由此可以安全地删除文件中未使用的部分。</p></blockquote><p><strong>解决方法</strong>是使用 <code>require()</code> 引入，原理是 <code>require</code> 方法不遵循 <strong>Tree Shaking</strong>。</p><h2 id="优化：一次性引入所有的-svg-文件"><a href="#优化：一次性引入所有的-svg-文件" class="headerlink" title="优化：一次性引入所有的 .svg 文件"></a>优化：一次性引入所有的 .svg 文件</h2><p>项目中引入了三个 <code>.svg</code> 文件，使用了三次 <code>require()</code> 。出于优化考虑，希望以后都可以直接将所有 icon 一次性引入，不用那么麻烦的一个一个引入。搜索相关资料，最终找到了解决办法。</p><p>首先要安装 ts 依赖：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">yarn add --dev @types/webpack-env<br></code></pre></div></td></tr></table></figure><p>然后就可以使用 TypeScript 引入了</p><figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><br><span class="hljs-comment">// require 一整个文件夹</span><br><span class="hljs-keyword">let</span> importAll = <span class="hljs-function">(<span class="hljs-params">requireContext: __WebpackModuleApi.RequireContext</span>) =&gt;</span> requireContext.keys().forEach(requireContext);<br><span class="hljs-keyword">try</span> &#123;<br>    importAll(<span class="hljs-built_in">require</span>.context(<span class="hljs-string">&#x27;icons&#x27;</span>, <span class="hljs-literal">true</span>, <span class="hljs-regexp">/\.svg$/</span>));<br>&#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>    <span class="hljs-built_in">console</span>.log(error);<br>&#125;<br><br><span class="hljs-keyword">type</span> Props = &#123; <span class="hljs-attr">name</span>:<span class="hljs-built_in">string</span> &#125;;<br><br><span class="hljs-keyword">const</span> Icon = <span class="hljs-function">(<span class="hljs-params">props:Props</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> (<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">svg</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;icon&quot;</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">use</span> <span class="hljs-attr">xlinkHref</span>=<span class="hljs-string">&#123;</span>&quot;#&quot; + <span class="hljs-attr">props.name</span>&#125;/&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">svg</span>&gt;</span></span><br>    );<br>&#125;;<br></code></pre></div></td></tr></table></figure><h2 id="点击-output-屏幕触发显示计算器面板"><a href="#点击-output-屏幕触发显示计算器面板" class="headerlink" title="点击 output 屏幕触发显示计算器面板"></a>点击 output 屏幕触发显示计算器面板</h2><p>之前使用 Vue 开发的 BitByBit 中，记账页面感觉有些拥挤，同时感觉 UI 有点单调，因此这次使用 React 我想增加一点空间，于是将收入和支出放到了一个下拉列表中。计算器面板则使用点击 output 触发显示的方法：将显示计算结果和唤醒计算器面板封装在 CalculatorOutput 组件中。</p><p>父组件：</p><figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Money</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">const</span> [displayCalculator, setDisplayCalculator] = useState(<span class="hljs-literal">false</span>);<br>    <span class="hljs-keyword">const</span> displayPad = useCallback(<span class="hljs-function">() =&gt;</span> &#123;<br>        setDisplayCalculator(<span class="hljs-function">() =&gt;</span> <span class="hljs-literal">true</span>);<br>    &#125;, []);<br><br>    <span class="hljs-keyword">return</span> (<br>        <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Layout</span>&gt;</span></span><br><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">CalculatorOutput</span></span></span><br><span class="hljs-tag"><span class="xml">                <span class="hljs-attr">displayCalculatorPad</span> = <span class="hljs-string">&#123;Props.displayCalculatorPad&#125;</span></span></span><br><span class="hljs-tag"><span class="xml">                <span class="hljs-attr">output</span> = <span class="hljs-string">&#123;Props.output&#125;</span></span></span><br><span class="hljs-tag"><span class="xml">            /&gt;</span></span><br><span class="xml">            &#123;displayCalculator &amp;&amp; <span class="hljs-tag">&lt;<span class="hljs-name">CalculatorPad</span>/&gt;</span>&#125;</span><br><span class="xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">Layout</span>&gt;</span></span><br>    );<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> Money;<br></code></pre></div></td></tr></table></figure><p>CalculatorOutput .tsx:</p><figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> Props =&#123;<br>    <span class="hljs-attr">displayCalculatorPad</span>:<span class="hljs-function">()=&gt;</span><span class="hljs-built_in">void</span>,<br>    <span class="hljs-attr">output</span>:<span class="hljs-built_in">string</span><br>&#125;<br><br><span class="hljs-keyword">const</span> CalculatorOutput:React.FC&lt;Props&gt; = <span class="hljs-function">(<span class="hljs-params">Props:Props</span>)=&gt;</span>&#123;<br>    <span class="hljs-keyword">return</span> (<br>        <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;output&quot;</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span>=&gt;</span> &#123;</span><br><span class="xml">            Props.displayCalculatorPad();</span><br><span class="xml">        &#125;&#125;&gt;</span><br><span class="xml">            &#123;Props.output&#125;</span><br><span class="xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    );<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> CalculatorOutput;<br></code></pre></div></td></tr></table></figure><h2 id="计算器面板无法紧贴底部"><a href="#计算器面板无法紧贴底部" class="headerlink" title="计算器面板无法紧贴底部"></a>计算器面板无法紧贴底部</h2><p>记账页面布局并不能随移动端长度变化而变化。预期是希望计算器面板总是紧贴底部的，我希望多出来的部分全部添加到 TagsSelection 组件上，即使用 <code>flex-grow: 1;</code> 。但是尽管 Layout 组件的 display 是 flex，而包裹所有组件的直接父元素是 <code>Main</code>，它的 display 为 block。因此必须首先给 <code>Main</code> 添加 <code>display:flex;</code> 。</p><p>一种方法是直接给 Layout 传入 <em>className</em> 参数，然后用外部 css 修改 Main 的 display。</p><p>不过我从一开始就不想使用外部 css ，因为这样之后命名比较麻烦，而且名字比较冗余，</p><p>于是我查阅 styled-components 官方文档，看有没有可以对自有组件进行二次封装的方法。</p><p>果然是有的：</p><p>首先还是要给 Layout 传 <em>className</em> 参数：</p><p>Layout.tsx: </p><figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> Layout = <span class="hljs-function">(<span class="hljs-params">props: <span class="hljs-built_in">any</span></span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> (<br>        <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">Wrapper</span>&gt;</span></span><br><span class="xml">                <span class="hljs-tag">&lt;<span class="hljs-name">Main</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&#123;props.className&#125;</span>&gt;</span></span><br><span class="xml">                    &#123;props.children&#125;</span><br><span class="xml">                <span class="hljs-tag">&lt;/<span class="hljs-name">Main</span>&gt;</span></span><br><span class="xml">                <span class="hljs-tag">&lt;<span class="hljs-name">Nav</span>/&gt;</span></span><br><span class="xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">Wrapper</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    );<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>然后对 Layout 进行二次封装：</p><p>MyLayout:</p><figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> MyLayout = sytled(Layout)<span class="hljs-string">`</span><br><span class="hljs-string">display:flex;</span><br><span class="hljs-string">flex-direction:column;</span><br><span class="hljs-string">`</span>;<br></code></pre></div></td></tr></table></figure><p>然后就可以使用 MyLayout 了：</p><p>Monty.tsx:</p><figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Money</span>(<span class="hljs-params"></span>) </span>&#123;<br><span class="hljs-keyword">return</span> (<br>        <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">MyLayout</span>&gt;</span></span><br><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">RecordSelection</span></span></span><br><span class="hljs-tag"><span class="xml">                <span class="hljs-attr">displayCalPad</span>=<span class="hljs-string">&#123;displayPad&#125;</span></span></span><br><span class="hljs-tag"><span class="xml">                <span class="hljs-attr">output</span>=<span class="hljs-string">&#123;</span>&quot;<span class="hljs-attr">100</span>&quot;&#125;</span></span><br><span class="hljs-tag"><span class="xml">            /&gt;</span></span><br><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">NoteSection</span>/&gt;</span></span><br><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">TagsSelection</span>/&gt;</span></span><br><span class="xml">            displayCalculator &amp;&amp; <span class="hljs-tag">&lt;<span class="hljs-name">CalculatorPad</span>/&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">MyLayout</span>&gt;</span></span><br>    );<br>&#125;<br></code></pre></div></td></tr></table></figure><p>将 TagSelection 的 <code>flex-grow</code> 设为 <code>1</code> 即可。</p><figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> TagsSelectionWrapper = styled.section<span class="hljs-string">`</span><br><span class="hljs-string">flex-grow: 1;</span><br><span class="hljs-string">`</span>;<br></code></pre></div></td></tr></table></figure><h2 id="监听-Note-input-事件变化"><a href="#监听-Note-input-事件变化" class="headerlink" title="监听 Note input 事件变化"></a>监听 Note input 事件变化</h2><p>一开始我选择使用受控模式监听 input 输入变化:</p><figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> NoteSection: React.FC = <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> [note, setNote] = useState(<span class="hljs-string">&quot;&quot;</span>);<br>    <span class="hljs-built_in">console</span>.log(note);<span class="hljs-comment">// 其他操作代码</span><br>    <span class="hljs-keyword">return</span> (<br>        <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Wrapper</span>&gt;</span></span><br><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span></span><br><span class="xml">                <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>备注<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="xml">                <span class="hljs-tag">&lt;<span class="hljs-name">input</span></span></span><br><span class="hljs-tag"><span class="xml">                    <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span></span></span><br><span class="hljs-tag"><span class="xml">                    <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;此处添加备注&quot;</span></span></span><br><span class="hljs-tag"><span class="xml">                    <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;note&#125;</span></span></span><br><span class="hljs-tag"><span class="xml">                    <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;e</span> =&gt;</span> &#123;</span><br><span class="xml">                        setNote(() =&gt;</span><br><span class="xml">                            e.target.value</span><br><span class="xml">                        );</span><br><span class="xml">                    &#125;&#125;</span><br><span class="xml">                /&gt;</span><br><span class="xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">Wrapper</span>&gt;</span></span><br>    );<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>这样就可以实时监听输入端的变化了，但是总觉实时监听没什么必要，因为用户目的是记录每一笔流水，那么备注就只用在移出焦点时做一次监听就好了。于是后来我又改为使用非受控模式的监听来实现这一过程。</p><figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> NoteSection: React.FC = <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> [note, setNote] = useState(<span class="hljs-string">&quot;&quot;</span>);<br>    <span class="hljs-keyword">const</span> refInput = useRef&lt;HTMLInputElement&gt;(<span class="hljs-literal">null</span>);<br>    <span class="hljs-keyword">const</span> currentInput = refInput.current;<br>    <span class="hljs-keyword">const</span> onBlur = <span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span> (currentInput) &#123;<br>            setNote(<span class="hljs-function">() =&gt;</span><br>                currentInput.value<br>            );<br>        &#125;<br>    &#125;;<br>    <span class="hljs-keyword">return</span> (<br>        <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Wrapper</span>&gt;</span></span><br><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span></span><br><span class="xml">                <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>备注<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="xml">                <span class="hljs-tag">&lt;<span class="hljs-name">input</span></span></span><br><span class="hljs-tag"><span class="xml">                    <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span></span></span><br><span class="hljs-tag"><span class="xml">                    <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;此处添加备注&quot;</span></span></span><br><span class="hljs-tag"><span class="xml">                    <span class="hljs-attr">defaultValue</span>=<span class="hljs-string">&#123;note&#125;</span></span></span><br><span class="hljs-tag"><span class="xml">                    <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;refInput&#125;</span></span></span><br><span class="hljs-tag"><span class="xml">                    <span class="hljs-attr">onBlur</span>=<span class="hljs-string">&#123;onBlur&#125;</span></span></span><br><span class="hljs-tag"><span class="xml">                /&gt;</span></span><br><span class="xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">Wrapper</span>&gt;</span></span><br>    );<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>在写完非受控模式的监听后，我发现了一个有意思的事：</p><p>HTML 的 onChange 是在鼠标移出（失去焦点）时触发的。</p><p>而 React 的 onChange 就是其字面意思：改变即触发（实时监听）。</p><p>也就是说：HTML 的 onChange 事件实际对应的是 React 的 onBlur 事件。</p><h2 id="自定义-Hooks-要命名为-“useXXX”"><a href="#自定义-Hooks-要命名为-“useXXX”" class="headerlink" title="自定义 Hooks 要命名为 “useXXX”"></a>自定义 Hooks 要命名为 “useXXX”</h2><p>在抽离 Tags 组件时，一开始我没有使用 “useXXX” 格式命名，导致报错：</p><p><img src="/2021/09/01/%E6%AF%94%E7%89%B9%E8%AE%B0%E8%B4%A6%EF%BC%88React%E7%89%88%EF%BC%89%E9%A1%B9%E7%9B%AE%E8%AE%B0%E5%BD%95/%E8%87%AA%E5%AE%9A%E4%B9%89hooks%E8%A6%81%E7%94%A8use%E5%BC%80%E5%A4%B4.png" alt="自定义hooks要用use开头"></p><p>原因是 react 规定，useState 只能在函数组件或者自定义 Hooks 中使用。函数组件要使用 首字母大写命名，自定义 Hooks 要以 “use” 开头，不能使用其他的驼峰命名方法。因此将 <code>createTags</code> 改名为 <code>useTags</code> 就好了：</p><figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> &#123;useState&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><br><span class="hljs-keyword">const</span> useTags = <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> [tags, setTags] = useState&lt;<span class="hljs-built_in">string</span>[]&gt;([<span class="hljs-string">&quot;衣服&quot;</span>, <span class="hljs-string">&quot;吃饭&quot;</span>, <span class="hljs-string">&quot;住房&quot;</span>, <span class="hljs-string">&quot;出行&quot;</span>]);<br>    <span class="hljs-keyword">return</span> &#123;tags, setTags&#125;;<br>&#125;;<br><br><span class="hljs-keyword">export</span> &#123;useTags&#125;;<br></code></pre></div></td></tr></table></figure><h2 id="Tags-深拷贝"><a href="#Tags-深拷贝" class="headerlink" title="Tags 深拷贝"></a>Tags 深拷贝</h2><p>Tags 无法直接修改，在对其进行操作前，必须先进行<strong>深拷贝</strong>：</p><figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> tagsClone = <span class="hljs-built_in">JSON</span>.parse(<span class="hljs-built_in">JSON</span>.stringify(tags));<br></code></pre></div></td></tr></table></figure><h2 id="页面跳转上一页"><a href="#页面跳转上一页" class="headerlink" title="页面跳转上一页"></a>页面跳转上一页</h2><p>为了达到回退指定页面的目的，本项目中，我采用把编辑页面两个回退 Icon 的 link 写死的方式完成。</p><p>但是编辑标签页面点击 <code>删除标签</code> 按钮，我使用的是回退上一页的方法处理的：</p><p>前期直接使用浏览器提供的方法：</p><figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> onClickBack = <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-built_in">window</span>.history.back();<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>查阅了 <code>react-router-dom</code> 文档之后，改用其封装好的 api 处理：</p><figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> &#123;useHistory&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react-router-dom&quot;</span>;<br><br><span class="hljs-keyword">const</span> history = useHistory();<br><span class="hljs-keyword">const</span> onClickBack = <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-comment">// window.history.back();</span><br>    history.goBack();<br>&#125;;<br></code></pre></div></td></tr></table></figure><h2 id="第一次刷新更行不执行代码"><a href="#第一次刷新更行不执行代码" class="headerlink" title="第一次刷新更行不执行代码"></a>第一次刷新更行不执行代码</h2><p>添加标签有一个 bug：当 localstorage 最开始为空数组时，useEffect 会在 undefined 变为 [] 时，执行一次 <code>setTags()</code> ；然后在 [] 变为 tags 时执行一次 <code>setTags()</code>  。显然第一次执行是不必要的，而且有时的确会出现tags 为空白的情款，为此，我单独度封装了一个自定义 hooks ，控制第一次更新不执行 <code>setTags()</code> 。</p><figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> &#123;useEffect, useRef&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> useUpdate = <span class="hljs-function">(<span class="hljs-params">fn:()=&gt;<span class="hljs-built_in">void</span>, deps:<span class="hljs-built_in">any</span>[]</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> count = useRef(<span class="hljs-number">0</span>);<br>    useEffect(<span class="hljs-function">() =&gt;</span> &#123;<br>        count.current += <span class="hljs-number">1</span>;<br>    &#125;);<br><br>    useEffect(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span> (count.current &gt; <span class="hljs-number">1</span>) &#123;<br>            fn();<br>        &#125;<br>    &#125;, deps);<br>&#125;;<br></code></pre></div></td></tr></table></figure><h2 id="自定义-prompt-组件"><a href="#自定义-prompt-组件" class="headerlink" title="自定义 prompt 组件"></a>自定义 prompt 组件</h2><p>为了解决微信无法使用 <code>window.prompt</code> ，我单独封装了 <code>OhMyPrompt</code> 组件:</p><p>OhMyPrompt.tsx:</p><figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> styled <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;styled-components&quot;</span>;<br><span class="hljs-keyword">import</span> React, &#123;ChangeEventHandler, useImperativeHandle&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><span class="hljs-keyword">import</span> &#123;Input&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./Imput&quot;</span>;<br><br><span class="hljs-keyword">const</span> ElemCenter = styled.div<span class="hljs-string">`</span><br><span class="hljs-string">    position: absolute;</span><br><span class="hljs-string">    top: 0;</span><br><span class="hljs-string">    left: 0;</span><br><span class="hljs-string">    display: flex;</span><br><span class="hljs-string">    width: 100%;</span><br><span class="hljs-string">    height: 100%;</span><br><span class="hljs-string">    justify-content: center;</span><br><span class="hljs-string">    align-items: center;</span><br><span class="hljs-string">    background: linear-gradient(</span><br><span class="hljs-string">    to bottom right,</span><br><span class="hljs-string">    rgba(255, 255, 255, 0.2),</span><br><span class="hljs-string">    rgba(255, 255, 255, 0.5)</span><br><span class="hljs-string">    );</span><br><span class="hljs-string">    backdrop-filter: blur(2px);</span><br><span class="hljs-string">    </span><br><span class="hljs-string">    &amp;.visibility-false &#123;</span><br><span class="hljs-string">        display: none;</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">`</span>;<br><br><span class="hljs-keyword">const</span> MyPrompt = styled.div<span class="hljs-string">`</span><br><span class="hljs-string">    background: linear-gradient(to top right, rgba(255, 255, 255, 0.1), rgba(255, 255, 255, 0.5));</span><br><span class="hljs-string">    width: 300px;</span><br><span class="hljs-string">    height: 200px;</span><br><span class="hljs-string">    display: flex;</span><br><span class="hljs-string">    flex-direction: column;</span><br><span class="hljs-string">    justify-content: center;</span><br><span class="hljs-string">    align-items: center;</span><br><span class="hljs-string">    padding: 20px;</span><br><span class="hljs-string">    border: solid 1px #c4c3c3;</span><br><span class="hljs-string">    border-radius: 15px;</span><br><span class="hljs-string">    backdrop-filter: blur(2px);</span><br><span class="hljs-string">    text-align: center;</span><br><span class="hljs-string">    </span><br><span class="hljs-string">    h3&#123;</span><br><span class="hljs-string">        margin-top: 8px;</span><br><span class="hljs-string">        margin-bottom: 16px;</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">    </span><br><span class="hljs-string">    Label&#123;</span><br><span class="hljs-string">        padding: 0 34px;</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">    </span><br><span class="hljs-string">    &gt; div&#123;</span><br><span class="hljs-string">        display: flex;</span><br><span class="hljs-string">        width: 100%;</span><br><span class="hljs-string">        padding: 16px 48px;</span><br><span class="hljs-string">        justify-content: space-around;</span><br><span class="hljs-string">            &gt;button&#123;</span><br><span class="hljs-string">              padding: 4px 8px;</span><br><span class="hljs-string">              font-weight: bolder;</span><br><span class="hljs-string">              &amp;:active &#123;</span><br><span class="hljs-string">                    box-shadow: inset 0 0 5px rgba(0,0,0,0.1);</span><br><span class="hljs-string">                &#125;</span><br><span class="hljs-string">                background: yellowgreen;</span><br><span class="hljs-string">                border-radius: 5px;</span><br><span class="hljs-string">            &#125;</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">`</span>;<br><br><span class="hljs-keyword">type</span> VisibleProps = &#123;<br>    <span class="hljs-attr">isOpen</span>: <span class="hljs-built_in">boolean</span>;<br>&#125; &amp; React.AllHTMLAttributes&lt;<span class="hljs-built_in">any</span>&gt;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">DisplayPrompt</span>(<span class="hljs-params">props: VisibleProps</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> (<br>        <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ElemCenter</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&#123;</span>`<span class="hljs-attr">visibility-</span>$&#123;<span class="hljs-attr">props.isOpen</span>&#125; `&#125;&gt;</span></span><br><span class="xml">            &#123;props.children&#125;</span><br><span class="xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">ElemCenter</span>&gt;</span></span><br>    );<br>&#125;<br><br><span class="hljs-keyword">type</span> myPromptProps = &#123;<br>    hidePad?: <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">void</span>;<br>    newTag: <span class="hljs-built_in">string</span>;<br>    setNewTag: <span class="hljs-function">(<span class="hljs-params">value: <span class="hljs-built_in">string</span></span>) =&gt;</span> <span class="hljs-built_in">void</span>;<br>    addTag: <span class="hljs-function">(<span class="hljs-params"><span class="hljs-built_in">string</span>: <span class="hljs-built_in">string</span></span>) =&gt;</span> <span class="hljs-built_in">boolean</span>;<br>    onRef: <span class="hljs-built_in">any</span>;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">OhMyPrompt</span>(<span class="hljs-params">props: myPromptProps</span>) </span>&#123;<br>    <span class="hljs-keyword">const</span> [display, setDisplay] = React.useState(<span class="hljs-literal">false</span>);<br>    <span class="hljs-keyword">const</span> &#123;newTag, setNewTag, addTag, onRef&#125; = props;<br><br>    useImperativeHandle(onRef, <span class="hljs-function">() =&gt;</span> (&#123;<br>        <span class="hljs-attr">openMyPrompt</span>: <span class="hljs-function">() =&gt;</span> &#123;<br>            setDisplay(<span class="hljs-literal">true</span>);<br>        &#125;<br>    &#125;));<br><br>    <span class="hljs-keyword">const</span> onAddtag: ChangeEventHandler&lt;HTMLInputElement&gt; = <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;<br>        setNewTag(e.target.value);<br>    &#125;;<br><br>    <span class="hljs-keyword">const</span> submitAddTag = <span class="hljs-function">() =&gt;</span> &#123;<br>        addTag(newTag);<br>        setNewTag(<span class="hljs-string">&quot;&quot;</span>);<br>    &#125;;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">closeMyPrompt</span>(<span class="hljs-params"></span>) </span>&#123;<br>        setDisplay(<span class="hljs-literal">false</span>);<br>    &#125;<br><br><br>    <span class="hljs-keyword">return</span> (<br>        <span class="xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">DisplayPrompt</span> <span class="hljs-attr">isOpen</span>=<span class="hljs-string">&#123;display&#125;</span>&gt;</span></span><br><span class="xml">                <span class="hljs-tag">&lt;<span class="hljs-name">MyPrompt</span>&gt;</span></span><br><span class="xml">                    <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>添加标签<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span></span><br><span class="xml">                    <span class="hljs-tag">&lt;<span class="hljs-name">Input</span></span></span><br><span class="hljs-tag"><span class="xml">                        <span class="hljs-attr">label</span>=<span class="hljs-string">&#123;</span>&quot;标签名&quot;&#125;</span></span><br><span class="hljs-tag"><span class="xml">                        <span class="hljs-attr">type</span>=<span class="hljs-string">&#123;</span>&quot;<span class="hljs-attr">text</span>&quot;&#125;</span></span><br><span class="hljs-tag"><span class="xml">                        <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&#123;</span>&quot;此处添加新的标签名&quot;&#125;</span></span><br><span class="hljs-tag"><span class="xml">                        <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;newTag&#125;</span></span></span><br><span class="hljs-tag"><span class="xml">                        <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;onAddtag&#125;/</span>&gt;</span></span><br><span class="xml">                    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">                        <span class="hljs-tag">&lt;<span class="hljs-name">button</span></span></span><br><span class="hljs-tag"><span class="xml">                            <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> &#123;</span><br><span class="xml">                                closeMyPrompt();</span><br><span class="xml">                                submitAddTag();</span><br><span class="xml">                            &#125;&#125;</span><br><span class="xml">                        &gt;</span><br><span class="xml">                            提交</span><br><span class="xml">                        <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="xml">                        <span class="hljs-tag">&lt;<span class="hljs-name">button</span></span></span><br><span class="hljs-tag"><span class="xml">                            <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;closeMyPrompt&#125;</span></span></span><br><span class="hljs-tag"><span class="xml">                        &gt;</span></span><br><span class="xml">                            取消</span><br><span class="xml">                        <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="xml">                    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">                <span class="hljs-tag">&lt;/<span class="hljs-name">MyPrompt</span>&gt;</span></span><br><span class="xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">DisplayPrompt</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;/&gt;</span></span><br>    );<br>&#125;<br><br><span class="hljs-keyword">export</span> &#123;OhMyPrompt&#125;;<br></code></pre></div></td></tr></table></figure><p>使用 <code>useRef</code> 和 <code>useImperativeHandle</code> 让父组件可以调用子组件的 <code>openMyPrompt()</code>方法，这样控制弹窗显示的 <code>Button</code>  样式就可以完全由父组件自己设定：</p><p>父组件 TagsList.tsx</p><figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> Button = styled.button<span class="hljs-string">`</span><br><span class="hljs-string">    color:#2a9e78;</span><br><span class="hljs-string">    font-size: 16px;</span><br><span class="hljs-string">    font-weight: bolder;</span><br><span class="hljs-string">    border: 1px solid #2a9e78;</span><br><span class="hljs-string">    padding: 8px 12px;</span><br><span class="hljs-string">    background: #f4faff;</span><br><span class="hljs-string">    border-radius: 10px;</span><br><span class="hljs-string">    &amp;:active &#123;</span><br><span class="hljs-string">        box-shadow: inset 0 0 5px rgba(0,0,0,0.1);</span><br><span class="hljs-string">        color:#00aeff;</span><br><span class="hljs-string">        background: #d9efff;</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">`</span>;<br><br><span class="hljs-keyword">const</span> TagsList = <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> &#123;tags, addTag, deleteTag&#125; = useTags();<br>    <span class="hljs-keyword">const</span> [newTag, setNewTag] = useState(<span class="hljs-string">&quot;&quot;</span>);<br>    <span class="hljs-keyword">const</span> child = useRef();<br>    <span class="hljs-keyword">const</span> onChild = <span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-comment">// @ts-ignore</span><br>        child.current.openMyPrompt();<br>    &#125;;<br><br>    <span class="hljs-keyword">return</span> (<br>        <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Layout</span>&gt;</span></span><br><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">TitleWrapper</span>&gt;</span></span><br><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">ElementCenter</span>&gt;</span></span><br><span class="xml">                <span class="hljs-tag">&lt;<span class="hljs-name">Button</span></span></span><br><span class="hljs-tag"><span class="xml">                    <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> &#123;</span><br><span class="xml">                        onChild();</span><br><span class="xml">                    &#125;&#125;</span><br><span class="xml">                &gt;</span><br><span class="xml">                    新增标签</span><br><span class="xml">                <span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span></span><br><span class="xml">                <span class="hljs-tag">&lt;<span class="hljs-name">OhMyPrompt</span></span></span><br><span class="hljs-tag"><span class="xml">                    <span class="hljs-attr">newTag</span>=<span class="hljs-string">&#123;newTag&#125;</span></span></span><br><span class="hljs-tag"><span class="xml">                    <span class="hljs-attr">setNewTag</span>=<span class="hljs-string">&#123;setNewTag&#125;</span></span></span><br><span class="hljs-tag"><span class="xml">                    <span class="hljs-attr">addTag</span>=<span class="hljs-string">&#123;addTag&#125;</span></span></span><br><span class="hljs-tag"><span class="xml">                    <span class="hljs-attr">onRef</span>=<span class="hljs-string">&#123;child&#125;</span></span></span><br><span class="hljs-tag"><span class="xml">                /&gt;</span></span><br><span class="xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">ElementCenter</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">Layout</span>&gt;</span></span><br><span class="xml">    );</span><br><span class="xml">&#125;;</span><br><span class="xml"></span><br><span class="xml">export &#123;TagsList&#125;;</span><br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>正则表达式</title>
    <link href="/2021/08/31/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <url>/2021/08/31/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>举例：筛选全部数字：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> ad = <span class="hljs-string">&quot;yi1024chang8421&quot;</span>;<br><br><span class="hljs-comment">// let nums = [...hd].filter(a=&gt;!Number.isNaN(parseInt(a)));</span><br><span class="hljs-comment">// console.log(nums.join(&quot;&quot;));</span><br><br><span class="hljs-built_in">console</span>.log(ad.match(<span class="hljs-regexp">/\d/g</span>).join(<span class="hljs-string">&quot;&quot;</span>));<br><span class="hljs-comment">// &quot;10248421&quot;</span><br></code></pre></div></td></tr></table></figure><h2 id="创建正则表达式的方法"><a href="#创建正则表达式的方法" class="headerlink" title="创建正则表达式的方法"></a>创建正则表达式的方法</h2><h3 id="字面量创建"><a href="#字面量创建" class="headerlink" title="字面量创建"></a>字面量创建</h3><p>字符串中查找 “a”</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> ad = <span class="hljs-string">&quot;yi1024chang8421&quot;</span>;<br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-regexp">/a/</span>.test(ad));  <span class="hljs-comment">// true</span><br><br><span class="hljs-keyword">let</span> m = <span class="hljs-string">&quot;a&quot;</span>;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">eval</span>(<span class="hljs-string">`/<span class="hljs-subst">$&#123;m&#125;</span>/`</span>).test(ad))  <span class="hljs-comment">//true</span><br></code></pre></div></td></tr></table></figure><h3 id="对象创建"><a href="#对象创建" class="headerlink" title="对象创建"></a>对象创建</h3><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> ad = <span class="hljs-string">&quot;yi1024chang8421&quot;</span>;<br><br><span class="hljs-keyword">let</span> m = <span class="hljs-string">&quot;a&quot;</span>;<br><br><span class="hljs-keyword">let</span> reg = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(m,<span class="hljs-string">&quot;g&quot;</span>);<br><span class="hljs-built_in">console</span>.log(reg.test(ad));    <span class="hljs-comment">//true</span><br></code></pre></div></td></tr></table></figure><p>参数细节：</p><p><strong>RegExp(<em>pattern</em>,<em>[, flags]</em>)</strong></p><ul><li><em>pattern</em>: 正则表达式的文本</li><li><em>[, flags]</em>: 指定要匹配的范围。参数值可以是：<ol><li><code>g</code> 全局匹配</li><li><code>i</code> 忽略大小写</li><li><code>m</code> 多行匹配</li><li><code>s</code> 点号匹配所有字符</li><li><code>u</code> unicode</li><li><code>y</code> sticky，粘性匹配</li></ol></li></ul><p>举例：支持正则表达式的样式替换小程序</p><p>html:</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;content&quot;</span>&gt;</span><br>  yichang8421.github.io<br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>JavaScript:</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> con = prompt(<span class="hljs-string">&quot;请输入要检测的内容，支持正则&quot;</span>);<br><span class="hljs-keyword">let</span> reg = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(con,<span class="hljs-string">&quot;g&quot;</span>);<br><span class="hljs-keyword">let</span> div = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&quot;div&quot;</span>);<br>div.innerHTML = div.innerHTML.replace(reg,<span class="hljs-function"><span class="hljs-params">search</span> =&gt;</span>&#123;<br>  <span class="hljs-keyword">return</span>(<span class="hljs-string">`</span><br><span class="hljs-string">    &lt;span style=&quot;color:red&quot;&gt;</span><br><span class="hljs-string">      <span class="hljs-subst">$&#123;search&#125;</span></span><br><span class="hljs-string">    &lt;/span&gt;</span><br><span class="hljs-string">  `</span>);<br>&#125;);<br></code></pre></div></td></tr></table></figure><h2 id="选择符"><a href="#选择符" class="headerlink" title="选择符"></a>选择符</h2><h3 id="或选择符"><a href="#或选择符" class="headerlink" title="或选择符"></a>或选择符</h3><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> tel = <span class="hljs-string">&quot;^010-1234567$&quot;</span>;<br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-regexp">/(010|020)\-\d&#123;7,8&#125;/</span>.test(tel));<span class="hljs-comment">// true</span><br></code></pre></div></td></tr></table></figure><h3 id="原子表-和原子组"><a href="#原子表-和原子组" class="headerlink" title="原子表 [] 和原子组 ()"></a>原子表 <code>[]</code> 和原子组 <code>()</code></h3><p>原子表 <code>[]</code> 中的每个字符之间为“或”链接，按一个字符一个字符的匹配，一旦匹配成功就返回，之后的不再匹配。</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> reg = <span class="hljs-regexp">/[123456]/</span>;<br><span class="hljs-keyword">let</span> ad = <span class="hljs-string">&#x27;1&#x27;</span>;<br><span class="hljs-keyword">let</span> ad2 = <span class="hljs-string">&#x27;12312132&#x27;</span>;<br><br><span class="hljs-built_in">console</span>.log(ad.match(reg));<span class="hljs-comment">// [&quot;1&quot;, index: 0, input: &quot;1&quot;, groups: undefined]。reg 按一个字符一个字符与 hd 匹配</span><br><span class="hljs-built_in">console</span>.log(ad2.match(reg));<span class="hljs-comment">// [&quot;1&quot;, index: 0, input: &quot;1&quot;, groups: undefined]。按一个字符一个字符的匹配，一旦匹配成功就返回，之后的不再匹配</span><br></code></pre></div></td></tr></table></figure><p>原子组原子组 <code>()</code> 是按一个整体匹配。</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> reg = <span class="hljs-regexp">/(123|456)/</span>;<br><span class="hljs-keyword">let</span> ad = <span class="hljs-string">&#x27;5123456789&#x27;</span>;<br><br><span class="hljs-built_in">console</span>.log(ad.match(reg));<span class="hljs-comment">// [&quot;123&quot;, &quot;123&quot;, index: 1, input: &quot;5123456789&quot;, groups: undefined]</span><br></code></pre></div></td></tr></table></figure><h2 id="转义符"><a href="#转义符" class="headerlink" title="转义符 \"></a>转义符 <code>\</code></h2><h3 id="字面量转义符"><a href="#字面量转义符" class="headerlink" title="字面量转义符"></a>字面量转义符</h3><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> price = <span class="hljs-string">&quot;12.34&quot;</span>;<br><span class="hljs-keyword">let</span> errorPrice = <span class="hljs-string">&quot;12@34&quot;</span>;<br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-regexp">/\d+\.\d+/</span>.test(price));<span class="hljs-comment">// true</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-regexp">/\d+\.\d+/</span>.test(errorPrice));<span class="hljs-comment">// false</span><br></code></pre></div></td></tr></table></figure><h3 id="对象中的转义字符"><a href="#对象中的转义字符" class="headerlink" title="对象中的转义字符"></a>对象中的转义字符</h3><p>字符串会将 “\” 符号忽略，因此正则表达式对象中,如果字符串包含 “\” ，达不到转义效果。</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> price = <span class="hljs-string">&quot;12.34&quot;</span>;<br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-regexp">/\d+\.\d+/</span>.test(price));<span class="hljs-comment">// true</span><br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;\d+\.\d+&quot;</span>);<span class="hljs-comment">// &quot;d+.d+&quot;</span><br><span class="hljs-keyword">let</span> reg = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">&quot;\d+\.\d+&quot;</span>);<br><span class="hljs-built_in">console</span>.log(reg.test(price));<span class="hljs-comment">// false</span><br></code></pre></div></td></tr></table></figure><p>解决办法是 “\” 再加 <code>\</code>, 表示 给 “\” 添加转义，告诉字符串不要忽略 “\“ </p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;\d+\.\d+&quot;</span>);<span class="hljs-comment">// &quot;\d+\.\d+&quot;</span><br><span class="hljs-keyword">let</span> reg = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">&quot;\d+\.\d+&quot;</span>);<br><span class="hljs-built_in">console</span>.log(reg.test(price));<span class="hljs-comment">// true</span><br></code></pre></div></td></tr></table></figure><h2 id="字符串边界约束"><a href="#字符串边界约束" class="headerlink" title="字符串边界约束"></a>字符串边界约束</h2><p> <code>^</code> 表示以其后匹配字符开始；<code>$</code> 表示以其前匹配字符结尾。</p><p>举例：限制输入 3-6 位字母，匹配成功则响应 “成功”，匹配失败则响应 “失败”。</p><p>html:</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span> = <span class="hljs-string">&quot;user&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>JavaScript:</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">document</span><br>  .querySelector(<span class="hljs-string">&quot;[name=&#x27;user&#x27;]&quot;</span>)<br>  .addEventListener(<span class="hljs-string">&quot;keyup&quot;</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br><span class="hljs-keyword">let</span> flag =<span class="hljs-built_in">this</span>.value.match(<span class="hljs-regexp">/^[a-z]&#123;3,6&#125;$/</span>);<br>  <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&quot;span&quot;</span>).innerHTML = flag?<span class="hljs-string">&quot;成功&quot;</span>:<span class="hljs-string">&quot;失败&quot;</span>;<br>&#125;);<br></code></pre></div></td></tr></table></figure><h2 id="数字相关元字符"><a href="#数字相关元字符" class="headerlink" title="数字相关元字符"></a>数字相关元字符</h2><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> ad= <span class="hljs-string">&quot;Andy 8421&quot;</span>;<br><br><span class="hljs-built_in">console</span>.log(ad.match(<span class="hljs-regexp">/\d/</span>));<span class="hljs-comment">// [&quot;8&quot;, index: 5, input: &quot;Andy 8421&quot;, groups: undefined]</span><br><span class="hljs-built_in">console</span>.log(ad.match(<span class="hljs-regexp">/\d/g</span>));<span class="hljs-comment">// [&quot;8&quot;, &quot;4&quot;, &quot;2&quot;, &quot;1&quot;]</span><br><span class="hljs-built_in">console</span>.log(ad.match(<span class="hljs-regexp">/\d+/</span>));<span class="hljs-comment">// [&quot;8421&quot;, index: 5, input: &quot;Andy 8421&quot;, groups: undefined]</span><br><br><span class="hljs-built_in">console</span>.log(ad.match(<span class="hljs-regexp">/\D/</span>));<span class="hljs-comment">// [&quot;A&quot;, index: 0, input: &quot;Andy 8421&quot;, groups: undefined]</span><br><span class="hljs-built_in">console</span>.log(ad.match(<span class="hljs-regexp">/\D/g</span>));<span class="hljs-comment">// [&quot;A&quot;, &quot;n&quot;, &quot;d&quot;, &quot;y&quot;, &quot; &quot;]</span><br><span class="hljs-built_in">console</span>.log(ad.match(<span class="hljs-regexp">/\D+/</span>));<span class="hljs-comment">// [&quot;Andy &quot;, index: 0, input: &quot;Andy 8421&quot;, groups: undefined]</span><br><br><span class="hljs-keyword">let</span> telList = <span class="hljs-string">`</span><br><span class="hljs-string">  Jackie: 010-9999999,</span><br><span class="hljs-string">  Eason: 020-8888888</span><br><span class="hljs-string">`</span>;<br><br><span class="hljs-built_in">console</span>.log(telList.match(<span class="hljs-regexp">/\d&#123;3&#125;-\d&#123;7,8&#125;/</span>));<span class="hljs-comment">// [&quot;010-9999999&quot;, index: 11, input: &quot;\n  Jackie: 010-9999999,\n  Eason: 020-8888888\n&quot;, groups: undefined]</span><br><span class="hljs-built_in">console</span>.log(telList.match(<span class="hljs-regexp">/\d&#123;3&#125;-\d&#123;7,8&#125;/g</span>));<span class="hljs-comment">// [&quot;010-9999999&quot;, &quot;020-8888888&quot;]</span><br><br><span class="hljs-built_in">console</span>.log(telList.match(<span class="hljs-regexp">/[^-\d:,\s]+/g</span>));<span class="hljs-comment">// [&quot;Jackie&quot;, &quot;Eason&quot;]</span><br></code></pre></div></td></tr></table></figure><p>解释：</p><p><code>D</code> :匹配除数字以外的字符;</p><p><code>g</code> : 全局匹配</p><p><code>+</code> : 整体匹配</p><p><code>[^ ]</code> ：表示匹配除了……以外的字符</p><p>​            <code>[^-\d:,\s]</code> : 匹配除了 “-”  数字  “，”   空白 “：” 以外的字符</p><p><code>s</code> : 匹配换行符</p><p><code>S</code> ：匹配非换行符</p><h2 id="w-与-W-元字符"><a href="#w-与-W-元字符" class="headerlink" title="w 与 W 元字符"></a><code>w</code> 与 <code>W</code> 元字符</h2><p>w 元字符：匹配字母、数字、下划线；</p><p>W 元字符：匹配非（字母、数字、下划线）</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> userName = prompt(<span class="hljs-string">&quot;请输入用户名&quot;</span>);<br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-regexp">/^[a-z]\w&#123;4,9&#125;$/</span>.test(userName));<br></code></pre></div></td></tr></table></figure><h2 id="匹配任何字符"><a href="#匹配任何字符" class="headerlink" title="匹配任何字符"></a>匹配任何字符</h2><p><code>[\s\S]+</code> ：匹配任何字符</p><p><code>[\d\D]+</code> ：匹配任何字符</p><p><code>[\w\W]+</code> ：匹配任何字符</p><h2 id="m-多行匹配修正符"><a href="#m-多行匹配修正符" class="headerlink" title="m 多行匹配修正符"></a><code>m</code> 多行匹配修正符</h2><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> list = <span class="hljs-string">`</span><br><span class="hljs-string">  #1 Jackie,64  #</span><br><span class="hljs-string">  #2 Eason,33   #</span><br><span class="hljs-string">  #3 andy,18    #</span><br><span class="hljs-string">    #ERROR     #   ERROR</span><br><span class="hljs-string">  #4 wife,18    #</span><br><span class="hljs-string">`</span>;<br><br><span class="hljs-keyword">let</span> message = list.match(<span class="hljs-regexp">/^\s*#\d+\s+.+\s+#$/gm</span>).map(<span class="hljs-function"><span class="hljs-params">v</span>=&gt;</span>&#123;<br>  v=v.replace(<span class="hljs-regexp">/\s*#\d+\s*/</span>,<span class="hljs-string">&quot;&quot;</span>).replace(<span class="hljs-regexp">/\s+#/</span>,<span class="hljs-string">&quot;&quot;</span>);<br>  [name,age]=v.split(<span class="hljs-string">&quot;,&quot;</span>);<br>  <span class="hljs-keyword">return</span> &#123;name,age&#125;;<br>&#125;);<br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">JSON</span>.stringify(message,<span class="hljs-literal">null</span>,<span class="hljs-number">2</span>));<br></code></pre></div></td></tr></table></figure><p>output:</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">[<br>  &#123;<br>    <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;Jackie&quot;</span>,<br>    <span class="hljs-string">&quot;age&quot;</span>: <span class="hljs-string">&quot;64&quot;</span><br>  &#125;,<br>  &#123;<br>    <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;Eason&quot;</span>,<br>    <span class="hljs-string">&quot;age&quot;</span>: <span class="hljs-string">&quot;33&quot;</span><br>  &#125;,<br>  &#123;<br>    <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;andy&quot;</span>,<br>    <span class="hljs-string">&quot;age&quot;</span>: <span class="hljs-string">&quot;18&quot;</span><br>  &#125;,<br>  &#123;<br>    <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;wife&quot;</span>,<br>    <span class="hljs-string">&quot;age&quot;</span>: <span class="hljs-string">&quot;18&quot;</span><br>  &#125;<br>]<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BitByBit 记账 Vue 版开发记录</title>
    <link href="/2021/08/20/BitByBit%E8%AE%B0%E8%B4%A6Vue%E7%89%88%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/"/>
    <url>/2021/08/20/BitByBit%E8%AE%B0%E8%B4%A6Vue%E7%89%88%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h2 id="使用-svg-sprite-loader-引入-svg-文件"><a href="#使用-svg-sprite-loader-引入-svg-文件" class="headerlink" title="使用 svg-sprite-loader 引入 .svg 文件"></a>使用 svg-sprite-loader 引入 .svg 文件</h2><p><img src="/2021/08/20/BitByBit%E8%AE%B0%E8%B4%A6Vue%E7%89%88%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/1630137354858.png"></p><p>TypeScript 中如果直接引入 .svg 文件将报错： <code>cannot find module “xxx.svg”</code></p><p>搜索资料，发现需要在 Vue 项目的 <code>shims-vue.d.ts</code> 文件中添加如下配置：</p><figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">declare</span> <span class="hljs-built_in">module</span> <span class="hljs-string">&quot;*.svg&quot;</span> &#123;<br>  <span class="hljs-keyword">const</span> content: <span class="hljs-built_in">any</span>;<br>  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> content;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>但是随后发现引入进来的 <code>.svg</code> 无法显示图标，控制台打印引入的 <code>.svg</code> 文件得到的并不是图标文件，而是一个字符串形式的路径。</p><p>这个路径应该可以直接作为 <img> 标签的 <code>src</code> 传入，这样引入的就不是图标而是图片了。但是这种方法使得随后修改 <code>.svg</code> 文件源代码更加麻烦，同时图片相对图标有所失真。</p><p><img src="/2021/08/20/BitByBit%E8%AE%B0%E8%B4%A6Vue%E7%89%88%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/1630137987356.png" alt="为解析时，引入的是文件路径"></p><p>于是我查阅相关资料，希望可以直接解析出 <code>.svg</code> 源文件。发现缺少 <code>svg-loader</code> 导致webpack无法解析出 .svg 文件。目前有一个较好用的插件： <code>svg-sprite-loader</code> 可以解决这个问题。</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">yarn add svg-sprite-loader -D<br></code></pre></div></td></tr></table></figure><p>官方给出的 <code>webpage.config</code> 配置如下：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">&#123;<br>  <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.svg$/</span>,<br>  loader: <span class="hljs-string">&#x27;svg-sprite-loader&#x27;</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>配置插件：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">&#123;<br>  <span class="hljs-attr">plugins</span>: [<br>    <span class="hljs-keyword">new</span> SpriteLoaderPlugin(&#123;<br>      <span class="hljs-attr">plainSprite</span>: <span class="hljs-literal">true</span>,<br>      <span class="hljs-attr">spriteAttrs</span>: &#123;<br>        <span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;my-custom-sprite-id&#x27;</span><br>      &#125;<br>    &#125;)<br>  ]<br>&#125;<br></code></pre></div></td></tr></table></figure><p>但是<strong>新的问题是 Vue-CLI 并不提供 <code>Webpack.config.js</code> 配置文件</strong>，创建的项目下只有一个 <code>vue.config.js</code> 。最后，我选择使用根据 Vue-CLI 的 <strong>链式操作</strong> 将以上代码翻译成 <code>vue.config.js</code> 接受的代码。修改源文件，例如：<code>.svg</code> 图标颜色也比较方便，直接改 <code>vue.config.js</code> 配置文件即可：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);<br><br><span class="hljs-built_in">module</span>.exports = &#123;<br>    <span class="hljs-attr">chainWebpack</span>: <span class="hljs-function"><span class="hljs-params">config</span> =&gt;</span> &#123;<br>        <span class="hljs-keyword">const</span> dir = path.resolve(__dirname, <span class="hljs-string">&#x27;src/assets/icons&#x27;</span>);<br><br>        <span class="hljs-comment">// 配置svg-sprite-loder</span><br>        config.module<br>            .rule(<span class="hljs-string">&#x27;svg-sprite&#x27;</span>)<br>            .test(<span class="hljs-regexp">/\.svg$/</span>)<br>            .include.add(dir).end() <span class="hljs-comment">// 只包含 icons 目录</span><br>            .use(<span class="hljs-string">&#x27;svg-sprite-loader&#x27;</span>).loader(<span class="hljs-string">&#x27;svg-sprite-loader&#x27;</span>)<br>            .options(&#123;<span class="hljs-attr">extract</span>: <span class="hljs-literal">false</span>&#125;).end();<span class="hljs-comment">// 不将其解析出文件</span><br><br>        <span class="hljs-comment">//  删除原有彩色</span><br>        <span class="hljs-comment">// .use(&#x27;svgo-loader&#x27;).loader(&#x27;svgo-loader&#x27;).tap(options =&gt; (&#123;...options, plugins: [&#123;removeAttrs: &#123;attrs: &#x27;fill&#x27;&#125;&#125;]&#125;)).end();</span><br><br>        <span class="hljs-comment">// 配置插件</span><br>        config.plugin(<span class="hljs-string">&#x27;svg-sprite&#x27;</span>).use(<span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;svg-sprite-loader/plugin&#x27;</span>), [&#123;<span class="hljs-attr">plainSprite</span>: <span class="hljs-literal">true</span>&#125;]);<br><br>        <span class="hljs-comment">// 其他 svg loader 排除 icons 目录</span><br>        config.module.rule(<span class="hljs-string">&#x27;svg&#x27;</span>).exclude.add(dir); <br><br>        config<br>            .plugin(<span class="hljs-string">&#x27;html&#x27;</span>)<br>            .tap(<span class="hljs-function"><span class="hljs-params">args</span> =&gt;</span> &#123;<br>                args[<span class="hljs-number">0</span>].title = <span class="hljs-string">&#x27;BitByBit&#x27;</span><br>                <span class="hljs-keyword">return</span> args<br>            &#125;);<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>随后 <code>&lt;symbol&gt;</code>  标签被引入 <code>&lt;svg&gt;</code> ，此时便可正常使用 <strong><code>svg-symbol</code></strong> 了:</p><figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> money <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@/assents/icons/money.svg&quot;</span>;<br><span class="hljs-built_in">console</span>.log(money);<br></code></pre></div></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">svg</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">use</span> <span class="hljs-attr">:xlink:href</span>=<span class="hljs-string">&quot;#money&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">svg</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p><img src="/2021/08/20/BitByBit%E8%AE%B0%E8%B4%A6Vue%E7%89%88%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/1630140880228.png" alt="正常引入"></p><h3 id="一次性引入所有-svg-文件"><a href="#一次性引入所有-svg-文件" class="headerlink" title="一次性引入所有 .svg 文件"></a>一次性引入所有 .svg 文件</h3><p>每次引入图标文件都要写一遍 <code>svg-symbol</code> 的代码，十分冗余。经过大量查阅资料，最终我使用以下方法一次性引入了所有文件：</p><figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> importAll = <span class="hljs-function">(<span class="hljs-params">requireContext: __WebpackModuleApi.RequireContext</span>) =&gt;</span> requireContext.keys().forEach(requireContext);<br><span class="hljs-keyword">try</span> &#123;<br>    importAll(<span class="hljs-built_in">require</span>.context(<span class="hljs-string">&quot;../assets/icons&quot;</span>, <span class="hljs-literal">true</span>, <span class="hljs-regexp">/\.svg$/</span>));<br>&#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>    <span class="hljs-built_in">console</span>.log(error);<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="重大-bug：手机端微信浏览器中-window-prompt-无效"><a href="#重大-bug：手机端微信浏览器中-window-prompt-无效" class="headerlink" title="重大 bug：手机端微信浏览器中 window.prompt() 无效"></a>重大 bug：手机端微信浏览器中 window.prompt() 无效</h2><p>PC 端和手机浏览器端开发测试完毕，当我准备最终发布时，竟发现一个重大 bug ：<strong>微信手机端浏览器</strong>上无法添加标签。经过多端浏览器测试，发现也只有微信浏览器无法添加标签。这说明产生的 bug 不是代码的问题，原因可能是手机微信浏览器的数据库存储 或者 原生 api 不兼容手机微信浏览器。但是由于 Statistics 保存功能可以正常使用，统计图和收支明细也都可以正常显示，问题肯定不是出在 localStorage 上。最终确定JavaScript 原生api 不兼容手机端微信浏览器。经过打断点，发现添加标签时以下代码未执行，这证明了我的推断：</p><figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TagHelper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Vue</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">createTag</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">const</span> name = <span class="hljs-built_in">window</span>.prompt(<span class="hljs-string">&quot;请输入自定义标签&quot;</span>);<br>        <span class="hljs-keyword">if</span> (name) &#123;<br>            <span class="hljs-comment">// 此句未执行</span><br>            <span class="hljs-built_in">this</span>.$store.commit(<span class="hljs-string">&quot;createTag&quot;</span>, name);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 此句执行</span><br>            <span class="hljs-built_in">window</span>.alert(<span class="hljs-string">&quot;fuck 标签名不能为空&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.$store.state.createTagError) &#123;<br>            <span class="hljs-built_in">window</span>.alert(map[<span class="hljs-built_in">this</span>.$store.state.createTagError.message] || <span class="hljs-string">&quot;未知错误&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>手机端微信浏览器添加标签时，页面跳出待提交提示框，但是并没有被阻塞直接弹出 <code>&quot;fuck 标签名不能为空&quot;</code> ，这说明微信不认识 <code>window.prompt();</code> ，它拿到的 <code>name</code> 值为 <code>undefined</code></p><p><img src="/2021/08/20/BitByBit%E8%AE%B0%E8%B4%A6Vue%E7%89%88%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/1630157942279.png" alt="手机端微信浏览器不认识 window.prompt() 方法"></p><p>为此，我专门自己封装了 <code>MyPrompt.vue</code> 组件解决了这个 bug。</p><h3 id="Vue-实现输入弹框"><a href="#Vue-实现输入弹框" class="headerlink" title="Vue 实现输入弹框"></a>Vue 实现输入弹框</h3><p>主要使用 v-if 来实现输入弹框。</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;mask&quot;</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;showModal&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;showModal=false&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;showModal=true&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;add&quot;</span>&gt;</span>添加<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;pop&quot;</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;showModal&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;prompt&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>请输入新增标签名：<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">input</span></span><br><span class="hljs-tag">                           <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span></span><br><span class="hljs-tag">                           <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;此处输入标签名&quot;</span></span><br><span class="hljs-tag">                           /&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;showModal=false&quot;</span>&gt;</span>提交<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></div></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript">&lt;script lang=<span class="hljs-string">&quot;ts&quot;</span>&gt;<br>    <span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;<br>    <span class="hljs-keyword">import</span> &#123;Component, Prop&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue-property-decorator&quot;</span>;<br>    <span class="hljs-meta">@Component</span><br>    <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyPrompt</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Vue</span> </span>&#123;<br>        showModal = <span class="hljs-literal">false</span>;<br>    &#125;<br>&lt;/script&gt;<br></code></pre></div></td></tr></table></figure><h3 id="实现新增标签功能"><a href="#实现新增标签功能" class="headerlink" title="实现新增标签功能"></a>实现新增标签功能</h3><p>应该可以直接在 MyPrompt 上完成添加标签操作，测试过的确没有问题，控制台并没有报警告。但本项目还是选择：按钮在父组件 Label 和 Tags ，弹框是子组件 MyPrompt ，添加标签使用父子组件传值来实现。</p><p>父组件：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">MyPrompt</span></span><br><span class="hljs-tag">            <span class="hljs-attr">:newName</span>=<span class="hljs-string">&quot;newName&quot;</span></span><br><span class="hljs-tag">            @<span class="hljs-attr">update:newName</span>=<span class="hljs-string">&quot;addNewName&quot;</span></span><br><span class="hljs-tag">            @<span class="hljs-attr">submit:newName</span>=<span class="hljs-string">&quot;createTag&quot;</span></span><br><span class="hljs-tag">        /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></div></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript">&lt;script lang=<span class="hljs-string">&quot;ts&quot;</span>&gt;<br>    <span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;<br>    <span class="hljs-keyword">import</span> &#123;Component&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue-property-decorator&quot;</span>;<br><br>    <span class="hljs-meta">@Component</span><br>    <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Tags</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Vue</span> </span>&#123;<br>        newName = <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-function"><span class="hljs-title">addNewName</span>(<span class="hljs-params">value: <span class="hljs-built_in">string</span></span>)</span> &#123;<br>            <span class="hljs-built_in">this</span>.newName = value;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-title">createTag</span>(<span class="hljs-params"></span>)</span> &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.newName) &#123;<br>                <span class="hljs-built_in">this</span>.$store.commit(<span class="hljs-string">&quot;createTag&quot;</span>, <span class="hljs-built_in">this</span>.newName);<br>                <span class="hljs-built_in">this</span>.newName = <span class="hljs-string">&quot;&quot;</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-built_in">window</span>.alert(<span class="hljs-string">&quot;标签名不能为空&quot;</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>&lt;/script&gt;<br></code></pre></div></td></tr></table></figure><p>子组件：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;mask&quot;</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;showModal&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;showModal=false&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;showModal=true&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;add&quot;</span>&gt;</span>添加<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;pop&quot;</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;showModal&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;prompt&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>请输入新增标签名：<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">input</span></span><br><span class="hljs-tag">                            <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span></span><br><span class="hljs-tag">                            <span class="hljs-attr">:newName</span>=<span class="hljs-string">&quot;newName&quot;</span></span><br><span class="hljs-tag">                            <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;此处输入标签名&quot;</span></span><br><span class="hljs-tag">                            @<span class="hljs-attr">input</span>=<span class="hljs-string">&quot;onAddNewName($event.target.value)&quot;</span></span><br><span class="hljs-tag">                    /&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">button</span></span><br><span class="hljs-tag">                            @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;showModal=false;onSubmit()&quot;</span></span><br><span class="hljs-tag">                            <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;btn&quot;</span></span><br><span class="hljs-tag">                    &gt;</span>提交<br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></div></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript">&lt;script lang=<span class="hljs-string">&quot;ts&quot;</span>&gt;<br>    <span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;<br>    <span class="hljs-keyword">import</span> &#123;Component, Prop&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue-property-decorator&quot;</span>;<br><br>    <span class="hljs-meta">@Component</span><br>    <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyPrompt</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Vue</span> </span>&#123;<br>        showModal = <span class="hljs-literal">false</span>;<br>        <span class="hljs-meta">@Prop</span>(&#123;<span class="hljs-attr">default</span>: <span class="hljs-string">&quot;&quot;</span>&#125;)<br>        <span class="hljs-keyword">readonly</span> newName!: <span class="hljs-built_in">string</span>;<br><br>        <span class="hljs-function"><span class="hljs-title">onAddNewName</span>(<span class="hljs-params">value:<span class="hljs-built_in">string</span></span>)</span>&#123;<br>            <span class="hljs-built_in">this</span>.$emit(<span class="hljs-string">&quot;update:newName&quot;</span>,value);<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-title">onSubmit</span>(<span class="hljs-params"></span>)</span>&#123;<br>            <span class="hljs-built_in">this</span>.$emit(<span class="hljs-string">&quot;submit:newName&quot;</span>);<br>        &#125;<br>    &#125;<br>&lt;/script&gt;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端路由</title>
    <link href="/2021/08/12/%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1/"/>
    <url>/2021/08/12/%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1/</url>
    
    <content type="html"><![CDATA[<h1 id="前端路由"><a href="#前端路由" class="headerlink" title="前端路由"></a>前端路由</h1><h2 id="1-路由是什么"><a href="#1-路由是什么" class="headerlink" title="1.路由是什么"></a>1.路由是什么</h2><h3 id="1-1-路由的概念"><a href="#1-1-路由的概念" class="headerlink" title="1.1 路由的概念"></a>1.1 路由的概念</h3><p>路由就是“<strong>分发请求</strong>”，是将互联网的网络信息从源地址传输到目的地址活动。路由通常根据<strong>路由表</strong>来引导分组传送。将它做成硬件的话，就称作路由器。</p><p>前端中的路由就是由URL到界面的映射。</p><h3 id="1-2-默认路由和-404-路由"><a href="#1-2-默认路由和-404-路由" class="headerlink" title="1.2 默认路由和 404 路由"></a>1.2 默认路由和 404 路由</h3><ol><li><p>默认路由：是对IP数据包中的目的地址找不到存在的其他路由时，路由器所选择的路由。即，URL 的 <code>hash</code>  为空时默认选择的 hash值。</p></li><li><p>404 路由 / 保底路由：是对IP数据包中的目的地址找不到存在的映射对象时，路由器所选择的路由。即，URL的 <code>hash</code> 在路由表中找不到时（错误时），选择预设的 404 hash。</p></li></ol><h2 id="2-前端路由的三种实现"><a href="#2-前端路由的三种实现" class="headerlink" title="2.前端路由的三种实现"></a>2.前端路由的三种实现</h2><p>前两种模式利用了 <code>window.location</code> 接口，将路由存入URL。这个接口表示 window 对象所展示的页面的地址等信息，对于一个完整的 url，<code>location</code> 的 protocol，<code>host</code>，<code>pathname</code>，<code>search</code> ，<code>hash</code> 分别表示了每一部分字段。</p><hr><p>例如，对于<a href="http://www.google.com.hk/news?s=a#page1%EF%BC%8C">http://www.google.com.hk/news?s=a#page1，</a><br>    location.protocol = “http:”<br>    location.host = “<a href="http://www.google.com.hk&quot;(包括hostname和port(80))/">www.google.com.hk&quot;（包括hostname和port(80)）</a><br>    location.pathname = “/news”<br>    location.search = “?s=a”<br>    location.hash = “#page1”</p><hr><h3 id="2-1-hash-模式"><a href="#2-1-hash-模式" class="headerlink" title="2.1 hash 模式"></a>2.1 hash 模式</h3><p>hash 模式通过构建路由表，建立URL到界面之间的映射。然后通过监听 <code>hashchange</code> 来响应URL变化，进而切换界面。</p><p>具体地，当用户点击 <code>a</code> 标签时，<code>href</code> 发生变化进而URL变化，随即触发 <code>hashchange</code> 事件。</p><p>index.html</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#1&quot;</span>&gt;</span>go to 1<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#2&quot;</span>&gt;</span>go to 2<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#3&quot;</span>&gt;</span>go to 3<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#4&quot;</span>&gt;</span>go to 4<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;div404&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;display: none;&quot;</span>&gt;</span>你访问的内容不存在<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;main.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>main.js</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> app = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&quot;#app&quot;</span>);<br><span class="hljs-keyword">const</span> div1 = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&quot;div&quot;</span>);<br>div1.innerHTML = <span class="hljs-string">&#x27;1&#x27;</span>;<br><span class="hljs-keyword">const</span> div2 = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&quot;div&quot;</span>);<br>div2.innerHTML = <span class="hljs-string">&#x27;2&#x27;</span>;<br><span class="hljs-keyword">const</span> div3 = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&quot;div&quot;</span>);<br>div3.innerHTML = <span class="hljs-string">&#x27;3&#x27;</span>;<br><span class="hljs-keyword">const</span> div4 = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&quot;div&quot;</span>);<br>div4.innerHTML = <span class="hljs-string">&#x27;4&#x27;</span>;<br><br><span class="hljs-keyword">const</span> routeTable = &#123;<br>    <span class="hljs-string">&quot;1&quot;</span>: div1,<br>    <span class="hljs-string">&quot;2&quot;</span>: div2,<br>    <span class="hljs-string">&quot;3&quot;</span>: div3,<br>    <span class="hljs-string">&quot;4&quot;</span>: div4<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">route</span>(<span class="hljs-params">container</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> number = <span class="hljs-built_in">window</span>.location.hash.substr(<span class="hljs-number">1</span>);<br><br>    <span class="hljs-comment">// 获取当前页面的 id</span><br>    number = number || <span class="hljs-number">1</span>;<br><br>    <span class="hljs-comment">// 获取由 url 映射的 div界面</span><br>    <span class="hljs-keyword">let</span> div = routeTable[number.toString()];<br><br>    <span class="hljs-keyword">if</span> (!div) &#123;<br>        div = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&quot;#div404&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 渲染 div</span><br>    div.style.display = <span class="hljs-string">&quot;block&quot;</span>;<br><br>    container.innerHTML = <span class="hljs-string">&quot;&quot;</span>;<br><br>    <span class="hljs-comment">// 展示 div</span><br>    container.appendChild(div);<br>&#125;<br><br><span class="hljs-comment">// 初始路由</span><br>route(app);<br><br><span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">&quot;hashchange&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    route(app);<br>&#125;)<br></code></pre></div></td></tr></table></figure><h4 id="hash-模式的优缺点"><a href="#hash-模式的优缺点" class="headerlink" title="hash 模式的优缺点"></a>hash 模式的优缺点</h4><p>优点：兼容性好。任何情况下都可以使用前端路由，例如本地模式下适合使用hash模式做路由。</p><p>缺点：SEO不友好。服务器并不能接收 <code>hash</code> 。URL中的 hash 只是在客户端的一种状态标记，当客户端向服务器发送请求时，<code>hash</code> 部分不会被发送。</p><h3 id="2-2-history-模式"><a href="#2-2-history-模式" class="headerlink" title="2.2 history 模式"></a>2.2 history 模式</h3><p><strong>当服务器将所有前端路由都渲染在同一个页面下时</strong>，才可以使用history模式。</p><p>history 模式先取消 a 标签的所有默认操作，然后使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/History/pushState"><code>windo.history.pushState()</code></a> 方法重新设置URL的 location.pathname;  最后封装 <code>onStateChange()</code> 方法通知浏览器重新路由。</p><p>index.html</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;/1&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;link&quot;</span>&gt;</span>go to 1<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;/2&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;link&quot;</span>&gt;</span>go to 2<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;/3&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;link&quot;</span>&gt;</span>go to 3<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;/4&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;link&quot;</span>&gt;</span>go to 4<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;div404&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;display: none;&quot;</span>&gt;</span>你访问的内容不存在<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;main.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>main.js</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> app = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&quot;#app&quot;</span>);<br><span class="hljs-keyword">const</span> div1 = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&quot;div&quot;</span>);<br>div1.innerHTML = <span class="hljs-string">&quot;1&quot;</span>;<br><span class="hljs-keyword">const</span> div2 = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&quot;div&quot;</span>);<br>div2.innerHTML = <span class="hljs-string">&quot;2&quot;</span>;<br><span class="hljs-keyword">const</span> div3 = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&quot;div&quot;</span>);<br>div3.innerHTML = <span class="hljs-string">&quot;3&quot;</span>;<br><span class="hljs-keyword">const</span> div4 = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&quot;div&quot;</span>);<br>div4.innerHTML = <span class="hljs-string">&quot;4&quot;</span>;<br><span class="hljs-keyword">const</span> routeTable = &#123;<br>    <span class="hljs-string">&quot;/1&quot;</span>: div1,<br>    <span class="hljs-string">&quot;/2&quot;</span>: div2,<br>    <span class="hljs-string">&quot;/3&quot;</span>: div3,<br>    <span class="hljs-string">&quot;/4&quot;</span>: div4<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">route</span>(<span class="hljs-params">container</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> number = <span class="hljs-built_in">window</span>.location.pathname;<br><br>    <span class="hljs-keyword">if</span> (number === <span class="hljs-string">&quot;/&quot;</span>) &#123;<br>        number = <span class="hljs-string">&quot;/1&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 获取界面</span><br>    <span class="hljs-keyword">let</span> div = routeTable[number.toString()];<br>    <span class="hljs-keyword">if</span> (!div) &#123;<br>        div = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&quot;#div404&quot;</span>);<br>    &#125;<br>    div.style.display = <span class="hljs-string">&quot;block&quot;</span>;<br><br>    <span class="hljs-comment">// 展示界面</span><br>    container.innerHTML = <span class="hljs-string">&quot;&quot;</span>;<br>    container.appendChild(div);<br>&#125;<br><br><span class="hljs-keyword">const</span> allA = <span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">&quot;a.link&quot;</span>);<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> a <span class="hljs-keyword">of</span> allA) &#123;<br>    a.addEventListener(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> &#123;<br>        e.preventDefault();<br>        <span class="hljs-keyword">const</span> href = a.getAttribute(<span class="hljs-string">&quot;href&quot;</span>);<br>        <span class="hljs-built_in">window</span>.history.pushState(<span class="hljs-literal">null</span>, <span class="hljs-string">`page <span class="hljs-subst">$&#123;href&#125;</span>`</span>, href);<br>        <span class="hljs-comment">// 通知</span><br>        onStateChange();<br>    &#125;);<br>&#125;<br><br>route(app);<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">onStateChange</span>(<span class="hljs-params"></span>) </span>&#123;<br>    route(app);<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="history-模式的优缺点"><a href="#history-模式的优缺点" class="headerlink" title="history 模式的优缺点"></a>history 模式的优缺点</h4><p>优点：URL 美观，可设置与当前URL同源的任意 URL</p><p>缺点：IE8 一下不支持，兼容性没有 hash 模式好，对服务器端的设置有要求。单机版路由不适合使用这种模式。</p><h3 id="2-3-memory模式"><a href="#2-3-memory模式" class="headerlink" title="2.3 memory模式"></a>2.3 memory模式</h3><p>memory 模式不使用URL存储（不使用 <code>window.location</code> API） ，而是使用本地数据库存储。前端路由一般使用 <code>localStorage</code> 进行存储。</p><p>index.html</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;/1&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;link&quot;</span>&gt;</span>go to 1<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;/2&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;link&quot;</span>&gt;</span>go to 2<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;/3&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;link&quot;</span>&gt;</span>go to 3<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;/4&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;link&quot;</span>&gt;</span>go to 4<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;div404&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;display: none;&quot;</span>&gt;</span>你访问的内容不存在<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;main.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>main.js</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> app = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&quot;#app&quot;</span>);<br><span class="hljs-keyword">const</span> div1 = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&quot;div&quot;</span>);<br>div1.innerHTML = <span class="hljs-string">&quot;1&quot;</span>;<br><span class="hljs-keyword">const</span> div2 = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&quot;div&quot;</span>);<br>div2.innerHTML = <span class="hljs-string">&quot;2&quot;</span>;<br><span class="hljs-keyword">const</span> div3 = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&quot;div&quot;</span>);<br>div3.innerHTML = <span class="hljs-string">&quot;3&quot;</span>;<br><span class="hljs-keyword">const</span> div4 = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&quot;div&quot;</span>);<br>div4.innerHTML = <span class="hljs-string">&quot;4&quot;</span>;<br><span class="hljs-keyword">const</span> routeTable = &#123;<br>    <span class="hljs-string">&quot;/1&quot;</span>: div1,<br>    <span class="hljs-string">&quot;/2&quot;</span>: div2,<br>    <span class="hljs-string">&quot;/3&quot;</span>: div3,<br>    <span class="hljs-string">&quot;/4&quot;</span>: div4<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">route</span>(<span class="hljs-params">container</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> number = <span class="hljs-built_in">window</span>.localStorage.getItem(<span class="hljs-string">&quot;pagePath&quot;</span>);<br><br>    <span class="hljs-keyword">if</span> (!number) number = <span class="hljs-string">&quot;/1&quot;</span>;<br><br>    <span class="hljs-keyword">let</span> div = routeTable[number.toString()];<br><br>    <span class="hljs-keyword">if</span> (!div) div = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&quot;#div404&quot;</span>);<br><br><br>    div.style.display = <span class="hljs-string">&quot;block&quot;</span>;<br>    container.innerHTML = <span class="hljs-string">&quot;&quot;</span>;<br>    container.appendChild(div);<br>&#125;<br><br><span class="hljs-keyword">const</span> allA = <span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">&quot;a.link&quot;</span>);<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> a <span class="hljs-keyword">of</span> allA) &#123;<br>    a.addEventListener(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> &#123;<br>        e.preventDefault();<br>        <span class="hljs-keyword">const</span> href = a.getAttribute(<span class="hljs-string">&quot;href&quot;</span>);<br>        <span class="hljs-built_in">window</span>.localStorage.setItem(<span class="hljs-string">&quot;pagePath&quot;</span>, href);<br>        route(app);<br>    &#125;)<br>&#125;<br><br>route(app);<br></code></pre></div></td></tr></table></figure><h4 id="memory-模式的优缺点"><a href="#memory-模式的优缺点" class="headerlink" title="memory 模式的优缺点"></a>memory 模式的优缺点</h4><p>memory 模式应用场景：适合于没有使用路径的本地app。例如react native、weex</p><p>缺点：由于 memory 模式没有使用URL，因此本质上就是一个单机版路由，路由不可分享。</p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>.sync修饰符</title>
    <link href="/2021/07/15/%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BA%8B%E4%BB%B6%E4%B8%AD.sync%E4%BF%AE%E9%A5%B0%E7%AC%A6/"/>
    <url>/2021/07/15/%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BA%8B%E4%BB%B6%E4%B8%AD.sync%E4%BF%AE%E9%A5%B0%E7%AC%A6/</url>
    
    <content type="html"><![CDATA[<h1 id="sync修饰符"><a href="#sync修饰符" class="headerlink" title=".sync修饰符"></a><a href="https://cn.vuejs.org/v2/guide/components-custom-events.html#sync-%E4%BF%AE%E9%A5%B0%E7%AC%A6">.sync修饰符</a></h1><p>有时候，我们需要对组件进行双向绑定。这么做的目的时避免父组件和子组件分别改变同一个prop值而产生冲突。具体思路是，只允许子组件向父组件发出修改组件值得意图，而实际修改组件值得动作由父组件“监听-响应“动作来完成。</p><p>这个过程利用了 <code>EventBus</code> 来完成父子组件之间得通信。</p><p>而<code>.sync</code> (2.3.0+) 语法糖，会扩展成一个更新父组件绑定值的 <code>v-on</code> 侦听器。</p><h2 id="一个案例"><a href="#一个案例" class="headerlink" title="一个案例"></a>一个案例</h2><p>具体见一下例子：</p><p>App.vue：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">&lt;template&gt;<br>  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span></span><br><span class="xml">    <span class="hljs-comment">&lt;!-- 父组件可以监听那个事件并根据需要更新一个本地的数据 property --&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>爸爸计划代儿子去&#123;&#123; travelPlan &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">hr</span> /&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">child-idea</span> <span class="hljs-attr">:sendData.sync</span>=<span class="hljs-string">&quot;travelPlan&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">child-idea</span>&gt;</span></span><br><span class="xml"></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;fatherIdea&quot;</span>&gt;</span>爸爸要去<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&lt;/template&gt;<br><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="javascript"><span class="xml"><span class="hljs-keyword">import</span> childIdea <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./Child.vue&quot;</span>;</span></span><br><span class="javascript"><span class="xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="javascript"><span class="xml">  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;index&quot;</span>,</span></span><br><span class="javascript"><span class="xml">  <span class="hljs-attr">components</span>: &#123; childIdea &#125;,</span></span><br><span class="javascript"><span class="xml">  <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span> &#123;</span></span><br><span class="javascript"><span class="xml">    <span class="hljs-keyword">return</span> &#123;</span></span><br><span class="javascript"><span class="xml">      <span class="hljs-attr">travelPlan</span>: <span class="hljs-string">&quot;爬山&quot;</span>,</span></span><br><span class="javascript"><span class="xml">    &#125;;</span></span><br><span class="javascript"><span class="xml">  &#125;,</span></span><br><span class="javascript"><span class="xml">  <span class="hljs-attr">methods</span>: &#123;</span></span><br><span class="javascript"><span class="xml">    <span class="hljs-function"><span class="hljs-title">fatherIdea</span>(<span class="hljs-params"></span>)</span> &#123;</span></span><br><span class="javascript"><span class="xml">      <span class="hljs-built_in">this</span>.travelPlan = <span class="hljs-string">&quot;爬山&quot;</span>;</span></span><br><span class="javascript"><span class="xml">    &#125;,</span></span><br><span class="javascript"><span class="xml">  &#125;,</span></span><br><span class="javascript"><span class="xml">&#125;;</span></span><br><span class="javascript"><span class="xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></div></td></tr></table></figure><p>Child.vue：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">&lt;template&gt;<br>  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;child-idea&quot;</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>儿子知道爸爸要带他去:&#123;&#123; sendData &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;childSelect&quot;</span>&gt;</span>儿子要去<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&lt;/template&gt;<br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="javascript"><span class="xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="javascript"><span class="xml">  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;childIdea&quot;</span>,</span></span><br><span class="javascript"><span class="xml">  <span class="hljs-attr">props</span>: [<span class="hljs-string">&quot;sendData&quot;</span>], <span class="hljs-comment">// 用来接收父组件传给子组件的数据</span></span></span><br><span class="javascript"><span class="xml">  <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span> &#123;</span></span><br><span class="javascript"><span class="xml">    <span class="hljs-keyword">return</span> &#123;</span></span><br><span class="javascript"><span class="xml">      <span class="hljs-attr">travelSite</span>: <span class="hljs-string">`迪斯尼`</span>,</span></span><br><span class="javascript"><span class="xml">    &#125;;</span></span><br><span class="javascript"><span class="xml">  &#125;,</span></span><br><span class="javascript"><span class="xml">  <span class="hljs-attr">methods</span>: &#123;</span></span><br><span class="javascript"><span class="xml">    <span class="hljs-function"><span class="hljs-title">childSelect</span>(<span class="hljs-params"></span>)</span> &#123;</span></span><br><span class="javascript"><span class="xml">      <span class="hljs-comment">// 表达子组件要修改父组件值的意图</span></span></span><br><span class="javascript"><span class="xml">      <span class="hljs-built_in">this</span>.$emit(<span class="hljs-string">&quot;update:sendData&quot;</span>, <span class="hljs-built_in">this</span>.travelSite); </span></span><br><span class="javascript"><span class="xml">    &#125;,</span></span><br><span class="javascript"><span class="xml">  &#125;,</span></span><br><span class="javascript"><span class="xml">&#125;;</span></span><br><span class="javascript"><span class="xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></div></td></tr></table></figure><p>其中，</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">child-idea</span> <span class="hljs-attr">:sendData.sync</span>=<span class="hljs-string">&quot;travelPlan&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">child-idea</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>展开写就是</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs HTML"><span class="hljs-tag">&lt;<span class="hljs-name">child-idea</span></span><br><span class="hljs-tag">    <span class="hljs-attr">:sendData</span>=<span class="hljs-string">&quot;travelPlan&quot;</span></span><br><span class="hljs-tag">    @<span class="hljs-attr">update:sendData</span>=<span class="hljs-string">&quot;travelPlan = $event&quot;</span></span><br><span class="hljs-tag">&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">child-idea</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h2 id="Vue中的EventBus"><a href="#Vue中的EventBus" class="headerlink" title="Vue中的EventBus"></a>Vue中的EventBus</h2><p>Vue封装了 EventBus：</p><ul><li>使用 <code>$emit</code> 定义并触发事件，并传参；事件名应为：<code>update:被监听的数据名</code></li><li>使用 <code>$event</code> 来获取其他组件中 <code>$emit</code> 的参数</li></ul><p>因此父组件可以监听事件<code>&quot;update:sendData&quot;</code>并根据需要更新本地的数据 property。</p><p><a href="https://codesandbox.io/s/jovial-murdock-qm5pk">点击这里看结果</a></p><p><img src="/2021/07/15/%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BA%8B%E4%BB%B6%E4%B8%AD.sync%E4%BF%AE%E9%A5%B0%E7%AC%A6/1626454149982.png" alt="1626454149982"></p><p>vue 修饰符sync的功能是：当一个子组件改变了一个 <code>prop</code> 的值时，这个变化也会同步到父组件中所绑定。这样就避免了父组件和子组件分别改变同一个prop值而产生冲突。</p>]]></content>
    
    
    <categories>
      
      <category>vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue的双向数据绑定</title>
    <link href="/2021/07/05/Vue%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A/"/>
    <url>/2021/07/05/Vue%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A/</url>
    
    <content type="html"><![CDATA[<h1 id="Vue的双向数据绑定"><a href="#Vue的双向数据绑定" class="headerlink" title="Vue的双向数据绑定"></a>Vue的双向数据绑定</h1><h2 id="一、什么是双向绑定"><a href="#一、什么是双向绑定" class="headerlink" title="一、什么是双向绑定"></a>一、什么是双向绑定</h2><p>Vue的双向绑定就是<strong>数据变化引起视图渲染（即数据响应式）</strong>，<strong>视图变化引起数据更新</strong>。</p><h2 id="二、Vue如何实现双向绑定"><a href="#二、Vue如何实现双向绑定" class="headerlink" title="二、Vue如何实现双向绑定"></a>二、Vue如何实现双向绑定</h2><h3 id="1-数据变化引起视图渲染"><a href="#1-数据变化引起视图渲染" class="headerlink" title="1. 数据变化引起视图渲染"></a>1. 数据变化引起视图渲染</h3><p>当把一个普通的 JavaScript 对象传入 Vue 实例作为 <code>data</code> 选项，Vue 将遍历此对象所有的 property，并使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty"><code>Object.defineProperty</code></a> 把这些 property 全部转为 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Working_with_Objects#%E5%AE%9A%E4%B9%89_getters_%E4%B8%8E_setters">getter/setter</a>。这个过程称为<strong>数据劫持</strong>。</p><p>这些 getter/setter 对用户来说是不可见的，但是在内部它们让 Vue 能够追踪依赖，在 property 被访问和修改时通知变更。</p><p>具体来说，</p><ul><li>当执行get()响应时，会调用<code>dep.depend()</code>，此函数将target对象push进<strong>监听队列</strong>（subscris），然后读取property。</li><li>当执行set()响应时，会先拿到新值，然后调用<code>dep.notify()</code>，此函数执行监听队列中的每个target，重新更新。</li></ul><p>每个组件实例都对应一个 <strong>watcher</strong> 实例，它会在组件渲染的过程中把“接触（Touch）”过的数据 property 记录为依赖。之后<strong>当依赖项的 setter 触发时，会通知 watcher，从而使它关联的组件重新渲染（这个过程DOM更新是异步的）</strong>。</p><p>具体介绍参见上一篇博客：<a href="https://yichang8421.github.io/2021/07/01/Vue%E6%95%B0%E6%8D%AE%E5%93%8D%E5%BA%94%E5%BC%8F/">Vue数据响应式</a></p><h3 id="2-视图变化引起数据更新"><a href="#2-视图变化引起数据更新" class="headerlink" title="2. 视图变化引起数据更新"></a>2. 视图变化引起数据更新</h3><p>这个相对数据响应式就非常简单了，我们只要利用事件的监听即可。</p><p>例如监听 input 事件，一般使用：<code>v-on:input</code>。有时也会使用<code>v-on:change</code>， onChange 事件是在移出焦点时才会触发。因此这样就不会实时地更新数据了，具体选择监听哪个事件看实际需求而定。</p><h2 id="三、Vue创建双向绑定"><a href="#三、Vue创建双向绑定" class="headerlink" title="三、Vue创建双向绑定"></a>三、Vue创建双向绑定</h2><p>首先看一段初始化代码，之后基于此 demo 创建双向绑定：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><br><span class="hljs-keyword">const</span> component = &#123;<br>    <span class="hljs-attr">template</span>: <span class="hljs-string">`</span><br><span class="hljs-string">        &lt;label&gt;</span><br><span class="hljs-string">            &lt;input type=&quot;text&quot; @input=&quot;handleInput&quot;&gt;</span><br><span class="hljs-string">        &lt;/label&gt;</span><br><span class="hljs-string">    `</span>,<br>    <span class="hljs-attr">methods</span>: &#123;<br>        handleInput (e) &#123;<br>            <span class="hljs-built_in">this</span>.$emit(<span class="hljs-string">&#x27;input&#x27;</span>, e.target.value)<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">new</span> Vue(&#123;<br>    <span class="hljs-attr">conponents</span>: &#123;<br>        <span class="hljs-attr">CompA</span>: component<br>    &#125;,<br>    <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#root&#x27;</span>,<br>    <span class="hljs-attr">template</span>: <span class="hljs-string">`</span><br><span class="hljs-string">        &lt;div&gt;</span><br><span class="hljs-string">            &lt;comp-a&gt;&lt;/comp-a&gt;</span><br><span class="hljs-string">        &lt;/div&gt;</span><br><span class="hljs-string">    `</span><br>&#125;)<br></code></pre></div></td></tr></table></figure><h3 id="绑定props和事件"><a href="#绑定props和事件" class="headerlink" title="绑定props和事件"></a>绑定props和事件</h3><h4 id="①数据变化引起视图渲染"><a href="#①数据变化引起视图渲染" class="headerlink" title="①数据变化引起视图渲染"></a>①数据变化引起视图渲染</h4><p>首先子组件要接受一个props，同时监听这个props</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> component = &#123;<br>    <span class="hljs-attr">props</span>: [<span class="hljs-string">&#x27;value&#x27;</span>],<br>    <span class="hljs-attr">template</span>: <span class="hljs-string">`</span><br><span class="hljs-string">        &lt;label&gt;</span><br><span class="hljs-string">            &lt;input type=&quot;text&quot; @input=&quot;handleInput&quot; :value=&quot;value&quot;&gt;</span><br><span class="hljs-string">        &lt;/label&gt;</span><br><span class="hljs-string">    `</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>这样父组件就可以从外部传入props：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">template: <span class="hljs-string">`</span><br><span class="hljs-string">    &lt;div&gt;</span><br><span class="hljs-string">        &lt;comp-a :value=&quot;value&quot;&gt;&lt;/comp-a&gt;</span><br><span class="hljs-string">    &lt;/div&gt;</span><br><span class="hljs-string">`</span>,<br>data () &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-attr">value</span>: <span class="hljs-string">&#x27;newValue&#x27;</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>每当外部传入value时，就会触发 <code>setter</code>，进而引起视图的渲染。</p><h4 id="②视图变化引起数据更新"><a href="#②视图变化引起数据更新" class="headerlink" title="②视图变化引起数据更新"></a>②视图变化引起数据更新</h4><p>父组件<strong>监听子组件暴露出的 <code>input</code> 事件</strong>（即Event Bus），当其触发时，会引起 value 的变化</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">template: <span class="hljs-string">`</span><br><span class="hljs-string">    &lt;div&gt;</span><br><span class="hljs-string">        &lt;comp-a :value=&quot;value&quot; @input=&quot;value = arguments[0]&quot;&gt;&lt;/comp-a&gt;</span><br><span class="hljs-string">    &lt;/div&gt;</span><br><span class="hljs-string">`</span>,<br></code></pre></div></td></tr></table></figure><p>其中，<code>arguments[0]</code> 即子组件传出的 <code>e.target.value</code></p><p>注意，此处并不是对子组件的 <code>props</code> 进行修改，而是<strong>监听子组件暴露的事件</strong>，然后修改自己的value</p><p>因此，完整代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><br><span class="hljs-keyword">const</span> component = &#123;<br>    <span class="hljs-attr">props</span>: [<span class="hljs-string">&#x27;value&#x27;</span>],<br>    <span class="hljs-attr">template</span>: <span class="hljs-string">`</span><br><span class="hljs-string">        &lt;label&gt;</span><br><span class="hljs-string">            &lt;input type=&quot;text&quot; @input=&quot;handleInput&quot; :value=&quot;value&quot;&gt;</span><br><span class="hljs-string">        &lt;/label&gt;</span><br><span class="hljs-string">    `</span>,<br>    <span class="hljs-attr">methods</span>: &#123;<br>        handleInput (e) &#123;<br>            <span class="hljs-built_in">this</span>.$emit(<span class="hljs-string">&#x27;input&#x27;</span>, e.target.value)<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">new</span> Vue(&#123;<br>    data () &#123;<br>        <span class="hljs-keyword">return</span> &#123;<br>            <span class="hljs-attr">value</span>: <span class="hljs-string">&#x27;newValue&#x27;</span><br>        &#125;<br>    <span class="hljs-attr">conponents</span>: &#123;<br>        <span class="hljs-attr">CompA</span>: component<br>    &#125;,<br>    <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#root&#x27;</span>,<br>    <span class="hljs-attr">template</span>: <span class="hljs-string">`</span><br><span class="hljs-string">        &lt;div&gt;</span><br><span class="hljs-string">        &lt;comp-a :value=&quot;value&quot; @input=&quot;value = arguments[0]&quot;&gt;&lt;/comp-a&gt;</span><br><span class="hljs-string">    &lt;/div&gt;</span><br><span class="hljs-string">    `</span><br>&#125;)<br></code></pre></div></td></tr></table></figure><h3 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h3><p>官方文档这样解释 v-model 的用法：</p><p><img src="/2021/07/05/Vue%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A/%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A.png"></p><p>由于以上 demo 中，父组件 :value 和 @input 比较冗余，所以 Vue 封装了 v-model 指令直接替换这两个指令：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">template: <span class="hljs-string">`</span><br><span class="hljs-string">    &lt;div&gt;</span><br><span class="hljs-string">        &lt;comp-a v-model=&quot;value&quot;&gt;&lt;/comp-a&gt;</span><br><span class="hljs-string">    &lt;/div&gt;</span><br><span class="hljs-string">`</span>,<br></code></pre></div></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在数据渲染时使用 <code>props</code> 渲染数据，将 <code>props</code> 绑定到子组件自身的数据上。</p><p>修改数据时更新自身数据来替代 <code>props</code> ，<code>watch</code> 子组件自身数据的改变，触发事件通知父组件更改绑定到 <code>props</code> 的数据。</p>]]></content>
    
    
    <categories>
      
      <category>vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue数据响应式</title>
    <link href="/2021/07/01/Vue%E6%95%B0%E6%8D%AE%E5%93%8D%E5%BA%94%E5%BC%8F/"/>
    <url>/2021/07/01/Vue%E6%95%B0%E6%8D%AE%E5%93%8D%E5%BA%94%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="Vue数据相应式"><a href="#Vue数据相应式" class="headerlink" title="Vue数据相应式"></a>Vue数据相应式</h1><p>Vue数据相应式：<strong>就是当修改普通JavaScript对象时，视图（view）会进行更新</strong>。</p><h2 id="响应式系统"><a href="#响应式系统" class="headerlink" title="响应式系统"></a>响应式系统</h2><p><img src="/2021/07/01/Vue%E6%95%B0%E6%8D%AE%E5%93%8D%E5%BA%94%E5%BC%8F/1625895230359.png" alt="1625895230359"></p><p>当把一个普通的 JavaScript 对象传入 Vue 实例作为 <code>data</code> 选项，Vue 将遍历此对象所有的 property，并使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty"><code>Object.defineProperty</code></a> 把这些 property 全部转为 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Working_with_Objects#%E5%AE%9A%E4%B9%89_getters_%E4%B8%8E_setters">getter/setter</a>。这个过程称为<strong>数据劫持</strong>。</p><p>这些 getter/setter 对用户来说是不可见的，但是在内部它们让 Vue 能够追踪依赖，在 property 被访问和修改时通知变更。</p><p>具体来说，</p><ul><li>当执行get()响应时，会调用<code>dep.depend()</code>，此函数将target对象push进<strong>监听队列</strong>（subscris），然后读取property。</li><li>当执行set()响应时，会先拿到新值，然后调用<code>dep.notify()</code>，此函数执行监听队列中的每个target，重新更新。</li></ul><p>每个组件实例都对应一个 <strong>watcher</strong> 实例，它会在组件渲染的过程中把“接触（Touch）”过的数据 property 记录为依赖。之后<strong>当依赖项的 setter 触发时，会通知 watcher，从而使它关联的组件重新渲染</strong>。</p><p>举例：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> target, total<br><span class="hljs-keyword">let</span> data = &#123;<span class="hljs-attr">price</span>:<span class="hljs-number">5</span>, <span class="hljs-attr">quantity</span>:<span class="hljs-number">2</span>&#125;<br><br><span class="hljs-comment">// 定义依赖（dependency-tracking）。</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dep</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-built_in">this</span>.subscribers= []<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">depend</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-comment">// 存储被监听对象target</span><br>        <span class="hljs-keyword">if</span>(target &amp;&amp; !<span class="hljs-built_in">this</span>.subscribers.includes(target))&#123;<br>            <span class="hljs-built_in">this</span>.subscribers.push(target)<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">notify</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-comment">// 更新target</span><br>        <span class="hljs-built_in">this</span>.subscribers.forEach(<span class="hljs-function"><span class="hljs-params">sub</span> =&gt;</span> sub())<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 建立依赖（dependency-tracking）。在 property 被访问和修改时通知变更。</span><br><span class="hljs-built_in">Object</span>.keys(data).forEach(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span>&#123;<br>    <span class="hljs-keyword">let</span> internalValue = data[key]<br><br>    <span class="hljs-keyword">const</span> dep = <span class="hljs-keyword">new</span> Dep()<br><br>    <span class="hljs-comment">// 异步函数</span><br>    <span class="hljs-built_in">Object</span>.defineProperty(data, key, &#123;<br>        <span class="hljs-function"><span class="hljs-title">get</span>(<span class="hljs-params"></span>)</span>&#123;<br>            dep.depend()<br>            <span class="hljs-keyword">return</span> internalValue<br>        &#125;,<br>        <span class="hljs-function"><span class="hljs-title">set</span>(<span class="hljs-params">newValue</span>)</span>&#123;<br>            internalValue = newValue<br>            dep.notify()<br>        &#125;<br>    &#125;)<br>&#125;)<br><br><span class="hljs-comment">// 观察者函数（极简化版）</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">watcher</span>(<span class="hljs-params">myFunc</span>)</span>&#123;<br>    <span class="hljs-comment">// 监听和执行target</span><br>    target = myFunc<br>    target()<br>    target = <span class="hljs-literal">null</span><br>    <br>    <span class="hljs-comment">// ...记录依赖</span><br>    <span class="hljs-comment">// ...Trigger re-render重新渲染</span><br>&#125;<br><br>watcher(<span class="hljs-function">()=&gt;</span>&#123;<br>    total = data.price * data.quantity<br>&#125;)<br></code></pre></div></td></tr></table></figure><p>测试：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 测试</span><br><span class="hljs-built_in">console</span>.log(data.price)<span class="hljs-comment">//5</span><br><span class="hljs-built_in">console</span>.log(data.quantity)<span class="hljs-comment">//2</span><br><span class="hljs-built_in">console</span>.log(total)<span class="hljs-comment">//10</span><br><br>data.price=<span class="hljs-number">10</span><br><br><span class="hljs-built_in">console</span>.log(total)<span class="hljs-comment">//20</span><br><span class="hljs-comment">// 修改data.price之后，total自动更新了</span><br></code></pre></div></td></tr></table></figure><h2 id="异步更新队列"><a href="#异步更新队列" class="headerlink" title="异步更新队列"></a>异步更新队列</h2><p>上面例子中，watcher被极度简化。实际上，Vue 在更新 DOM 时是<strong>异步</strong>执行的。<strong>只要侦听到数据变化，Vue 将开启一个队列，并buffer在同一事件循环中发生的所有数据变更。</strong>如果同一个 watcher 被多次触发，只会被推入到队列中一次（数据去重），避免不必要的计算和 DOM 操作。然后，在下一个的事件循环“tick”中，Vue 刷新队列。</p><p>具体见一下例子：</p><p><a href="https://jsbin.com/mocotic/edit?html,js,output">https://jsbin.com/mocotic/edit?html,js,output</a></p><p>html:</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">span-a</span>&gt;</span><br>      &#123;&#123;obj.a&#125;&#125; <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">span-b</span>&gt;</span><br>      &#123;&#123;obj.b&#125;&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>JavaScript：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> app = <span class="hljs-keyword">new</span> Vue(&#123;<br>  <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#app&#x27;</span>,<br>  <span class="hljs-attr">data</span>: &#123;<br>    <span class="hljs-attr">obj</span>: &#123;<br>      <span class="hljs-attr">a</span>: <span class="hljs-string">&#x27;a&#x27;</span>,<br>    &#125;<br>  &#125;,<br>&#125;)<br><br>app.obj.b = <span class="hljs-string">&#x27;addB&#x27;</span><br><br><span class="hljs-comment">// oupput：a</span><br></code></pre></div></td></tr></table></figure><p>因为 b 一开始不是 obj 的 key，所以 Vue 并没有监听 b。即使 b 的值变了，视图也不会更新。</p><p>JavaScript:</p><figure class="highlight stylus"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stylus"><span class="hljs-selector-tag">var</span> app = new Vue(&#123;<br>  el: <span class="hljs-string">&#x27;#app&#x27;</span>,<br>  data: &#123;<br>    obj: &#123;<br>      <span class="hljs-selector-tag">a</span>: <span class="hljs-string">&#x27;a&#x27;</span>,<br>    &#125;<br>  &#125;,<br>&#125;)<br><br>app<span class="hljs-selector-class">.obj</span><span class="hljs-selector-class">.a</span> = <span class="hljs-string">&#x27;newA&#x27;</span><br>app<span class="hljs-selector-class">.obj</span><span class="hljs-selector-class">.b</span> = <span class="hljs-string">&#x27;addB&#x27;</span><br><br><span class="hljs-comment">// oupput：newA addB</span><br></code></pre></div></td></tr></table></figure><p>由于更新DOM过程是<strong>异步</strong>的。当更新a属性时，Vue监听到变化，先是开启了一个新的监听队列，将更新任务push到新的更新队列里。等到代码运行完毕，再更新DOM。此时页面展示的就是所有的跟新的数据。</p>]]></content>
    
    
    <categories>
      
      <category>vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue计算属性（computed）和侦听器（watcher）</title>
    <link href="/2021/06/30/Vue%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%EF%BC%88computed%EF%BC%89%EF%BC%89%E5%92%8C%E4%BE%A6%E5%90%AC%E5%99%A8%E4%BE%A6%E5%90%AC%E5%99%A8%EF%BC%88watcher%EF%BC%89/"/>
    <url>/2021/06/30/Vue%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%EF%BC%88computed%EF%BC%89%EF%BC%89%E5%92%8C%E4%BE%A6%E5%90%AC%E5%99%A8%E4%BE%A6%E5%90%AC%E5%99%A8%EF%BC%88watcher%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="Vue计算属性（computed）和侦听器（watcher）"><a href="#Vue计算属性（computed）和侦听器（watcher）" class="headerlink" title="Vue计算属性（computed）和侦听器（watcher）"></a>Vue计算属性（computed）和侦听器（watcher）</h1><h2 id="computed属性-API-—-Vue-js-vuejs-org"><a href="#computed属性-API-—-Vue-js-vuejs-org" class="headerlink" title="[computed属性](API — Vue.js (vuejs.org))"></a>[computed属性](<a href="https://cn.vuejs.org/v2/api/#computed">API — Vue.js (vuejs.org)</a>)</h2><blockquote><p>计算属性将被混入到 Vue 实例中。所有 getter 和 setter 的 this 上下文自动地绑定为 Vue 实例。</p><p>注意如果你为一个计算属性使用了箭头函数，则 <code>this</code> 不会指向这个组件的实例，不过你<strong>仍然可以</strong>将其实例作为函数的第一个参数来访问。</p><p>计算属性的结果会被缓存，除非依赖的响应式 property 变化才会重新计算。注意，如果某个依赖 (比如非响应式 property) 在该实例范畴之外，则计算属性是<strong>不会</strong>被更新的。</p></blockquote><p>举例：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;example&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Original message: &quot;&#123;&#123; message &#125;&#125;&quot;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Computed reversed message: &quot;&#123;&#123; reversedMessage &#125;&#125;&quot;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></div></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> Vue(&#123;<br>  <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#example&#x27;</span>,<br>  <span class="hljs-attr">data</span>: &#123;<br>    <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;Hello&#x27;</span>,<br>    <span class="hljs-attr">reverse</span>: <span class="hljs-literal">false</span><br>  &#125;,<br>  <span class="hljs-attr">computed</span>: &#123;<br>    <span class="hljs-attr">rev</span>: <span class="hljs-function"><span class="hljs-params">vm</span> =&gt;</span> vm.message.split(<span class="hljs-string">&#x27;&#x27;</span>).reverse().join(<span class="hljs-string">&#x27;&#x27;</span>),<br>    <span class="hljs-attr">reversedMessage</span>:&#123;<br>      <span class="hljs-function"><span class="hljs-title">get</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.rev<br>      &#125;,<br>      <span class="hljs-function"><span class="hljs-title">set</span>(<span class="hljs-params"></span>)</span>&#123;&#125;<br>    &#125;<br>  &#125;<br>&#125;)<br></code></pre></div></td></tr></table></figure><p>结果：</p><p>Original message: “Hello”</p><p>Computed reversed message: “olleH”</p><h2 id="watch属性-API-—-Vue-js-vuejs-org"><a href="#watch属性-API-—-Vue-js-vuejs-org" class="headerlink" title="[watch属性](API — Vue.js (vuejs.org))"></a>[watch属性](<a href="https://cn.vuejs.org/v2/api/#watch">API — Vue.js (vuejs.org)</a>)</h2><blockquote><p>methods 将被混入到 Vue 实例中。可以直接通过 VM 实例访问这些方法，或者在指令表达式中使用。方法中的 <code>this</code> 自动绑定为 Vue 实例。</p><p>注意，<strong>不应该使用箭头函数来定义 method 函数</strong> (例如 <code>plus: () =&gt; this.a++</code>)。因为箭头函数绑定了父级作用域的上下文，这样 <code>this</code> 将不会按照期望指向 Vue 实例，<code>this.a</code> 将是 undefined。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">new</span> Vue(&#123;<br>  <span class="hljs-attr">data</span>: &#123;<br>    <span class="hljs-attr">n</span>: <span class="hljs-number">0</span>,<br>    <span class="hljs-attr">history</span>: [],<br>    <span class="hljs-attr">inUndoMode</span>: <span class="hljs-literal">false</span><br>  &#125;,<br>  <span class="hljs-attr">watch</span>: &#123;<br>    <span class="hljs-attr">n</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">newValue, oldValue</span>) </span>&#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.inUndoMode?<span class="hljs-string">&quot;正在撤销&quot;</span>:<span class="hljs-string">&#x27;&#x27;</span>);<br>      <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.inUndoMode) &#123;<br>        <span class="hljs-built_in">this</span>.history.push(&#123; <span class="hljs-attr">from</span>: oldValue, <span class="hljs-attr">to</span>: newValue &#125;);<br>      &#125;<br>    &#125;<br>  &#125;,<br>  <span class="hljs-comment">// 不如用 computed 来计算 displayName</span><br>  <span class="hljs-attr">template</span>: <span class="hljs-string">`</span><br><span class="hljs-string">    &lt;div&gt;</span><br><span class="hljs-string">      &#123;&#123;n&#125;&#125;</span><br><span class="hljs-string">      &lt;hr /&gt;</span><br><span class="hljs-string">      &lt;button @click=&quot;add1&quot;&gt;+1&lt;/button&gt;</span><br><span class="hljs-string">      &lt;hr/&gt;</span><br><span class="hljs-string">      &lt;button @click=&quot;undo&quot;&gt;撤销&lt;/button&gt;</span><br><span class="hljs-string">      &lt;hr/&gt;</span><br><span class="hljs-string"></span><br><span class="hljs-string">      &#123;&#123;history&#125;&#125;</span><br><span class="hljs-string">    &lt;/div&gt;</span><br><span class="hljs-string">  `</span>,<br>  <span class="hljs-attr">methods</span>: &#123;<br>    <span class="hljs-function"><span class="hljs-title">add1</span>(<span class="hljs-params"></span>)</span> &#123;<br>      <span class="hljs-built_in">this</span>.n += <span class="hljs-number">1</span>;<br>    &#125;,<br>    <span class="hljs-function"><span class="hljs-title">undo</span>(<span class="hljs-params"></span>)</span> &#123;<br>      <span class="hljs-keyword">const</span> last = <span class="hljs-built_in">this</span>.history.pop();<br>      <span class="hljs-built_in">console</span>.log(last);<br>      <span class="hljs-built_in">this</span>.inUndoMode = <span class="hljs-literal">true</span>;<br>      <span class="hljs-built_in">this</span>.n = last.from;<br>      <span class="hljs-built_in">this</span>.$nextTick(<span class="hljs-function">()=&gt;</span>&#123;<br>        <span class="hljs-built_in">this</span>.inUndoMode = <span class="hljs-literal">false</span>;<br>      &#125;,<span class="hljs-number">0</span>) <br>    &#125;<br>  &#125;<br>&#125;).$mount(<span class="hljs-string">&quot;#app&quot;</span>);<br></code></pre></div></td></tr></table></figure><p>以上代码中，不能直接执行 <code>this.inUndoMode = false;</code> ，因为 <code>watch</code> 是异步的，当执行 <code>this.n = last.from;</code> 时，不会立刻执行 <code>watch</code> 代码，它只会等 <code>undo</code> 全部执行完毕才会执行。</p><p>此处有两种解绝方法：可以将 <code>this.inUndoMode = false;</code>  置于 <code>watch</code> 的最后一句 。或者，放在 <code>this.$nextTick()</code> 中。为了逻辑清晰，此处选择第二种解决方法。</p><p>选择使用 <code>nextTick()</code> 函数执行异步操作，是因为 watch 内部所使用的异步 API 也是这个函数，同级别异步函数会按照代码顺序执行。</p><p>测试：<a href="https://codesandbox.io/s/lucid-shamir-cpcw3?file=/src/main.js:89-1118">lucid-shamir-cpcw3 - CodeSandbox</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>computed</strong> 计算属性。它会根据你所以来的数据动态显示新的计算结果。它具有如下特点：</p><ol><li>调用时不需要加括号；</li><li>可以根据依赖自动<strong>缓存</strong>：当依赖不变时，computed不会重新计算。</li><li>computed不支持异步操作，当computed内部有异步操作时无效，无法监听数据变化。</li></ol><p><strong>watch</strong> 用来监听依赖变化，当依赖的 data 变化时执行回调。它有两个常用选项：</p><ol><li>immediate 表示是否在第一次渲染时执行回调；</li><li>deep 表示监听某个对象时，是否要同时监听该对象内部的属性变化。</li><li>watch本身是异步的，内部使用的异步 AP 是 <code>nextTick()</code>  。</li></ol>]]></content>
    
    
    <categories>
      
      <category>vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入理解MVC</title>
    <link href="/2021/06/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3MVC/"/>
    <url>/2021/06/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3MVC/</url>
    
    <content type="html"><![CDATA[<h1 id="深入理解MVC"><a href="#深入理解MVC" class="headerlink" title="深入理解MVC"></a>深入理解MVC</h1><h2 id="MVC的三个对象"><a href="#MVC的三个对象" class="headerlink" title="MVC的三个对象"></a>MVC的三个对象</h2><p><strong>MVC</strong> **(Model-View-Controller)**是一种软件设计模式，它把软件设计分成三大模块：模型（Model）、视图（View）、控制器（Controller）。这样重构的代码：</p><ol><li>简化了后续对程序的修改和扩展简化，避免出现<em>意大利面条式</em>的代码</li><li>并使某一部分代码能够重复利用</li><li>同时，这一设计模式通过对复杂度的简化，使程序结构更加直观易于理解和维护。</li></ol><ul><li><strong>模型（Model）</strong> - 负责存放和处理（增删改查）数据。一般与Conterller存在耦合，M从<code>服务器</code>拿到数据后一般会通过<strong>eventBus</strong>传给Controller</li></ul><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> $ <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;jquery&#x27;</span>;<br><br><span class="hljs-keyword">const</span> eventBus = $(<span class="hljs-built_in">window</span>);<br><br><span class="hljs-keyword">const</span> m = &#123;<br>    <span class="hljs-comment">// 服务器获得的数据</span><br>    <span class="hljs-attr">data</span>:&#123;&#125;,<br>    <span class="hljs-comment">// 对数据进行增删改查</span><br>    <span class="hljs-function"><span class="hljs-title">create</span>(<span class="hljs-params"></span>)</span>&#123;&#125;,<br>    <span class="hljs-function"><span class="hljs-title">delete</span>(<span class="hljs-params"></span>)</span>&#123;&#125;,<br>    <span class="hljs-function"><span class="hljs-title">update</span>(<span class="hljs-params">data</span>)</span>&#123;<br>        <span class="hljs-comment">/* 调用m.update()时，通过eventBus.trigger()触发事件，而Conterller通过</span><br><span class="hljs-comment">        eventBus.on()来监听这个事件，以实现对象间通信 */</span><br>        <span class="hljs-built_in">Object</span>.assign(m.data, data);<span class="hljs-comment">//将data全部拷贝/覆盖给m.data</span><br>        eventBus.trigger(<span class="hljs-string">&#x27;m已更新&#x27;</span>);<span class="hljs-comment">//触发‘m已更新’这个事件</span><br>    &#125;,<br>    <span class="hljs-function"><span class="hljs-title">get</span>(<span class="hljs-params"></span>)</span>&#123;&#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><ul><li><strong>视图（View）</strong> - 负责所有UI界面</li></ul><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> v = &#123;<br>    <span class="hljs-attr">el</span>: <span class="hljs-literal">null</span>,<span class="hljs-comment">//待渲染元素</span><br>    <span class="hljs-attr">html</span>: <span class="hljs-string">`&lt;!--  要显示浏览器页面的内容  --&gt;`</span>,<br>    <span class="hljs-function"><span class="hljs-title">init</span>(<span class="hljs-params">container</span>)</span>&#123;<br>        <span class="hljs-comment">// 初始化带渲染元素</span><br>        v.el = $(container);<br>    &#125;,<br>    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params">data</span>)</span>&#123;<br>        <span class="hljs-comment">// 渲染元素</span><br>        <span class="hljs-keyword">if</span>(v.el.children) v.el.empty();   <span class="hljs-comment">// 如果v.el原来有内容，则先清空</span><br>        <span class="hljs-comment">//...然后重新渲染v.el</span><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><ul><li><strong>控制器（Controller）</strong>- 负责监听和处理View事件，同时监听Model数据变化（通过<strong>eventBus</strong>）</li></ul><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> c = &#123;<br>    <span class="hljs-function"><span class="hljs-title">init</span>(<span class="hljs-params">el</span>)</span>&#123;<br>        v.init(el);<br>        <span class="hljs-comment">// 第一次渲染</span><br>        v.render(data);<span class="hljs-comment">/* view = render(data)方式让render只在</span><br><span class="hljs-comment">        该更新的地方更新 */</span> <br>        c.autoBindEvents();<br>        eventBus.on(<span class="hljs-string">&#x27;m已更新&#x27;</span>,<span class="hljs-function">()=&gt;</span>&#123;<br>           <span class="hljs-comment">// eventBus监听‘m已更新’事件，每当该事件触发，就重新渲染</span><br>           v.render(data); <br>        &#125;);<br>    &#125;,<br>    <span class="hljs-attr">events</span>:&#123; <span class="hljs-comment">/* 一般使用哈希表存储 */</span> &#125;,<br>    <span class="hljs-function"><span class="hljs-title">method</span>(<span class="hljs-params"></span>)</span>&#123;&#125;,<br>    <span class="hljs-function"><span class="hljs-title">autoBindEvents</span>(<span class="hljs-params"></span>)</span>&#123;&#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>由于，v和c耦合度较高，一般将二者合为一个对象<strong>View</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> $ <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;jquery&#x27;</span>;<br><br><span class="hljs-keyword">const</span> eventBus = $(<span class="hljs-built_in">window</span>);<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">View</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">eventBus</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">options</span>)</span> &#123;<br>        <span class="hljs-built_in">super</span>();<span class="hljs-comment">/* 调用 super()会调用父类构造函数，并将返回的实例</span><br><span class="hljs-comment">        赋值给 this。不能在调用 super()之前引用 this。 */</span><br>        <span class="hljs-built_in">Object</span>.assign(<span class="hljs-built_in">this</span>,options);<br><br>        <span class="hljs-built_in">this</span>.el = $(<span class="hljs-built_in">this</span>.el);<br>        <span class="hljs-built_in">this</span>.render(<span class="hljs-built_in">this</span>.data);<br>        <span class="hljs-built_in">this</span>.autoBindEvents();<br>        <span class="hljs-built_in">this</span>.on(<span class="hljs-string">&#x27;m已更新&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-comment">// 继承eventBus的on方法</span><br>            <span class="hljs-built_in">this</span>.render(<span class="hljs-built_in">this</span>.data);<br>        &#125;);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-title">autoBindEvents</span>(<span class="hljs-params"></span>)</span> &#123;&#125;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> View;<br></code></pre></div></td></tr></table></figure><h2 id="EventBus-实现对象间通信"><a href="#EventBus-实现对象间通信" class="headerlink" title="EventBus 实现对象间通信"></a>EventBus 实现对象间通信</h2><p>EventBus就是一个以事件为驱动的消息服务总线，用来实现组件/对象之间的通信。</p><p>这样做的原理是：EventBus有三个关键的 API：on（监听事件），trigger（触发事件）或$emit（vue中）,off（取消监听)</p><p>以上c和m之间的通信就是使用EventBus的一个例子。</p><p>实际工作中一般不用<code>const eventBus = $(window);</code>，因为这样写不利于调用和后期代码维护。一般单独封装一个EventBus类进行解耦。</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> $ <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;jquery&quot;</span>;<br><br><span class="hljs-comment">//解耦EventBus</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EventBus</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-built_in">this</span>._eventBus = $(<span class="hljs-built_in">window</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-title">on</span>(<span class="hljs-params">eventName, fn</span>)</span> &#123;<br>        <span class="hljs-keyword">return</span>  <span class="hljs-built_in">this</span>._eventBus.on(eventName, fn);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-title">trigger</span>(<span class="hljs-params">eventName, fn</span>)</span> &#123;<br>       <span class="hljs-keyword">return</span>  <span class="hljs-built_in">this</span>._eventBus.trigger(eventName, fn);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-title">off</span>(<span class="hljs-params">eventName, fn</span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>._eventBus.off(eventName, fn);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> EventBus;<br></code></pre></div></td></tr></table></figure><h2 id="表驱动编程（Table-Driven-Approach）"><a href="#表驱动编程（Table-Driven-Approach）" class="headerlink" title="表驱动编程（Table-Driven Approach）"></a>表驱动编程（Table-Driven Approach）</h2><p>首先看一段冗余代码：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> $ <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;jquery&quot;</span>;<br><br><span class="hljs-keyword">const</span> testEl = $(<span class="hljs-built_in">window</span>);<br><br><span class="hljs-keyword">const</span> v = &#123;<br>    <span class="hljs-attr">el</span>: testEl,<br>    <span class="hljs-function"><span class="hljs-title">bindEvents</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-comment">// 重复代码过多</span><br>        v.cntnr.on(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-string">&quot;#add1&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>            data += <span class="hljs-number">1</span>;<br>        &#125;);<br><br>        v.cntnr.on(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-string">&quot;#minus1&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>            data -= <span class="hljs-number">1</span>;<br>        &#125;);<br><br>        v.cntnr.on(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-string">&quot;#multiply2&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>            data &lt;&lt;= <span class="hljs-number">1</span>;<br>        &#125;);<br>        v.cntnr.on(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-string">&quot;#divide2&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>            data &gt;&gt;= <span class="hljs-number">1</span>;<br>        &#125;);<br>    &#125;<br>&#125;;<br><br>v.bindEvents();<br></code></pre></div></td></tr></table></figure><p>以上这种绑定事件的方法有如下缺点：</p><ol><li>代码重复性：bindEvents方法明显存在大量重复代码，可以进一步提炼</li><li>可扩展性差：如果改变事件响应函数，就要改变bindEvents()方法，非常不方便</li><li>代码多的时候，不易读，主要程序逻辑被淹没在一些没用的冗余代码中</li></ol><p>表驱动编程：</p><p>为解决上面这些问题，可以将代码发生变化的那一部分（一般是数据部分）放到表中，一般使用哈希表。而其他不变的部分（一般是逻辑部分），单独封装。这样后期维护只需要对表进行响应修改即可。</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> $ <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;jquery&quot;</span>;<br><br><span class="hljs-keyword">const</span> testEl = $(<span class="hljs-built_in">window</span>);<br><br><span class="hljs-keyword">const</span> v = &#123;<br>    <span class="hljs-attr">el</span>:testEl,<br>    <span class="hljs-attr">events</span>:&#123;<br>    <span class="hljs-comment">// 数据部分（变化的部分）</span><br>        <span class="hljs-string">&#x27;click #add1&#x27;</span>: <span class="hljs-string">&#x27;add&#x27;</span>,<br>        <span class="hljs-string">&#x27;click #minus1&#x27;</span>: <span class="hljs-string">&#x27;minus&#x27;</span>,<br>        <span class="hljs-string">&#x27;click #mul2&#x27;</span>: <span class="hljs-string">&#x27;mul&#x27;</span>,<br>        <span class="hljs-string">&#x27;click #divide2&#x27;</span>: <span class="hljs-string">&#x27;divide&#x27;</span>,<br>&#125;,<br>        <br>    <span class="hljs-comment">// 逻辑部分（不变的部分）</span><br>    <span class="hljs-function"><span class="hljs-title">add</span>(<span class="hljs-params"></span>)</span> &#123;<br>        data += <span class="hljs-number">1</span>;<br>    &#125;,<br>    <span class="hljs-function"><span class="hljs-title">minus</span>(<span class="hljs-params"></span>)</span> &#123;<br>        data -= <span class="hljs-number">1</span>;<br>    &#125;,<br>    <span class="hljs-function"><span class="hljs-title">mul</span>(<span class="hljs-params"></span>)</span> &#123;<br>        data &lt;&lt;= <span class="hljs-number">1</span>;<br>    &#125;,<br>    <span class="hljs-function"><span class="hljs-title">divide</span>(<span class="hljs-params"></span>)</span> &#123;<br>        data &gt;&gt;= <span class="hljs-number">1</span>;<br>    &#125;,<br>    <span class="hljs-function"><span class="hljs-title">autoBindEvents</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> v.events)&#123;<br>            <span class="hljs-keyword">const</span> value = v[v.events[key]];<br>            <span class="hljs-keyword">const</span> spaceIndex = key.indexOf(<span class="hljs-string">&#x27; &#x27;</span>);<br>            <span class="hljs-keyword">const</span> part1 = key.slice(<span class="hljs-number">0</span>,spaceIndex);<br>            <span class="hljs-keyword">const</span> part2 = key.slice(spaceIndex+<span class="hljs-number">1</span>);<br>            v.el.on(part1,part2,value);<br>        &#125;<br>&#125;<br>&#125;;<br>    <br>v.autoBindEvents();<br></code></pre></div></td></tr></table></figure><p>表驱动编程的意义在于实现了<strong>逻辑与数据的分离。</strong></p><p>相应的，表驱动编程有以下<strong>优点</strong>：</p><ol><li>提高代码可读性。代码简化到：只需要看“表”，就能知道程序是干什么的。</li><li>减少重复代码</li><li>增加代码可扩展性，比较方便。同时更易于控制复杂度</li></ol><h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><p>模块化是指解决一个复杂问题时自顶向下逐层把系统划分成若干模块的过程，有多种属性，分别反映其内部特性。模块化设计，简单地说就是程序的编写不是一开始就逐条录入计算机语句和指令，而是首先用主程序、子程序、子过程等框架把软件的主要结构和流程描述出来，并定义和调试好各个框架之间的输入、输出链接关系逐步求精的结果是得到一系列以功能块为单位的算法描述。以功能块为单位进行程序设计，实现其求解算法的方法称为模块化。</p><p>模块化的<strong>目的</strong>是为了降低程序复杂度，使程序设计、调试和维护等操作简单化。</p><p>以上封装m、v、c，解耦EventBus，以及表驱动编程的例子都体现了模块化的思想。</p><p>模块化具有以下<strong>优点</strong>：</p><ol><li><p>控制了程序设计的复杂性。</p></li><li><p>提高了代码的重用性。</p></li><li><p>易于维护和功能扩充。</p></li><li><p>有利于团队开发。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>跨域</title>
    <link href="/2021/06/20/%E8%B7%A8%E5%9F%9F/"/>
    <url>/2021/06/20/%E8%B7%A8%E5%9F%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h1><h2 id="同源"><a href="#同源" class="headerlink" title="同源"></a>同源</h2><p><strong>同源</strong>：如果两个 URL 的 <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Protocol">protocol</a>、<a href="https://developer.mozilla.org/en-US/docs/Glossary/Port">port (en-US)</a> (如果有指定的话)和 <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Host">host</a> <strong>都相同</strong>的话，则这两个 URL 是<em>同源</em>。</p><p><strong>同源策略</strong>是一个重要的安全策略，它用于限制一个<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Origin">origin</a>的文档或者它加载的脚本如何能与另一个源的资源进行交互。</p><p>目的：它能帮助阻隔恶意文档，减少可能被攻击的媒介。</p><p>当两个URL的协议，或端口，或主机（域名）不同时，都不构成同源，此时无法进行资源交流。</p><p>这个方案也被称为“协议/主机/端口元组”，或者直接是 “元组”。（“元组” 是指一组项目构成的整体，双重/三重/四重/五重/等的通用形式）。</p><p>随着互联网的发展，”同源政策”越来越严格。目前，如果非同源，共有三种行为受到限制。</p><blockquote><p>（1） Cookie、LocalStorage 和 IndexDB 无法读取。</p><p>（2） DOM 无法获得。</p><p>（3） AJAX 请求不能发送。</p></blockquote><p>虽然这些限制是必要的，但是有时很不方便，合理的用途也受到影响。下面，我将详细介绍，如何规避上面三种限制。</p><p>但是注意：同源策略是针对浏览器而言的，客户端和服务器并不存在同源策略的概念。在出现非同源情况时，客户端如果向服务器发送GET请求，请求本身会成功发送，服务器得到请求也会返回响应。只是浏览器的同源策略导致客户端拿不到服务器返回的response。</p><h2 id="跨域-1"><a href="#跨域-1" class="headerlink" title="跨域"></a>跨域</h2><p>目前，如果非同源，共有三种行为受到限制。</p><blockquote><p>（1） Cookie、LocalStorage 和 IndexDB 无法读取。</p><p>（2） DOM 无法获得。</p><p>（3） AJAX 请求不能发送。</p></blockquote><p>虽然这些限制是必要的，但是有时很不方便，合理的用途也受到影响。下面，我将详细介绍，如何规避上面三种限制。</p><p>若要实现服务器与客户端间的跨域通信，可以使用JSONP和CORS两种方法。</p><h2 id="兼容IE：选择JSONP"><a href="#兼容IE：选择JSONP" class="headerlink" title="兼容IE：选择JSONP"></a>兼容IE：选择JSONP</h2><p>JSONP基本思想是，网页通过添加一个<code>&lt;script&gt;</code>元素，向服务器请求JSON数据，这种做法不受同源政策限制；服务器收到请求后，将数据放在一个指定名字的回调函数里传回来。</p><p>具体地，在某些浏览器不支持cors进行跨域时，通过请求一个js文件，在这个js文件中执行一个回调，而回调中有我们需要的跨域数据。其中，回调的名字可以使用random随机生成，这个名字以callback参数传给后台，后台将函数返回并执行。</p><p>实际中，以上方法可能存在一个缺陷：就是第三方网站可能调用 <code>JSONP</code> 。这可以通过使用 Header 的 <code>Referer</code> 字段告诉浏览器用户在访问当前资源之前的位置，进而实现用户跟踪。</p><p>浏览器的 JavaScript 引擎提供<code>document.referrer</code> 属性，可以查看当前页面的引荐来源。</p><p>具体地，如果 <code>Referer</code> 字段的网址是 <code>JSONP</code> 允许地网址，就放行。否则，就会屏蔽。</p><p><strong>jsonp的优点</strong></p><p>①兼容ie</p><p>②可以实现跨域</p><p><strong>jsonp的缺点</strong></p><p>①由于jsonp使用<code>&lt;script&gt;</code>标签，它无法像Ajax那样能读到精确状态码，也无法读到响应头，而只知道请求成功失败状态；</p><p>②script标签只能发送get请求，不支持post请求</p><h2 id="CORS（Cross-origin-resource-sharing）"><a href="#CORS（Cross-origin-resource-sharing）" class="headerlink" title="CORS（Cross-origin resource sharing）"></a>CORS（Cross-origin resource sharing）</h2><p>CORS是跨源资源分享（Cross-Origin Resource Sharing）的缩写。它是W3C标准，是跨源AJAX请求的根本解决方法。相比JSONP只能发<code>GET</code>请求，<strong>CORS允许任何类型的请求</strong>。</p><p>它允许浏览器向跨源服务器，发出<a href="https://www.ruanyifeng.com/blog/2012/09/xmlhttprequest_level_2.html"><code>XMLHttpRequest</code></a>请求，从而克服了AJAX只能<a href="https://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html">同源</a>使用的限制。</p><p>浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。</p><h3 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h3><p>只要同时满足以下两大条件，就属于简单请求。</p><blockquote><p>（1) 请求方法是以下三种方法之一：</p><ul><li>HEAD</li><li>GET</li><li>POST</li></ul><p>（2）HTTP的头信息不超出以下几种字段：</p><ul><li>Accept</li><li>Accept-Language</li><li>Content-Language</li><li>Last-Event-ID</li><li>Content-Type：只限于三个值<code>application/x-www-form-urlencoded</code>、<code>multipart/form-data</code>、<code>text/plain</code></li></ul></blockquote><p>对于简单请求，浏览器直接发出CORS请求。具体来说，就是在头信息之中，增加一个<code>Origin</code>字段。</p><p><strong>（1）Access-Control-Allow-Origin</strong></p><p>该字段是<strong>必须的</strong>。它的值要么是请求时<code>Origin</code>字段的值，要么是一个<code>*</code>，表示接受任意域名的请求。</p><p><strong>（2）Access-Control-Allow-Credentials</strong></p><p>该字段可选。它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为<code>true</code>，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为<code>true</code>，如果服务器不要浏览器发送Cookie，删除该字段即可。</p><p><strong>（3）Access-Control-Expose-Headers</strong></p><p>该字段可选。CORS请求时，<code>XMLHttpRequest</code>对象的<code>getResponseHeader()</code>方法只能拿到6个基本字段：<code>Cache-Control</code>、<code>Content-Language</code>、<code>Content-Type</code>、<code>Expires</code>、<code>Last-Modified</code>、<code>Pragma</code>。如果想拿到其他字段，就必须在<code>Access-Control-Expose-Headers</code>里面指定。上面的例子指定，<code>getResponseHeader(&#39;FooBar&#39;)</code>可以返回<code>FooBar</code>字段的值。</p><h3 id="非简单请求"><a href="#非简单请求" class="headerlink" title="非简单请求"></a>非简单请求</h3><p>非简单请求是那种对服务器有特殊要求的请求，比如请求方法是<code>PUT</code>或<code>DELETE</code>，或者<code>Content-Type</code>字段的类型是<code>application/json</code>。</p><p>非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为”预检”请求（preflight）。</p><p>浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的<code>XMLHttpRequest</code>请求，否则就报错。</p><p>非简单请求具体见MDN：<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS#%E9%A2%84%E6%A3%80%E8%AF%B7%E6%B1%82">跨源资源共享（CORS） - HTTP | MDN (mozilla.org)</a></p><h3 id="CORS与JSONP的比较"><a href="#CORS与JSONP的比较" class="headerlink" title="CORS与JSONP的比较"></a>CORS与JSONP的比较</h3><p>CORS与JSONP的使用目的相同，但是比JSONP更强大。</p><p>JSONP只支持<code>GET</code>请求，CORS支持所有类型的HTTP请求。JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。</p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ajax</title>
    <link href="/2021/06/15/Ajax/"/>
    <url>/2021/06/15/Ajax/</url>
    
    <content type="html"><![CDATA[<h1 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h1><h2 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL;DR"></a>TL;DR</h2><p>GET 请求：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> request = <span class="hljs-keyword">new</span> XMLHttpRequest();<br>request.open(<span class="hljs-string">&#x27;GET&#x27;</span>, <span class="hljs-string">&#x27;http://www.example.com/page.php&#x27;</span>, <span class="hljs-literal">true</span>);<br>request.responseType = <span class="hljs-string">&#x27;text&#x27;</span>;<br>request.onreadystatechange = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">if</span>(request.readyState === <span class="hljs-number">4</span> &amp;&amp; request.status === <span class="hljs-number">200</span>) &#123;<br>        <span class="hljs-built_in">console</span>.log(request.responseText);<br>    &#125;<br>&#125;;<br>request.send();<br></code></pre></div></td></tr></table></figure><p>POST 请求：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> request = <span class="hljs-keyword">new</span> XMLHttpRequest();<br>request.open(<span class="hljs-string">&#x27;POST&#x27;</span>, <span class="hljs-string">&#x27;http://www.example.com/page.php&#x27;</span>, <span class="hljs-literal">true</span>);<br>request.setRequestHeader(<span class="hljs-string">&#x27;Content-Type&#x27;</span>, <span class="hljs-string">&#x27;application/x-www-form-urlencoded&#x27;</span>);<br>request.responseType = <span class="hljs-string">&#x27;text&#x27;</span>;<br>request.onreadystatechange = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">if</span>(request.readyState === <span class="hljs-number">4</span> &amp;&amp; request.status === <span class="hljs-number">200</span>) &#123;<br>        <span class="hljs-built_in">console</span>.log(request.responseText);<br>    &#125;<br>&#125;;<br>request.send(data);<br></code></pre></div></td></tr></table></figure><p>Ajax 即 “Asynchronous JavaScript and XML”(非同步的 JavaScript 与 XML技术)，Ajax 通过原生的<code>XMLHttpRequest</code>对象发出 HTTP 请求，得到服务器返回的数据后，再进行处理。其核心也就是 <code>XMLHttpRequest</code> 对象</p><p>Ajax 主要用于<strong>在不刷新页面的情况下</strong>向浏览器发起请求并接受响应，最后<strong>局部更新</strong>页面。</p><p>现在，服务器返回的都是 JSON 格式的数据，XML 格式已经过时了，但是 AJAX 这个名字已经成了一个通用名词，字面含义已经消失了。</p><h2 id="1-发送请求"><a href="#1-发送请求" class="headerlink" title="1. 发送请求"></a>1. 发送请求</h2><h3 id="1-1-创建对象"><a href="#1-1-创建对象" class="headerlink" title="1.1 创建对象"></a>1.1 创建对象</h3><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> request = <span class="hljs-keyword">new</span> XMLHttpRequest();<br></code></pre></div></td></tr></table></figure><h3 id="1-2-向服务器发送请求"><a href="#1-2-向服务器发送请求" class="headerlink" title="1.2 向服务器发送请求"></a>1.2 向服务器发送请求</h3><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">request.open(<span class="hljs-string">&#x27;GET&#x27;</span>, <span class="hljs-string">&#x27;http://www.example.com/page.php&#x27;</span>, <span class="hljs-literal">true</span>);<span class="hljs-comment">//设定发送请求的请求类型、url、是否为异步请求</span><br>request.send();<br></code></pre></div></td></tr></table></figure><p>参数细节：</p><p><strong>open(<em>method;url;async</em>)</strong></p><ul><li><em>method</em>: GET / POST</li><li><em>url</em>: 指定的服务器地址</li><li><em>async</em>：true（异步，default）/ false（同步）data</li></ul><p><strong>send（<em>data</em>）</strong></p><ul><li>data：如果不带参数 data，就表示 HTTP 请求只包含头信息，也就是只有一个 URL，典型例子就是 GET 请求；如果带有参数，就表示除了头信息，还带有包含具体数据的信息体，典型例子就是 POST 请求。</li></ul><p>相对 GET 请求，在发送 POST 请求时，需要额外使用 <code>setRequestHeader()</code> 方法设置 HTTP 请求头，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">xmlhttp.setRequestHeader(<span class="hljs-string">&quot;content-type&quot;</span>,<span class="hljs-string">&quot;text/xml;charset=utf-8&quot;</span>);  <br></code></pre></div></td></tr></table></figure><p><strong>setRequestHeader(<em>header</em>,<em>value</em>)</strong></p><ul><li><em>header</em>: 规定头的名称</li><li><em>value</em>: 规定头的值</li></ul><h3 id="1-3-服务器的响应"><a href="#1-3-服务器的响应" class="headerlink" title="1.3 服务器的响应"></a>1.3 服务器的响应</h3><p>获取服务器响应信息一般使用 responseText 和 responseXML 属性</p><ul><li><code>XMLHttpRequest.responseText</code> 属性返回从服务器接收到的字符串，该属性为只读。</li><li><code>XMLHttpRequest.responseXML</code> 属性返回从服务器接收到的 HTML 或 XML 文档对象，该属性为只读。</li><li><code>XMLHttpRequest.responseURL</code> 属性是字符串，表示发送数据的服务器的网址。</li></ul><h2 id="2-处理响应"><a href="#2-处理响应" class="headerlink" title="2. 处理响应"></a>2. 处理响应</h2><h3 id="2-1-XMLHttpRequest-readyState"><a href="#2-1-XMLHttpRequest-readyState" class="headerlink" title="2.1 XMLHttpRequest.readyState"></a>2.1 XMLHttpRequest.readyState</h3><h4 id="2-1-1-readyState-和-status的区别"><a href="#2-1-1-readyState-和-status的区别" class="headerlink" title="2.1.1 readyState 和 status的区别"></a>2.1.1 readyState 和 status的区别</h4><p><code>readyState</code> 状态值，表示 XMLHttpRequest 实例对象的当前状态。<code>XMLHttpRequest.readyState</code> 可以返回该值。整个响应周期一共有五个整数值：</p><blockquote><p>0，表示 XMLHttpRequest 实例已经生成，但是实例的 <code>open()</code> 方法还没有被调用。</p><p>1，表示<code>open()</code>方法已经调用，但是实例的 <code>send()</code> 方法还没有调用，仍然可以使用实例的<code>setRequestHeader()</code> 方法，设定 HTTP 请求的头信息。</p><p>2，表示实例的 <code>send()</code> 方法已经调用，并且服务器返回的头信息和状态码已经收到。</p><p>3，LOADING。表示正在接收服务器传来的数据体（body 部分）。这时，如果实例的 <code>responseType</code> 属性等于 <code>text</code> 或者空字符串，<code>responseText</code> 属性就会包含已经收到的部分信息。</p><p>4，完成响应。表示服务器返回的数据已经<strong>完全接收</strong>，或者本次接收<strong>已经失败</strong>。</p></blockquote><p><code>status</code> 表示服务器回应的 HTTP 状态码，一般来说，如果通信成功的话，这个状态码是200；如果服务器没有返回状态码，那么这个属性默认是200。<code>XMLHttpRequest.statue</code> 可以返回该值。常见的状态码有：</p><blockquote><p>100 客户端应当继续发送请求。<br>200 响应成功。<br>202 服务器已接受请求，但尚未处理。<br>204 服务器成功处理了请求，但不需要返回任何实体内容，并且希望返回更新了的元信息。<br>205 服务器成功处理了请求，且没有返回任何内容。<br>301 被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个 URI 之一。<br>400 语义有误，当前请求无法被服务器理解。或者，请求参数有误。<br>401 当前请求需要用户验证。<br>403 服务器已经理解请求，但是拒绝执行它。<br>404 请求失败，请求所希望得到的资源未被在服务器上发现。<br>500 服务器发生错误</p></blockquote><h3 id="2-2-XMLHttpRequest-onreadystatechange"><a href="#2-2-XMLHttpRequest-onreadystatechange" class="headerlink" title="2.2 XMLHttpRequest.onreadystatechange"></a>2.2 XMLHttpRequest.onreadystatechange</h3><p><code>readyState</code>属性的值发生改变，就会触发 readyStateChange 事件。</p><p>我们可以通过<code>onReadyStateChange</code>属性，指定这个事件的监听函数，对不同状态进行不同处理。</p><p>一般当状态变为<code>4</code>的时候，表示服务器响应完成，这时如果获得的 <code>statue</code> 值为 <code>202</code> ，回调函数就可以处理服务器传送回来的数据。</p><h2 id="3-Ajax-的缺点"><a href="#3-Ajax-的缺点" class="headerlink" title="3. Ajax 的缺点"></a>3. Ajax 的缺点</h2><h3 id="3-1-同源策略导致不能跨域"><a href="#3-1-同源策略导致不能跨域" class="headerlink" title="3.1 同源策略导致不能跨域"></a>3.1 同源策略导致不能跨域</h3><p>同源策略导致 Ajax 不能实现跨域。</p><p>浏览器的<strong>同源策略</strong>是一个重要的安全策略，它用于限制一个 <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Origin">origin</a> 的文档或者它加载的脚本如何能与另一个源的资源进行交互。为了保护本地数据不被JavaScript代码获取回来的数据污染，同源策略拦截了所请求数据的接收，即请求发送了，服务器响应了，但是无法被浏览器接收。</p><p>当两个URL的协议，或端口，或主机（域名）不同时，都不构成同源，此时无法进行资源交流，浏览器会在控制台中报一个异常，提示拒绝访问，即无法实现跨域。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b927a27372644edb8b223382f41dd4f5~tplv-k3u1fbpfcp-zoom-1.image" alt="查看源图像"></p><h3 id="3-2-实现跨域"><a href="#3-2-实现跨域" class="headerlink" title="3.2 实现跨域"></a>3.2 实现跨域</h3><p>想要跨越就要用到 JSONP 或 CORS 。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>请问 Ajax 的原理是什么？</p><ol><li>Ajax 就是异步的 JS 和 XML 的缩写，目前我们一般用 JSON 代替 XML。</li><li>Ajax 主要用于在不刷新页面的情况下向浏览器发起请求并接受响应，最后局部更新页面。</li><li>该技术最核心概念是 XMLHttpRequest 对象，该对象可发起 HTTP 请求，我们可以监听其 <code>readystate</code> 和 <code>status</code> 的变化获得响应。</li><li>Ajax 的优点是无刷新请求。</li><li>Ajax 缺点是被浏览器限制不能跨域。</li><li>想要跨越需要使用 JSONP 或 CORS 。</li></ol>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>this和call/apply/bind</title>
    <link href="/2021/06/06/this%E5%92%8Ccall%E3%80%81apply%E3%80%81bind/"/>
    <url>/2021/06/06/this%E5%92%8Ccall%E3%80%81apply%E3%80%81bind/</url>
    
    <content type="html"><![CDATA[<h1 id="this和call-apply-bind"><a href="#this和call-apply-bind" class="headerlink" title="this和call/apply/bind"></a>this和call/apply/bind</h1><p>概括的说，call、apply、bind的用途是指定函数调用时所引用上下文对象（context object）的值，即<strong>this的值</strong>。</p><h2 id="深入理解this"><a href="#深入理解this" class="headerlink" title="深入理解this"></a>深入理解this</h2><h3 id="普通函数的this"><a href="#普通函数的this" class="headerlink" title="普通函数的this"></a>普通函数的this</h3><p>在最普通的函数调用中，this引用的是把函数当成方法调用的上下文对象，此时this值就是window。或者说，在网页的全局上下文中调用函数时，this指向window。</p><p>举例：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> hero = <span class="hljs-string">&#x27;Jackie Chan&#x27;</span>;<br><span class="hljs-comment">//window.hero = &#x27;Jackie Chan&#x27;;</span><br><br><span class="hljs-keyword">let</span> person = &#123;<br>    <span class="hljs-attr">hero</span>:<span class="hljs-string">&#x27;Eason Chan&#x27;</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myHero</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.hero;<br>&#125;<br><br>myHero();<span class="hljs-comment">//&#x27;Jackie Chan&#x27;</span><br><br>person.myHero = myHero;<br>person.myHero();<span class="hljs-comment">//&#x27;Eason Chan&#x27;</span><br></code></pre></div></td></tr></table></figure><p>定义在全局上下文中的函数 <code>myHero()</code>引用了 <code>this</code> 对象。这个 this 到底引用哪个对象必须到<br>函数被调用时才能确定。 </p><p>若想只调用<code>myHero()</code>就得到person.hero值，则可以使用call设定this指向：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs JavaScript">myhero();<span class="hljs-comment">//&#x27;Jackie Chan&#x27;</span><br>myHero.call(person,);<span class="hljs-comment">//&#x27;Eason Chan&#x27;</span><br><br>myHero.call(<span class="hljs-literal">null</span>,);<span class="hljs-comment">//&#x27;Jackie Chan&#x27;</span><br>myHero.call(<span class="hljs-literal">undefined</span>,);<span class="hljs-comment">//&#x27;Jackie Chan&#x27;</span><br>myHero.call(<span class="hljs-string">&#x27;&#x27;</span>,);<span class="hljs-comment">//undefined</span><br>...<br>myHero.call([其他falsy值],);  <span class="hljs-comment">//undefined</span><br></code></pre></div></td></tr></table></figure><p>浏览器里有一条规则：如果传的 context 是 null 或 undefined（不包括其他falsy值），那么 window 对象就是默认的 context（严格模式下默认 context 是 undefined），因此会出现第三行代码以后的结果。</p><h3 id="箭头函数的this"><a href="#箭头函数的this" class="headerlink" title="箭头函数的this"></a>箭头函数的this</h3><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> hero = <span class="hljs-string">&#x27;Jackie Chan&#x27;</span>;<br><span class="hljs-comment">//window.hero = &#x27;Jackie Chan&#x27;;</span><br><br><span class="hljs-keyword">let</span> person = &#123;<br>    <span class="hljs-attr">hero</span>:<span class="hljs-string">&#x27;Eason Chan&#x27;</span><br>&#125;;<br><br><span class="hljs-keyword">let</span> myHero = <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">this</span>.hero;<br><br>myHero();<span class="hljs-comment">//&#x27;Jackie Chan&#x27;</span><br><br>person.myHero = myHero;<br>person.myHero();<span class="hljs-comment">//&#x27;Jackie Chan&#x27;</span><br></code></pre></div></td></tr></table></figure><p>在箭头函数中，this 引用的是定义箭头函数的上下文。 由于箭头函数<code>myHero</code>是在全局作用域中定义的，所以this指向的都是window。</p><p>注意：<em><strong>箭头函数的this是固定的，不能被call/apply/bind修改。</strong></em></p><h3 id="闭包中的this"><a href="#闭包中的this" class="headerlink" title="闭包中的this"></a>闭包中的this</h3><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs JavaScript"><span class="hljs-keyword">var</span> color = <span class="hljs-string">&#x27;red&#x27;</span>;<br><span class="hljs-comment">// window.color = &#x27;red&#x27;;</span><br><br><span class="hljs-keyword">let</span> obj = &#123;<br>    <span class="hljs-attr">color</span>: <span class="hljs-string">&#x27;blue&#x27;</span>,<br>    <span class="hljs-function"><span class="hljs-title">sayColor</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">color</span>(<span class="hljs-params"></span>)</span>&#123;<br>         <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.color;   <br>        &#125;<br>&#125;<br>&#125;;<br><br>obj.sayColor()();<span class="hljs-comment">// &#x27;red&#x27;</span><br></code></pre></div></td></tr></table></figure><p>以上代码中，全局变量<code>color</code>和函数<code>color()</code>构成闭包。</p><p>具体解释：见<a href="https://yichang8421.github.io/2021/06/01/%E9%97%AD%E5%8C%85/">《闭包》</a></p><p>要想使<code>obj.sayColor()();</code>返回obj的blue，则应该让<code>obj.color</code>和函数<code>color()</code>构成闭包。可将this保存到闭包可以访问的另一个变量that中：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> color = <span class="hljs-string">&#x27;red&#x27;</span>;<br><span class="hljs-comment">// window.color = &#x27;red&#x27;;</span><br><br><span class="hljs-keyword">let</span> obj = &#123;<br>    <span class="hljs-attr">color</span>: <span class="hljs-string">&#x27;blue&#x27;</span>,<br>    <span class="hljs-function"><span class="hljs-title">sayColor</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">let</span> that = <span class="hljs-built_in">this</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">color</span>(<span class="hljs-params"></span>)</span>&#123;<br>         <span class="hljs-keyword">return</span> that.color;   <br>        &#125;<br>&#125;<br>&#125;;<br><br>obj.sayColor()();<span class="hljs-comment">// &#x27;blue&#x27;</span><br></code></pre></div></td></tr></table></figure><h3 id="回调函数中的this"><a href="#回调函数中的this" class="headerlink" title="回调函数中的this"></a>回调函数中的this</h3><p>回调函数中的this指向window。</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> hero = <span class="hljs-string">&#x27;Jackie Chan&#x27;</span>;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">peoplesHero</span>(<span class="hljs-params">fn</span>)</span>&#123;<br>fn();<br>    <span class="hljs-keyword">return</span> hero;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myHero</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-keyword">var</span> hero = <span class="hljs-string">&#x27;Eason Chan&#x27;</span>;<br>    <span class="hljs-keyword">return</span> hero;<br>&#125;<br><br>peoplesHero(myHero);<span class="hljs-comment">//&#x27;Jackie Chan&#x27;</span><br><br><span class="hljs-comment">//以上为同步回调，代码等价于：</span><br><span class="hljs-keyword">var</span> hero = <span class="hljs-string">&#x27;Jackie Chan&#x27;</span>;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">peoplesHero</span>(<span class="hljs-params"></span>)</span>&#123;<br>(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myHero</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-keyword">var</span> hero = <span class="hljs-string">&#x27;Eason Chan&#x27;</span>;<br>    <span class="hljs-keyword">return</span> hero;<br>&#125;)();<br>    <span class="hljs-keyword">return</span> hero;<br>&#125;<br><br>peoplesHero();<span class="hljs-comment">//&#x27;Jackie Chan&#x27;</span><br></code></pre></div></td></tr></table></figure><h2 id="call"><a href="#call" class="headerlink" title="call"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/call">call</a></h2><p><code>call()</code> 方法使用一个指定的 <code>this</code> 值和单独给出的一个或多个参数来调用一个函数。</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span>.call(thisArg, arg1, arg2, ...)<br></code></pre></div></td></tr></table></figure><p>代码举例在<strong>普通函数的this</strong>小节已经介绍，不再赘述。</p><p>注意：<strong>正确的函数调用方式是使用call/apply/bind指定this.</strong></p><h2 id="apply"><a href="#apply" class="headerlink" title="apply"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/apply">apply</a></h2><p><code>apply()</code> 方法调用一个具有给定<code>this</code>值的函数，以及以一个数组（或<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Indexed_collections#working_with_array-like_objects">类数组对象</a>）的形式提供的参数。</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span>.apply(thisArg, [argsArray])<br></code></pre></div></td></tr></table></figure><p><strong>注意：</strong>call()方法的作用和 apply() 方法非常非常类似，区别就是<code>call()</code>方法接受的是<strong>参数列表</strong>，而<code>apply()</code>方法接受的是<strong>一个参数数组</strong>。</p><h2 id="bind"><a href="#bind" class="headerlink" title="bind"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind">bind</a></h2><p><code>bind()</code> 方法创建一个<strong>新的函数</strong>，在 <code>bind()</code> 被调用时，这个新函数的 <code>this</code> 被指定为 <code>bind()</code> 的第一个参数，而其余参数将作为新函数的参数，供调用时使用。</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span>.bind(thisArg[, arg1[, arg2[, ...]]])<br></code></pre></div></td></tr></table></figure><p>举例：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> hero = <span class="hljs-string">&#x27;Jackie Chan&#x27;</span>;<br><span class="hljs-comment">//window.hero = &#x27;Jackie Chan&#x27;;</span><br><br><span class="hljs-keyword">let</span> person = &#123;<br>    <span class="hljs-attr">hero</span>:<span class="hljs-string">&#x27;Eason Chan&#x27;</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myHero</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.hero;<br>&#125;<br><br><span class="hljs-keyword">var</span> sayHero = myHero.bind(person);<br><span class="hljs-built_in">console</span>.log(sayHero);<span class="hljs-comment">//ƒ myHero()&#123; return this.hero; &#125;</span><br><br>myHero();<span class="hljs-comment">//&#x27;Jackie Chan&#x27;</span><br>sayHero();<span class="hljs-comment">//&#x27;Eason Chan&#x27;</span><br></code></pre></div></td></tr></table></figure><h2 id="call-apply-bind的应用场景"><a href="#call-apply-bind的应用场景" class="headerlink" title="call/apply/bind的应用场景"></a>call/apply/bind的应用场景</h2><p>参考：<a href="https://www.jianshu.com/p/bc541afad6ee">call、apply和bind方法的用法以及区别 - 简书</a></p><ul><li>求数组中的最大和最小值</li></ul><figure class="highlight jsx"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jsx"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">89</span>,<span class="hljs-number">46</span>]<br><span class="hljs-keyword">var</span> max = <span class="hljs-built_in">Math</span>.max.apply(<span class="hljs-literal">null</span>,arr)<span class="hljs-comment">//89</span><br><span class="hljs-keyword">var</span> min = <span class="hljs-built_in">Math</span>.min.apply(<span class="hljs-literal">null</span>,arr)<span class="hljs-comment">//1</span><br></code></pre></div></td></tr></table></figure><ul><li>将类数组转化为数组</li></ul><figure class="highlight jsx"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jsx"><span class="hljs-keyword">var</span> trueArr = <span class="hljs-built_in">Array</span>.prototype.slice.call(arrayLike)<br></code></pre></div></td></tr></table></figure><ul><li>数组追加</li></ul><figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp"><span class="hljs-keyword">var</span> arr1 = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];<br><span class="hljs-keyword">var</span> arr2 = [<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>];<br><span class="hljs-keyword">var</span> total = [].push.apply(arr1, arr2);<span class="hljs-comment">//6</span><br><span class="hljs-comment">// arr1 [1, 2, 3, 4, 5, 6]</span><br><span class="hljs-comment">// arr2 [4,5,6]</span><br></code></pre></div></td></tr></table></figure><ul><li>判断变量类型</li></ul><figure class="highlight jsx"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isArray</span>(<span class="hljs-params">obj</span>)</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.prototype.toString.call(obj) == <span class="hljs-string">&#x27;[object Array]&#x27;</span>;<br>&#125;<br>isArray([]) <span class="hljs-comment">// true</span><br>isArray(<span class="hljs-string">&#x27;dot&#x27;</span>) <span class="hljs-comment">// false</span><br></code></pre></div></td></tr></table></figure><ul><li>利用call和apply做继承</li></ul><figure class="highlight jsx"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params">name,age</span>)</span>&#123;<br>    <span class="hljs-comment">// 这里的this都指向实例</span><br>    <span class="hljs-built_in">this</span>.name = name<br>    <span class="hljs-built_in">this</span>.age = age<br>    <span class="hljs-built_in">this</span>.sayAge = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.age)<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Female</span>(<span class="hljs-params"></span>)</span>&#123;<br>    Person.apply(<span class="hljs-built_in">this</span>,<span class="hljs-built_in">arguments</span>)<span class="hljs-comment">//将父元素所有方法在这里执行一遍就继承了</span><br>&#125;<br><span class="hljs-keyword">var</span> dot = <span class="hljs-keyword">new</span> Female(<span class="hljs-string">&#x27;Dot&#x27;</span>,<span class="hljs-number">2</span>)<br></code></pre></div></td></tr></table></figure><ul><li>使用 log 代理 console.log</li></ul><figure class="highlight jsx"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">log</span>(<span class="hljs-params"></span>)</span>&#123;<br>  <span class="hljs-built_in">console</span>.log.apply(<span class="hljs-built_in">console</span>, <span class="hljs-built_in">arguments</span>);<br>&#125;<br><span class="hljs-comment">// 当然也有更方便的 var log = console.log()</span><br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>闭包</title>
    <link href="/2021/06/01/%E9%97%AD%E5%8C%85/"/>
    <url>/2021/06/01/%E9%97%AD%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><h2 id="闭包是什么？"><a href="#闭包是什么？" class="headerlink" title="闭包是什么？"></a>闭包是什么？</h2><p>一个函数和对其周围状态的引用捆绑在一起，或者说函数被引用包围，这样的组合就是闭包。闭包让我们可以在一个内层函数中访问到其外层函数的作用域。</p><p>「函数」和「函数内部能访问到的变量」（也叫环境）的总和，就是一个闭包。</p><p>举例：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">init</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> name = <span class="hljs-string">&quot;andy8421&quot;</span>; <span class="hljs-comment">// name 是一个被 init 创建的局部变量</span><br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">displayName</span>(<span class="hljs-params"></span>) </span>&#123; <br>        alert(name);                <br>        <span class="hljs-comment">//displayName使用了父函数中声明的变量name，二者共同构成一个闭包。</span><br>  &#125;<br>   <span class="hljs-keyword">return</span> displayName;<br>&#125;<br><br><span class="hljs-keyword">let</span> myDetail = init();<br>myDetail();<br></code></pre></div></td></tr></table></figure><p><strong>注意</strong>，最后两句和<code>init()();</code>这种调用方法并不相同，后者并没有发挥闭包保存内部变量的作用，这不叫使用了闭包。</p><p>举例：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">a</span>(<span class="hljs-params"></span>)</span>&#123;<br><span class="hljs-keyword">let</span> m=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">let</span> n=<span class="hljs-number">2</span>;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">c</span>(<span class="hljs-params"></span>)</span>&#123;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">`m:<span class="hljs-subst">$&#123;m&#125;</span>`</span>);<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">`n:<span class="hljs-subst">$&#123;n&#125;</span>`</span>);<br>m++;<br>n++;<br>&#125;<br><span class="hljs-keyword">return</span> c;<br>&#125;;<br><br>a()();<span class="hljs-comment">//m:1, n:2</span><br>a()();<span class="hljs-comment">//m:1, n:2</span><br>a()();<span class="hljs-comment">//m:1, n:2</span><br><br><span class="hljs-keyword">let</span> f = a();<br>f();<span class="hljs-comment">//m:1, n:2</span><br>f();<span class="hljs-comment">//m:2, n:3</span><br>f();<span class="hljs-comment">//m:3, n:4</span><br></code></pre></div></td></tr></table></figure><h2 id="闭包的作用是什么？"><a href="#闭包的作用是什么？" class="headerlink" title="闭包的作用是什么？"></a>闭包的作用是什么？</h2><ol><li>访问块级作用域、封装私有变量、模拟私有方法</li></ol><p>举例：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)&#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>        <span class="hljs-built_in">console</span>.log(i);<br>    &#125;,<span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-comment">//控制台打印0，1，2，3，4</span><br></code></pre></div></td></tr></table></figure><p>当计时器（私有方法）开始执行时，for循环已经结束，每一次的<code>i</code>都是该次所在的块（块级作用域）中的<code>i</code>，所以打印的是当时的<code>i</code>（私有变量）值。</p><p>以上代码相当于：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)&#123;<br>    <span class="hljs-keyword">let</span> j=i<br>    <span class="hljs-comment">//const j=i</span><br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>        <span class="hljs-built_in">console</span>.log(j);<br>    &#125;,<span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-comment">//控制台打印0，1，2，3，4</span><br></code></pre></div></td></tr></table></figure><p>此处详细解释见：<a href="https://yichang8421.github.io/2021/03/28/JS%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E6%97%B6%E6%9C%BA/"><strong>JS函数的执行时机</strong></a></p><ol start="2"><li>暴露操作函数而隐藏局部变量</li></ol><p>有时，直接使用全局变量很不妥，会出先某些安全问题。我们不能直接访问这些变量，此时就要用到闭包来隐藏局部变量，而仅暴露一个访问器（函数）来间接访问这些变量。</p><p>​    详见：<a href="https://fangyinghang.com/closures-in-js/">JS 中的闭包是什么？</a></p><h2 id="闭包中的this对象"><a href="#闭包中的this对象" class="headerlink" title="闭包中的this对象"></a>闭包中的this对象</h2><p>问题引入：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> color = <span class="hljs-string">&#x27;red&#x27;</span>;<br><span class="hljs-comment">// window.color = &#x27;red&#x27;;</span><br><br><span class="hljs-keyword">let</span> obj = &#123;<br>    <span class="hljs-attr">color</span>: <span class="hljs-string">&#x27;blue&#x27;</span>,<br>    <span class="hljs-function"><span class="hljs-title">sayColor</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">color</span>(<span class="hljs-params"></span>)</span>&#123;<br>         <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.color;   <br>        &#125;<br>&#125;<br>&#125;;<br><br>obj.sayColor()();<span class="hljs-comment">// &#x27;red&#x27;</span><br></code></pre></div></td></tr></table></figure><p>为什么<code>obj.sayColor()();</code>返回的是window.color的值red,而不是obj的blue?</p><p>以上代码中，首先创建了一个全局变量color，之后又创建了包含color属性的对象obj。obj对象还包含一个名为sayColor的函数，而这个函数本身又返回的是一个函数color()。</p><p>由于函数内部的代码在访问变量时，会沿作用域链查找变量。当函数执行完毕后，局部活动对象会被销毁，内存中就只剩下全局作用域。因此<strong>内部函数永远不可能直接访问外部函数的this和arguments变量</strong>。</p><p>当执行<code>obj.sayColor()</code>后，在函数<code>color()</code>所处的执行上下文中，局部活动对象obj已经被销毁。此时<code>color()</code>只能访问全局作用域中的color变量。</p><p>以上代码中，全局变量<code>color</code>和函数<code>color()</code>构成闭包。</p><p>要想使<code>obj.sayColor()();</code>返回obj的blue，则应该让<code>obj.color</code>和函数<code>color()</code>构成闭包。</p><p>解决方法：</p><p>将this保存到闭包可以访问的另一个变量that中：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> color = <span class="hljs-string">&#x27;red&#x27;</span>;<br><span class="hljs-comment">// window.color = &#x27;red&#x27;;</span><br><br><span class="hljs-keyword">let</span> obj = &#123;<br>    <span class="hljs-attr">color</span>: <span class="hljs-string">&#x27;blue&#x27;</span>,<br>    <span class="hljs-function"><span class="hljs-title">sayColor</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">let</span> that = <span class="hljs-built_in">this</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">color</span>(<span class="hljs-params"></span>)</span>&#123;<br>         <span class="hljs-keyword">return</span> that.color;   <br>        &#125;<br>&#125;<br>&#125;;<br><br>obj.sayColor()();<span class="hljs-comment">// &#x27;blue&#x27;</span><br></code></pre></div></td></tr></table></figure><p>尽管当执行<code>obj.Color()</code>后，其执行上下文的作用域已经被销毁，但函数<code>color()</code>仍然引用了外部函数sayColor的变量(即this)，所以他的活动对象obj仍然保存在内存中，进而obj.color仍然可以访问到。</p><p><em>obj是在color()最终执行完毕才被销毁的。</em></p><h2 id="闭包的缺点是什么？"><a href="#闭包的缺点是什么？" class="headerlink" title="闭包的缺点是什么？"></a>闭包的缺点是什么？</h2><ol><li>因为闭包会保留它们包含函数的作用域，所以比其他函数更占用内存。过度使用闭<br>包可能导致内存过度占用 。</li><li>闭包会在父函数外部改变父函数内部变量的值</li></ol>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Promise</title>
    <link href="/2021/05/01/Promise/"/>
    <url>/2021/05/01/Promise/</url>
    
    <content type="html"><![CDATA[<h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><h2 id="Promise的用途"><a href="#Promise的用途" class="headerlink" title="Promise的用途"></a>Promise的用途</h2><p>如果异步任务有成功和失败两个结果时，如果想不阻塞程序运行，传统方法有两种：</p><p>① 回调接受两个参数：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">fs.readFile(<span class="hljs-string">&#x27;./1.txt&#x27;</span>,<span class="hljs-function">(<span class="hljs-params">error,data</span>)=&gt;</span>&#123;<br><span class="hljs-keyword">if</span>(error)&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;失败&#x27;</span>);<span class="hljs-keyword">return</span>;&#125;<br><span class="hljs-built_in">console</span>.log(data.toString());<br>&#125;);<br></code></pre></div></td></tr></table></figure><p>② 使用两个回调分别表示成功和失败</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 第一个函数时成功回调，第二个函数时失败回调</span><br>ajax(<span class="hljs-string">&#x27;get&#x27;</span>,<span class="hljs-string">&#x27;./1.json&#x27;</span>,<span class="hljs-function">(<span class="hljs-params">data</span>)=&gt;</span>&#123;&#125;,<span class="hljs-function">(<span class="hljs-params">error</span>)=&gt;</span>&#123;&#125;);<br><br><span class="hljs-comment">// 或者接受一个对象，这个对象有两个key分别表示成功和失败</span><br>ajax(<span class="hljs-string">&#x27;get&#x27;</span>,<span class="hljs-string">&#x27;./1.json&#x27;</span>,&#123;<br><span class="hljs-attr">success</span>:<span class="hljs-function">()=&gt;</span>&#123;&#125;,<br><span class="hljs-attr">fail</span>:<span class="hljs-function">()=&gt;</span>&#123;&#125;<br>&#125;);<br></code></pre></div></td></tr></table></figure><p>传统方法存在以下不足：</p><p>Ⅰ. 代码不规范</p><p>Ⅱ. 容易出现回调地狱</p><p>Ⅲ. 很难进行错误处理</p><p> 为了解决这些问题，前端程序员提出了Promise思想，制定了Promise/A+规范。</p><h2 id="创建Promise"><a href="#创建Promise" class="headerlink" title="创建Promise"></a>创建Promise</h2><figure class="highlight coffeescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs coffeescript"><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">(resolve,reject)</span>=&gt;</span>&#123;&#125;);<br></code></pre></div></td></tr></table></figure><p>任务成功则调用resolve(result)</p><p>任务失败则调用reject(error)</p><p>resolve和reject再通过then方法</p><h2 id="Promise-prototype-then"><a href="#Promise-prototype-then" class="headerlink" title="Promise.prototype.then"></a>Promise.prototype.then</h2><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">p.then(onFulfilled[, onRejected]);<br><br>p.then(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>  <span class="hljs-comment">// fulfillment</span><br>&#125;, <span class="hljs-function"><span class="hljs-params">reason</span> =&gt;</span> &#123;<br>  <span class="hljs-comment">// rejection</span><br>&#125;);<br></code></pre></div></td></tr></table></figure><p>then的第一个参数就是success</p><p>then的第二个参数就是fail</p><p>举例：</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  resolve(<span class="hljs-string">&#x27;Success！&#x27;</span>);<br>  <span class="hljs-comment">// or</span><br>  <span class="hljs-comment">// reject(new Error(&quot;fucking fucked！&quot;));</span><br>&#125;);<br><br>p1.then(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(value); <span class="hljs-comment">// Success！</span><br>&#125;, <span class="hljs-function"><span class="hljs-params">reason</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.error(reason); <span class="hljs-comment">// Error: fucking fucked!</span><br>&#125;);<br></code></pre></div></td></tr></table></figure><h2 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all"></a>Promise.all</h2><p>Promise.all() 方法接收一个promise的iterable类型（Array，Map，Set）的输入，并且只返回一个<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise"><code>Promise</code></a>实例， 那个输入的所有promise的resolve回调的结果是一个数组。</p><p>语法：</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-built_in">Promise</span>.all(iterable);<br></code></pre></div></td></tr></table></figure><p>返回值</p><ul><li>如果传入的参数是一个空的可迭代对象，则返回一个<strong>已完成（already resolved）</strong>状态的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise"><code>Promise</code></a>。</li><li>如果传入的参数不包含任何 <code>promise</code>，则返回一个<strong>异步完成（asynchronously resolved）</strong> <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise"><code>Promise</code></a>。注意：Google Chrome 58 在这种情况下返回一个<strong>已完成（already resolved）</strong>状态的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise"><code>Promise</code></a>。</li><li>其它情况下返回一个<strong>处理中（pending）</strong>的<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise"><code>Promise</code></a>。这个返回的 <code>promise</code> 之后会在所有的 <code>promise</code> 都完成或有一个 <code>promise</code> 失败时<strong>异步</strong>地变为完成或失败。 见下方关于“Promise.all 的异步或同步”示例。返回值将会按照参数内的 <code>promise</code> 顺序排列，而不是由调用 <code>promise</code> 的完成顺序决定。</li></ul><h2 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race"></a>Promise.race</h2><p><strong>Promise.race(iterable)</strong> 方法返回一个 promise，一旦迭代器中的某个promise解决或拒绝，返回的 promise就会解决或拒绝。</p><p>语法：</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-built_in">Promise</span>.race(iterable);<br></code></pre></div></td></tr></table></figure><p>参数</p><ul><li><p>iterable</p><p>可迭代对象，类似<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array"><code>Array</code></a>。详见 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols">iterable</a>。</p></li></ul><p>返回值</p><p>一个<strong>待定的</strong> <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise"><code>Promise</code></a> 只要给定的迭代中的一个promise解决或拒绝，就采用第一个promise的值作为它的值，从而<strong>异步</strong>地解析或拒绝（一旦堆栈为空）。</p><p>描述</p><p><code>race</code> 函数返回一个 <code>Promise</code>，它将与第一个传递的 promise 相同的完成方式被完成。它可以是完成（ resolves），也可以是失败（rejects），这要取决于第一个完成的方式是两个中的哪个。</p><p>如果传的迭代是空的，则返回的 promise 将永远等待。</p><p>如果迭代包含一个或多个非承诺值和/或已解决/拒绝的承诺，则<code> Promise.race</code> 将解析为迭代中找到的第一个值。</p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS函数的执行时机</title>
    <link href="/2021/03/28/JS%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E6%97%B6%E6%9C%BA/"/>
    <url>/2021/03/28/JS%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E6%97%B6%E6%9C%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="JS函数的执行时机"><a href="#JS函数的执行时机" class="headerlink" title="JS函数的执行时机"></a>JS函数的执行时机</h1><h2 id="问题引入（五个5问题）："><a href="#问题引入（五个5问题）：" class="headerlink" title="问题引入（五个5问题）："></a>问题引入（五个5问题）：</h2><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)&#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>        <span class="hljs-built_in">console</span>.log(i)<br>    &#125;,<span class="hljs-number">0</span>)<br>&#125;<br><span class="hljs-comment">//控制台打印五个5</span><br><span class="hljs-comment">//return为浏览器输出的，不关心。下文不再赘述。</span><br></code></pre></div></td></tr></table></figure><p>为什么控制台打印出了五个5，而不是0、1、2、3、4，<strong>why</strong>？</p><h2 id="深入理解JS函数的执行时机"><a href="#深入理解JS函数的执行时机" class="headerlink" title="深入理解JS函数的执行时机"></a>深入理解JS函数的执行时机</h2><p>输出以上结果的前提是：</p><p>① <code>var</code>声明使得<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/var#%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87"><strong>变量提升</strong></a>。使用var命令声明，同时<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/var#description">给未声明的变量赋值, 则执行赋值后, 该变量会被隐式地创建为全局变量（成为全局对象的属性)</a>。</p><p>因此，此代码中，for循环的i被提升为全局变量（<strong>for循环全程只有一个变量i</strong>）。</p><p>以上代码等价于：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> i<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)&#123;<br>   ...<br>&#125;<br></code></pre></div></td></tr></table></figure><p>感觉这个代码比较啰嗦，以下均使用for循环内部的<code>var</code>命令来声明全局的<code>i</code>。</p><p>② JavaScript是一门<strong>单线程语言</strong>。每一个任务只能按顺序依次进行。</p><p>上述代码中的<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout">window.setTimeout</a>设置了一个<strong>定时器</strong>，该定时器在一段时期后（可以理解为之前的任务完成后）才执行一个函数或指定的一段代码。</p><p>因此在执行<code>setTimeout(()=&gt;&#123;console.log(i);&#125;,0);</code>时，for循环已经结束，此时i的值为5.</p><p>所以此时每次执行的<code>console.log(i);</code>结果都为5。</p><p><strong>通俗的理解</strong>，在当前任务还没有完成时，就安排了下一个任务，而下一个任务的进行需要上一个任务得到的结果（这里前后两个任务分别是for循环和计时器）。那么JS会先把当前任务完成，然后再开始完成下一个任务。此时，下一个任务用到的数据应该是当前任务（for循环）完成之后（<strong>have done</strong>）的数据，而不是正在完成（<strong>v.ing</strong>）的数据。</p><h3 id="异步任务"><a href="#异步任务" class="headerlink" title="异步任务"></a><a href="https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Asynchronous">异步任务</a></h3><p>通常来说，程序都是顺序执行，同一时刻只会发生一件事。如果一个函数依赖于另一个函数的结果，它只能等待那个函数结束才能继续执行，从用户的角度来说，整个程序才算运行完毕。</p><p>使用<strong>异步函数</strong>可以设置函数队列的执行顺序。JS中最基本的异步函数有：</p><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout">window.setTimeout</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/WindowOrWorkerGlobalScope/setInterval">window.setInterval</a></li></ul><h2 id="灵活使用-TL-DR"><a href="#灵活使用-TL-DR" class="headerlink" title="灵活使用(TL;DR)"></a>灵活使用(TL;DR)</h2><p>如何打出想要的0-4？</p><p><strong>理解关键点</strong>：只要 ①在局部作用域中<strong>创造</strong>它的<strong>局部变量<code>i</code><strong>（方法一） 或者 ②在</strong>局部作用域</strong>中<strong>使用</strong>全局变量<code>i</code>（方法二和方法三）就能够达到目的。</p><p><strong>方法一</strong>（for循环内部使用let声明）：</p><p>可以将var声明改为<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/let"><code>let</code></a>声明。它能声明一个块级作用域的本地变量。</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)&#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>        <span class="hljs-built_in">console</span>.log(i);<br>    &#125;,<span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-comment">//控制台打印0，1，2，3，4</span><br></code></pre></div></td></tr></table></figure><p>let肯定不能放在for循环外面，上文已经解释。</p><p>此时，尽管计时器开始执行时，for循环已经结束，但每一次的<code>i</code>都是该次所在的块中的<code>i</code>，所以打印的是当时的i值。</p><p>注意，此时<strong>for循环将产生六个局部变量i</strong>，分别是0，1，2，3，4，5。</p><p>同样的道理，也可以在for循环中<strong>单独声明</strong>一个变量j（使用let或const）。此代码比较无聊，但对于理解方法一有帮助：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)&#123;<br>    <span class="hljs-keyword">let</span> j=i<br>    <span class="hljs-comment">//const j=i</span><br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>        <span class="hljs-built_in">console</span>.log(j);<br>    &#125;,<span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-comment">//控制台打印0，1，2，3，4</span><br></code></pre></div></td></tr></table></figure><p><strong>方法二</strong>（立即执行函数）：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)&#123;<br>    !<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">i</span>)</span>&#123;<br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>        <span class="hljs-built_in">console</span>.log(i)<br>    &#125;,<span class="hljs-number">0</span>)<br>    &#125;(i)<br>&#125;<br><span class="hljs-comment">//控制台打印0，1，2，3，4</span><br></code></pre></div></td></tr></table></figure><p>使用立即执行函数可以创造一个局部作用域，进而达到想要的效果：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">!<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>       <span class="hljs-comment">/*</span><br><span class="hljs-comment">       局部作用域。</span><br><span class="hljs-comment">       */</span><br>   &#125;()<br></code></pre></div></td></tr></table></figure><p><strong>方法三</strong>（setTimeout函数传参）：</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout">window.setTimeout</a>的第三个参数用于设定function的参数</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)&#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">i</span>)</span>&#123;<br>        <span class="hljs-built_in">console</span>.log(i)<br>    &#125;,<span class="hljs-number">0</span>,i)<br>&#125;<br><span class="hljs-comment">//控制台打印0，1，2，3，4</span><br></code></pre></div></td></tr></table></figure><p>此时，每一次进入for循环，第三个参数都告诉计时器：不用等for循环完成，你现在就能拿到i值给你的function执行了。所以每一次都能直接打印出当次的i值。</p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DOM事件模型和事件委托（下）</title>
    <link href="/2020/02/18/DOM%E4%BA%8B%E4%BB%B6%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
    <url>/2020/02/18/DOM%E4%BA%8B%E4%BB%B6%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98%EF%BC%88%E4%B8%8B%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="DOM事件模型和事件委托（下）"><a href="#DOM事件模型和事件委托（下）" class="headerlink" title="DOM事件模型和事件委托（下）"></a>DOM事件模型和事件委托（下）</h1><h2 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h2><p>当监听子元素时，事件冒泡会通过目标元素向上传递到父级，直到<code>document</code>，如果子元素不确定或者动态生成，<strong>可以通过监听祖先素来取代监听子元素。</strong></p><p>通俗理解：儿子办不成或难办成的事找爹办，爹也办不成的找爷爷办，总之谁有能力办成就找谁办。</p><h3 id="情形一：给多个按钮添加点击事件，具体哪个按钮不确定"><a href="#情形一：给多个按钮添加点击事件，具体哪个按钮不确定" class="headerlink" title="情形一：给多个按钮添加点击事件，具体哪个按钮不确定"></a>情形一：给多个按钮添加点击事件，具体哪个按钮不确定</h3><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">情形一：<br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;div1&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>click 1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>click 2<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>click 3<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>click 4<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>click 5<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>click 6<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>click 7<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>click 8<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>click 9<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>click 10<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>click 11<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>click 12<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>click 13<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>click 14<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>click 15<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>click 16<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>click 17<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>click 18<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>click 19<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>click 20<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>e.target是button，但操作哪个button并不确定，此时可以监听父元素div</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;.div1&#x27;</span>).addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> t = e.target;<br>    <span class="hljs-keyword">if</span>(t.tagName.toLowerCase() === <span class="hljs-string">&#x27;button&#x27;</span>)&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;button被点击了&#x27;</span>);<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;button内容是：&#x27;</span> + t.textContent);<br>    &#125;<br>&#125;);<br></code></pre></div></td></tr></table></figure><h3 id="情形二：监听原本不存在的元素"><a href="#情形二：监听原本不存在的元素" class="headerlink" title="情形二：监听原本不存在的元素"></a>情形二：监听原本不存在的元素</h3><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs HTML"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;div2&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>假设div的子元素button要在一段时间之后才生成，那也不能够直接监听button，此时也可以使用事件委托。</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> button = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;button&#x27;</span>);<br>    button.textContent = <span class="hljs-string">&#x27;click 21&#x27;</span>;<br>    div2.appendChild(button);<br>&#125;, <span class="hljs-number">500</span>);<br><br>div2.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> t = e.target;<br>    <span class="hljs-comment">// if (t.tagName.toLowerCase() === &#x27;button&#x27;) &#123;</span><br>    <span class="hljs-comment">//     console.log(&#x27;新添加的button被点击&#x27;);</span><br>    <span class="hljs-comment">// &#125;</span><br>    <span class="hljs-keyword">if</span> (t.matches(<span class="hljs-string">&#x27;button&#x27;</span>)) &#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;新添加的button被点击&#x27;</span>);<br>    &#125;<br>&#125;);<br></code></pre></div></td></tr></table></figure><h3 id="情形三：使用自定义函数监听不存在的元素"><a href="#情形三：使用自定义函数监听不存在的元素" class="headerlink" title="情形三：使用自定义函数监听不存在的元素"></a>情形三：使用自定义函数监听不存在的元素</h3><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;div3&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>自定义函数on()可以实现事件委托。</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">on</span>(<span class="hljs-params">eventType, element, selector, fn</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (!(element <span class="hljs-keyword">instanceof</span> Element)) &#123;<br>        element = <span class="hljs-built_in">document</span>.querySelector(element);<br>    &#125;<br>    element.addEventListener(eventType, <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> &#123;<br>        <span class="hljs-keyword">let</span> el = e.target;<br>        <span class="hljs-keyword">while</span> (!el.matches(selector)) &#123;<br>            <span class="hljs-keyword">if</span> (element === el) &#123;<br>            <span class="hljs-comment">//   如果当被操作元素已经等于传入元素（最顶端元素）仍不匹配selector时，说明被操作元素不存在，跳出循环</span><br>              el = <span class="hljs-literal">null</span>;<br>              <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-comment">// 当被造作元素不匹配selector时，就将指针移动到父元素</span><br>            el = el.parentNode;<br>        &#125;<br><br>        <span class="hljs-comment">// 当被操作元素部位falsy时，调用fn</span><br>        el &amp;&amp; fn.call(el, e, el);<br>      &#125;)<br>    <span class="hljs-keyword">return</span> element;<br>&#125;<br><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> button = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;button&#x27;</span>);<br>    <span class="hljs-keyword">const</span> span = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;span&#x27;</span>);<br>    span.textContent = <span class="hljs-string">&#x27;click 22&#x27;</span>;<br>    button.appendChild(span);<br>    div3.appendChild(button);<br>&#125;, <span class="hljs-number">500</span>);<br><br>on.call(<span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-string">&#x27;#div3&#x27;</span>, <span class="hljs-string">&#x27;button&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;自定义函数on()被触发&#x27;</span>);<br>&#125;);<br></code></pre></div></td></tr></table></figure><h4 id="可以将on封装到jQuery中，使用更方便："><a href="#可以将on封装到jQuery中，使用更方便：" class="headerlink" title="可以将on封装到jQuery中，使用更方便："></a>可以将on封装到jQuery中，使用更方便：</h4><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;div4&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>以下为封装jQuery的基本方法：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">/* 封装 */</span><br><span class="hljs-built_in">window</span>.$ = <span class="hljs-built_in">window</span>.jQuery = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">selectorOrArrayOrTemplate</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> elements;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> selectorOrArrayOrTemplate === <span class="hljs-string">&#x27;string&#x27;</span>) &#123;<br>        <span class="hljs-keyword">if</span> (selectorOrArrayOrTemplate[<span class="hljs-number">0</span>] === <span class="hljs-string">&#x27;&lt;&#x27;</span>) &#123;<br>            elements = [createElement(selectorOrArrayOrTemplate)];<br>            <span class="hljs-comment">/* 定义elements的目的是操作elements，应将其设置为数组 */</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            elements = <span class="hljs-built_in">document</span>.querySelectorAll(selectorOrArrayOrTemplate);<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (selectorOrArrayOrTemplate <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Array</span>) &#123;<br>        elements = selectorOrArrayOrTemplate;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createElement</span>(<span class="hljs-params">string</span>) </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> string === <span class="hljs-string">&#x27;string&#x27;</span>) &#123;<br>            <span class="hljs-keyword">const</span> container = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;template&#x27;</span>);<br>            container.innerHTML = string.trim();<br>            <span class="hljs-keyword">return</span> container.content.firstChild;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Error! please enter a string.&#x27;</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//设置jQuery原型，节约内存</span><br>    <span class="hljs-keyword">const</span> api = <span class="hljs-built_in">Object</span>.create(jQuery.prototype);<br>    <span class="hljs-comment">//创建对象api。api.__proto__=jQuery.prototype</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     api.elements = elements;</span><br><span class="hljs-comment">     api.oldApi = selectorOrArrayOrTemplate.oldApi;</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-built_in">Object</span>.assign(api, &#123;<br>        <span class="hljs-attr">elements</span>: elements,<br>        <span class="hljs-attr">oldApi</span>: selectorOrArrayOrTemplate.oldApi,<br>    &#125;);<br>    <span class="hljs-keyword">return</span> api;<br>&#125;;<br><br>jQuery.fn = jQuery.prototype = &#123;<br>    <span class="hljs-attr">constructor</span>: jQuery,<br>    <span class="hljs-attr">jQuery</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-comment">// 点击事件</span><br>    <span class="hljs-function"><span class="hljs-title">on</span>(<span class="hljs-params">eventType, element, selector, fn</span>)</span> &#123;<br>        <span class="hljs-keyword">if</span> (!(<span class="hljs-built_in">this</span>.element <span class="hljs-keyword">instanceof</span> Element)) &#123;<br>            <span class="hljs-built_in">this</span>.element = <span class="hljs-built_in">document</span>.querySelector(element);<br>        &#125;<br>        <span class="hljs-built_in">this</span>.element.addEventListener(eventType, <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> &#123;<br>            <span class="hljs-keyword">let</span> el = e.target;<br>            <span class="hljs-keyword">while</span> (!el.matches(selector)) &#123;<br>                <span class="hljs-keyword">if</span> (element === el) &#123;<br>                <span class="hljs-comment">//   如果当被操作元素已经等于传入元素（最顶端元素）仍不匹配selector时，说明被操作元素不存在，跳出循环</span><br>                  el = <span class="hljs-literal">null</span>;<br>                  <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-comment">// 当被造作元素不匹配selector时，就将指针移动到父元素</span><br>                el = el.parentNode;<br>            &#125;<br>    <br>            <span class="hljs-comment">// 当被操作元素部位falsy时，调用fn</span><br>            el &amp;&amp; fn.call(el, e, el);<br>          &#125;)<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/* 情形三 */</span><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> button = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;button&#x27;</span>);<br>    <span class="hljs-keyword">const</span> span = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;span&#x27;</span>);<br>    span.textContent = <span class="hljs-string">&#x27;click 22&#x27;</span>;<br>    button.appendChild(span);<br>    div4.appendChild(button);<br>&#125;, <span class="hljs-number">500</span>);<br><br><span class="hljs-comment">/* 调用jQuery方法 */</span><br>$(<span class="hljs-string">&#x27;#div4&#x27;</span>).on(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-string">&#x27;#div4&#x27;</span>, <span class="hljs-string">&#x27;button&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;自定义jQuery的on()函数被触发&#x27;</span>);<br>&#125;);<br></code></pre></div></td></tr></table></figure><p><strong>优点：</strong></p><ul><li>省监听数（内存）</li><li>可以监听动态元素</li></ul><h2 id="TL-DR-面试题"><a href="#TL-DR-面试题" class="headerlink" title="TL;DR 面试题"></a>TL;DR 面试题</h2><p>请简述事件委托。</p><p><strong>答：</strong></p><p>事件委托就是把事件监听放在祖先元素（如父元素、爷爷元素）上。<br>好处是：1 节约监听数量 2 可以监听动态生成的元素。</p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>Front end</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DOM事件模型和事件委托（上）</title>
    <link href="/2020/02/15/DOM%E4%BA%8B%E4%BB%B6%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
    <url>/2020/02/15/DOM%E4%BA%8B%E4%BB%B6%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98%EF%BC%88%E4%B8%8A%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="DOM事件模型和事件委托（上）"><a href="#DOM事件模型和事件委托（上）" class="headerlink" title="DOM事件模型和事件委托（上）"></a>DOM事件模型和事件委托（上）</h1><h2 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL;DR"></a>TL;DR</h2><h3 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h3><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml">add<span class="hljs-constructor">EventListener(&#x27;<span class="hljs-params">click</span>&#x27;,<span class="hljs-params">fn</span>,<span class="hljs-params">bool</span>)</span>;<br></code></pre></div></td></tr></table></figure><ul><li>如果bool值不传或为falsy，fn走冒泡</li><li>如果bool值为true，fn走捕获</li></ul><h3 id="target和currentTarget"><a href="#target和currentTarget" class="headerlink" title="target和currentTarget"></a><strong>target和currentTarget</strong></h3><ul><li><code>e.target</code> 是用户<strong>操作</strong>的元素</li><li><code>e.currentTarget</code> 是程序员<strong>监听</strong>的元素</li></ul><p>举例：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs text">div&gt;span&#123;文字&#125;<br>在div上绑定了事件监听函数<br>用户点击文字后，e.target 指span，e.currentTarget指div<br></code></pre></div></td></tr></table></figure><h3 id="event-stopPropagation-event-stopPropagation-Web-API-接口参考-MDN-mozilla-org"><a href="#event-stopPropagation-event-stopPropagation-Web-API-接口参考-MDN-mozilla-org" class="headerlink" title="[event.stopPropagation](event.stopPropagation - Web API 接口参考 | MDN (mozilla.org))"></a><strong>[event.stopPropagation](<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Event/stopPropagation">event.stopPropagation - Web API 接口参考 | MDN (mozilla.org)</a>)</strong></h3><p><strong>捕获和冒泡都可以阻止</strong>：阻止<strong>捕获</strong>和<strong>冒泡</strong>阶段中当前事件的进一步传播（注意是都可以，MDN文档有解释，实践也证明如此）。</p><p>但是，它不能防止任何<strong>默认行为</strong>的发生； 例如，对链接的点击仍会被处理。</p><p>如果要停止这些行为，请参见 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Event/preventDefault">preventDefault</a> 方法，它可以阻止事件触发后默认动作的发生。</p><h3 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/CustomEvent/CustomEvent">自定义事件</a></h3><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> event = <span class="hljs-keyword">new</span> CustomEvent(<span class="hljs-string">&quot;eventName&quot;</span>, customEventInit);<br></code></pre></div></td></tr></table></figure><p><code>customEventInit</code>包含detial、bubbles、cancelable三个key值。</p><h3 id="发派事件"><a href="#发派事件" class="headerlink" title="发派事件"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/dispatchEvent">发派事件</a></h3><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">target.dispatchEvent(event);<br></code></pre></div></td></tr></table></figure><ul><li>event 是要被派发的事件对象。</li><li>target被用来初始化 事件 和 决定将会触发 目标。</li></ul><h2 id="1-DOM事件模型"><a href="#1-DOM事件模型" class="headerlink" title="1. DOM事件模型"></a>1. DOM事件模型</h2><h3 id="1-1-DOM事件（流）"><a href="#1-1-DOM事件（流）" class="headerlink" title="1.1 DOM事件（流）"></a>1.1 DOM事件（流）</h3><p>根据[维基百科](<a href="https://zh.wikipedia.org/wiki/%E4%BA%8B%E4%BB%B6%E9%A9%85%E5%8B%95%E7%A8%8B%E5%BC%8F%E8%A8%AD%E8%A8%88">事件驱动程序设计 - 维基百科，自由的百科全书 (wikipedia.org)</a>)的定义：<strong>事件</strong>或者<strong>事件驱动程序设计</strong>（<strong>Event-driven programming</strong>）是一种程序设计模型。这种程序运行流程是由用户的动作（如鼠标点击，键盘的按键动作）或者是由其他程序的指令性事件来决定的。</p><p>当事件发生在<strong>某个DOM节点</strong>上时，事件会在DOM结构中进行逐级的传播（propagation）。<strong>这个传播过程称为事件流</strong>。</p><p>我们可以利用**<a href="%5BEventTarget.addEventListener(">事件监听</a> - Web API 接口参考 | MDN (mozilla.org)](<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/addEventListener))**%E6%9D%A5%E6%8E%A7%E5%88%B6%E9%A1%B5%E9%9D%A2%E5%AF%B9%E6%89%80%E8%A7%A6%E5%8F%91%E4%BA%8B%E4%BB%B6%E5%8F%91%E5%87%BA%E5%93%8D%E5%BA%94%EF%BC%9A%E5%BD%93%E4%BA%8B%E4%BB%B6%E8%A7%A6%E5%8F%91%E6%97%B6%E6%89%A7%E8%A1%8C%E7%9B%B8%E5%BA%94%E7%9A%84%E7%A8%8B%E5%BA%8F%EF%BC%8C%E8%BF%9B%E8%80%8C%E5%AE%9E%E7%8E%B0%E7%94%A8%E6%88%B7%E5%92%8C%E7%BD%91%E9%A1%B5%E7%9A%84%E4%BA%A4%E4%BA%92%E3%80%82">https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/addEventListener))**来控制页面对所触发事件发出响应：当事件触发时执行相应的程序，进而实现用户和网页的交互。</a></p><h3 id="1-2-DOM事件模型——捕获和冒泡"><a href="#1-2-DOM事件模型——捕获和冒泡" class="headerlink" title="1.2 DOM事件模型——捕获和冒泡"></a>1.2 DOM事件模型——捕获和冒泡</h3><p>根据W3C的[**DOM3级事件草案**](<a href="https://www.w3.org/TR/DOM-Level-3-Events/#dom-event-architecture">UI Events (w3.org)</a>)，浏览器应同时支持两种调用顺序，共三个事件阶段：</p><ul><li><strong>捕获阶段（capture phase）</strong>：事件对象从window开始，由目标元素的祖先传播到目标元素的的父母，自上而下传播。此阶段也称为<em>捕获阶段</em>。</li><li><strong>目标阶段（target phase）</strong>：事件对象到达它的的event target。此阶段也称为<em>目标阶段</em>。<ul><li> 如果<a href="https://www.w3.org/TR/DOM-Level-3-Events/#event-type">事件类型</a>指定了事件对象默认不冒泡（<code>bubbles: false</code>），则事件对象将在完成此阶段后停止。</li></ul></li><li><strong>冒泡阶段（bubbling phase）</strong>：事件对象以相反顺序自下向上，由目标元素开始，经过目标的父母向祖先元素传播，直到到window结束。此阶段也称为<em>冒泡阶段</em>。</li></ul><p><strong>W3C 事件模型/事件机制</strong>：对每个事件<strong>先捕获再冒泡</strong>。</p><p><img src="/2020/02/15/DOM%E4%BA%8B%E4%BB%B6%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98%EF%BC%88%E4%B8%8A%EF%BC%89/eventFlow.png" alt="Graphical representation of an event dispatched in a DOM tree using the DOM event flow"></p><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>预览：<a href="https://yichang8421.github.io/DOMEvent/dist/">https://yichang8421.github.io/DOMEvent/dist/</a></p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs HTML"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;level1 x&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;level2 x&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;level3 x&quot;</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;level4 x&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;level5 x&quot;</span>&gt;</span><br>              <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;level6 x&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;level7 x&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>              <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>          <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.bootcdn.net/ajax/libs/jquery/3.6.0/jquery.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;main.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></div></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> level1 = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;.level1&#x27;</span>);<br><span class="hljs-keyword">const</span> level2 = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;.level2&#x27;</span>);<br><span class="hljs-keyword">const</span> level3 = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;.level3&#x27;</span>);<br><span class="hljs-keyword">const</span> level4 = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;.level4&#x27;</span>);<br><span class="hljs-keyword">const</span> level5 = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;.level5&#x27;</span>);<br><span class="hljs-keyword">const</span> level6 = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;.level6&#x27;</span>);<br><span class="hljs-keyword">const</span> level7 = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;.level7&#x27;</span>);<br><br><span class="hljs-keyword">let</span> n = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">const</span> removeX = <span class="hljs-function">(<span class="hljs-params">e</span>)=&gt;</span>&#123;<br>  <span class="hljs-keyword">const</span> t = e.currentTarget;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>    t.classList.remove(<span class="hljs-string">&#x27;x&#x27;</span>);<br>  &#125;,n*<span class="hljs-number">500</span>);<br>  n+=<span class="hljs-number">1</span>;<br>&#125;;<br><span class="hljs-keyword">const</span> addX =<span class="hljs-function">(<span class="hljs-params">e</span>)=&gt;</span>&#123;<br>  <span class="hljs-keyword">const</span> t = e.currentTarget;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>    t.classList.add(<span class="hljs-string">&#x27;x&#x27;</span>);<br>  &#125;,n*<span class="hljs-number">500</span>);<br>  n+=<span class="hljs-number">1</span>;<br>&#125;;<br><br><span class="hljs-comment">// 在第四个div阻止冒泡</span><br>level4.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>,<span class="hljs-function">(<span class="hljs-params">e</span>)=&gt;</span>&#123;<br>  e.stopPropagation();<br>&#125;);<br><br><span class="hljs-comment">// 在第四个div阻止捕获</span><br><span class="hljs-comment">// level4.addEventListener(&#x27;click&#x27;,(e)=&gt;&#123;</span><br><span class="hljs-comment">//     e.stopPropagation();</span><br><span class="hljs-comment">//   &#125;,true);</span><br><br>$(<span class="hljs-string">&#x27;div&#x27;</span>).each(<span class="hljs-function">(<span class="hljs-params">i, e</span>) =&gt;</span> &#123;<br>    e.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, addX,);<br>&#125;);<br><br>$(<span class="hljs-string">&#x27;div&#x27;</span>).each(<span class="hljs-function">(<span class="hljs-params">i,e</span>)=&gt;</span>&#123;<br>  e.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>,removeX,<span class="hljs-literal">true</span>);<br>&#125;);<br></code></pre></div></td></tr></table></figure><h2 id="2-自定义事件"><a href="#2-自定义事件" class="headerlink" title="2. 自定义事件"></a>2. 自定义事件</h2><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;div1&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;button1&quot;</span>&gt;</span>点击触发 自定义 事件<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript">      button1.addEventListener(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;</span><br><span class="javascript">        <span class="hljs-comment">// 自定义事件</span></span><br><span class="javascript">        <span class="hljs-keyword">const</span> event = <span class="hljs-keyword">new</span> CustomEvent(<span class="hljs-string">&quot;newEvent&quot;</span>, &#123;</span><br><span class="javascript">          <span class="hljs-attr">detail</span>: &#123;</span><br><span class="javascript">            <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;andy8421&quot;</span>,</span><br><span class="javascript">            <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,</span><br><span class="javascript">          &#125;,</span><br><span class="javascript">          <span class="hljs-comment">// 设置可以冒泡</span></span><br><span class="javascript">          <span class="hljs-attr">bubbles</span>: <span class="hljs-literal">true</span>,</span><br><span class="javascript">          <span class="hljs-comment">// 不允许阻止冒泡</span></span><br><span class="javascript">          <span class="hljs-attr">cancelable</span>: <span class="hljs-literal">false</span>,</span><br><span class="javascript">        &#125;);</span><br><span class="javascript"></span><br><span class="javascript">        <span class="hljs-comment">// 将自定义的事件发派给button1</span></span><br><span class="javascript">        button1.dispatchEvent(event);</span><br><span class="javascript">      &#125;);</span><br><span class="javascript"></span><br><span class="javascript">      div1.addEventListener(<span class="hljs-string">&quot;newEvent&quot;</span>, <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;</span><br><span class="javascript">        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;触发newEvent事件&quot;</span>);</span><br><span class="javascript">        <span class="hljs-built_in">console</span>.log(e.detail);</span><br><span class="javascript">      &#125;);</span><br><span class="javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h2 id="面试题："><a href="#面试题：" class="headerlink" title="面试题："></a>面试题：</h2><p>请简述 DOM 事件模型或 DOM 事件机制。</p><p><strong>答：</strong></p><p>捕获：当用户点击按钮，浏览器会从 window 从上向下遍历至用户点击的按钮，逐个触发事件处理函数。<br>冒泡：浏览器从用户点击的按钮从下往上遍历至 window，逐个触发事件处理函数。<br>W3C 事件模型/事件机制：对每个事件先捕获再冒泡。</p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>Front end</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入理解JQuery设计思想--基于手写DOM库</title>
    <link href="/2020/01/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jQuery%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/"/>
    <url>/2020/01/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jQuery%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/</url>
    
    <content type="html"><![CDATA[<h1 id="深入理解JQuery设计思想"><a href="#深入理解JQuery设计思想" class="headerlink" title="深入理解JQuery设计思想"></a>深入理解JQuery设计思想</h1><h2 id="从封装DOM开始"><a href="#从封装DOM开始" class="headerlink" title="从封装DOM开始"></a>从封装DOM开始</h2><p>由于原生DOM操作比较麻烦，我使用原生JavaScript对常用DOM操作进行了封装。</p><p>[代码连接](<a href="https://github.com/yichang8421/jsDOM/blob/master/src/dom.js">jsDOM/dom.js at master · yichang8421/jsDOM (github.com)</a>)</p><p>API使用范例：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// document.createElement(&#x27;div&#x27;);</span><br><span class="hljs-keyword">const</span> div = dom.create(<span class="hljs-string">&quot;&lt;div&gt;newDiv1&lt;/div&gt;&quot;</span>);<br><span class="hljs-built_in">console</span>.log(div);<br><br><span class="hljs-comment">// dom.after()</span><br>dom.after(<span class="hljs-built_in">window</span>.test, div);<br><br><span class="hljs-keyword">const</span> div2 = dom.create(<span class="hljs-string">&quot;&lt;div&gt;newDiv2&lt;/div&gt;&quot;</span>);<br>dom.before(<span class="hljs-built_in">window</span>.test, div2);<br><br><span class="hljs-comment">// dom.wrap()</span><br><span class="hljs-keyword">const</span> div3 = dom.create(<span class="hljs-string">&quot;&lt;div id=&#x27;parent&#x27;&gt;&lt;/div&gt;&quot;</span>);<br>dom.wrap(<span class="hljs-built_in">window</span>.test, div3);<br><br><span class="hljs-comment">// dom.empty()</span><br><span class="hljs-keyword">const</span> node = dom.empty(<span class="hljs-built_in">window</span>.testEmpty);<br><span class="hljs-built_in">console</span>.log(node);<br><br><span class="hljs-comment">// dom.attr() </span><br><span class="hljs-comment">// 设置title属性</span><br>dom.attr(<span class="hljs-built_in">window</span>.test, <span class="hljs-string">&#x27;title&#x27;</span>, <span class="hljs-string">&#x27;helloWorld&#x27;</span>);<br><span class="hljs-comment">// 读取title属性</span><br><span class="hljs-keyword">const</span> title = dom.attr(<span class="hljs-built_in">window</span>.test, <span class="hljs-string">&#x27;title&#x27;</span>);<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">`title:<span class="hljs-subst">$&#123;title&#125;</span>`</span>);<br><br><span class="hljs-comment">// dom.text()</span><br><span class="hljs-comment">// 设置节点的文本内容(会整体替换节点内容)</span><br>dom.text(<span class="hljs-built_in">window</span>.test, <span class="hljs-string">&#x27;你好，这是新的内容&#x27;</span>);<br><span class="hljs-comment">//获取节点的文本内容</span><br>dom.text(<span class="hljs-built_in">window</span>.test);<br><br><span class="hljs-comment">// dom.style()</span><br><span class="hljs-comment">// 设置节点的样式</span><br>dom.style(<span class="hljs-built_in">window</span>.test, &#123;<span class="hljs-attr">border</span>: <span class="hljs-string">&#x27;1px solid red&#x27;</span>, <span class="hljs-attr">color</span>: <span class="hljs-string">&#x27;green&#x27;</span>&#125;);<br><span class="hljs-comment">// 获取节点的样式</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">`test.color: <span class="hljs-subst">$&#123;dom.style(<span class="hljs-built_in">window</span>.test, <span class="hljs-string">&#x27;color&#x27;</span>)&#125;</span>`</span>);<br><span class="hljs-comment">// 修改样式属性值</span><br>dom.style(<span class="hljs-built_in">window</span>.test, <span class="hljs-string">&#x27;color&#x27;</span>, <span class="hljs-string">&#x27;blue&#x27;</span>);<br><br><span class="hljs-comment">// dom.class.add()</span><br><span class="hljs-comment">// 给节点添加class属性</span><br>dom.class.add(<span class="hljs-built_in">window</span>.test, <span class="hljs-string">&#x27;red&#x27;</span>);<br><span class="hljs-comment">// 删除class属性</span><br>dom.class.remove(<span class="hljs-built_in">window</span>.test, <span class="hljs-string">&#x27;red&#x27;</span>);<br><span class="hljs-comment">// 判断某个class属性是否存在</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">`含有class=red? <span class="hljs-subst">$&#123;dom.<span class="hljs-keyword">class</span>.contains(<span class="hljs-built_in">window</span>.test, <span class="hljs-string">&#x27;red&#x27;</span>)&#125;</span>`</span>);<br><br><span class="hljs-keyword">const</span> testClick = <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;点击事件&#x27;</span>);<br>&#125;;<br><br><span class="hljs-comment">// dom.on()</span><br><span class="hljs-comment">// 添加点击事件</span><br>dom.on(<span class="hljs-built_in">window</span>.test, <span class="hljs-string">&#x27;click&#x27;</span>, testClick);<br><span class="hljs-comment">// 移出点击事件</span><br>dom.off(<span class="hljs-built_in">window</span>.test, <span class="hljs-string">&#x27;click&#x27;</span>, testClick);<br><br><span class="hljs-comment">// dom.find()</span><br><span class="hljs-keyword">const</span> testDiv = dom.find(<span class="hljs-string">&#x27;#test2&#x27;</span>)[<span class="hljs-number">0</span>];<br><span class="hljs-built_in">console</span>.log(testDiv);<br><span class="hljs-built_in">console</span>.log(dom.find(<span class="hljs-string">&#x27;.red&#x27;</span>,testDiv)[<span class="hljs-number">0</span>]);<br><br><span class="hljs-comment">// dom.parent()</span><br><span class="hljs-built_in">console</span>.log(dom.parent(<span class="hljs-built_in">window</span>.test));<br><br><span class="hljs-comment">// dom.siblings()</span><br><span class="hljs-keyword">const</span> sibling2 =dom.find(<span class="hljs-string">&#x27;#siblings2&#x27;</span>)[<span class="hljs-number">0</span>];<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;兄弟节点:&#x27;</span>);<br><span class="hljs-built_in">console</span>.log(dom.siblings(sibling2));<br><br><span class="hljs-comment">// dom.next()</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;前一个兄弟节点:&#x27;</span>);<br><span class="hljs-built_in">console</span>.log(dom.next(sibling2));<br><br><span class="hljs-comment">// dom.previous()</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;后一个兄弟节点:&#x27;</span>);<br><span class="hljs-built_in">console</span>.log(dom.previous(sibling2));<br><br><span class="hljs-comment">// dom.each()</span><br><span class="hljs-comment">// 设置子元素属性</span><br><span class="hljs-keyword">const</span> t = dom.find(<span class="hljs-string">&quot;#testTravel&quot;</span>)[<span class="hljs-number">0</span>];<br>dom.each(dom.children(t),<span class="hljs-function">(<span class="hljs-params">n</span>)=&gt;</span> dom.style(n,<span class="hljs-string">&#x27;color&#x27;</span>,<span class="hljs-string">&#x27;red&#x27;</span>));<br><br><span class="hljs-comment">// dom.index()</span><br><span class="hljs-comment">// 找到节点在平级节点中的索引</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">`siblings的索引：<span class="hljs-subst">$&#123;dom.index(sibling2)&#125;</span>`</span>);<br></code></pre></div></td></tr></table></figure><h2 id="jQuery基本用法"><a href="#jQuery基本用法" class="headerlink" title="jQuery基本用法"></a>jQuery基本用法</h2><p><strong>jQuery</strong>是一套跨浏览器的JavaScript函数库，它可以简化HTML与JavaScript之间的操作。其语法设计模式使得许多操作变得容易，如操作文档对象（document）、选择文档对象模型（DOM）元素、创建动画效果、处理事件、以及开发Ajax程序等等。</p><p>jQuery的核心特性可以总结为：具有独特的链式语法和短小清晰的多功能接口；具有高效灵活的css选择器，并且可对CSS选择器进行扩展；拥有便捷的插件扩展机制和丰富的插件；兼容各种主流浏览器（如IE 6.0+、FF 1.5+、Safari 2.0+、Opera 9.0+等）。</p><p>截至2021年2月，全球前1万名访问最高的网站中，有79.76%的网站使用了jQuery<a href="https://trends.builtwith.com/javascript/jQuery">[1]</a>，仍是目前最受欢迎的JavaScript函数库。</p><p><strong><a href="https://api.jquery.com/">jQuery官方文档</a></strong></p><h3 id="引入jQuery"><a href="#引入jQuery" class="headerlink" title="引入jQuery"></a>引入jQuery</h3><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 注意：要把JQuery库的引用放到第一个&lt;script&gt;引用前面，这样顺序执行后面的js文件才能识别$符号 --&gt;</span><br><br><span class="hljs-comment">&lt;!-- 1.yran add jquery后引入 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;jquery.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 2.https://jquery.com/download/</span><br><span class="hljs-comment">或 https://www.bootcdn.cn/jquery/ --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.bootcdn.net/ajax/libs/jquery/3.6.0/jquery.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h3 id="页面加载即执行jQuery"><a href="#页面加载即执行jQuery" class="headerlink" title="页面加载即执行jQuery"></a>页面加载即执行jQuery</h3><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// jQuery可以用$代替</span><br><span class="hljs-comment">/* 写法一：DOM树结构完整即执行 */</span><br>$(<span class="hljs-built_in">document</span>).ready(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>     <span class="hljs-comment">//  操作代码</span><br>&#125;);<br><br><span class="hljs-comment">/* 简写 */</span><br>$(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-comment">// 操作代码</span><br>&#125;);<br><br><span class="hljs-comment">/* 写法二：等整个窗口加载完毕（含图片）才执行 */</span><br><span class="hljs-built_in">window</span>.onload = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-comment">//操作代码</span><br>&#125;;<br></code></pre></div></td></tr></table></figure><p>写法一的简写形式较为多用。</p><h2 id="选择网页元素"><a href="#选择网页元素" class="headerlink" title="选择网页元素"></a>选择网页元素</h2><p>jQuery基本思想是：选择某个元素，然后对其进行操作。</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 选择表达式，类似JavaScript选择器</span><br>$(<span class="hljs-built_in">document</span>);<br>$(<span class="hljs-string">&#x27;#myId&#x27;</span>);<br>$(<span class="hljs-string">&#x27;div.myClass&#x27;</span>);<br>$(<span class="hljs-string">&#x27;input[name=first]&#x27;</span>);<br><br><span class="hljs-comment">//特有的选择表达式</span><br>$(<span class="hljs-string">&#x27;a:first&#x27;</span>);<br>$(<span class="hljs-string">&#x27;tr:odd&#x27;</span>);<span class="hljs-comment">//选择表格的奇数行</span><br>$(<span class="hljs-string">&#x27;#myForm :input&#x27;</span>);<br>$(<span class="hljs-string">&#x27;div:visible&#x27;</span>);<span class="hljs-comment">//选择可见的元素</span><br>$(<span class="hljs-string">&#x27;div:gt(2)&#x27;</span>);<span class="hljs-comment">//选择索引大于2的所有div元素</span><br>$(<span class="hljs-string">&#x27;div:animated&#x27;</span>);<span class="hljs-comment">//选择当前出于动画状态的div元素</span><br></code></pre></div></td></tr></table></figure><h2 id="改变数据集"><a href="#改变数据集" class="headerlink" title="改变数据集"></a>改变数据集</h2><p>jQuery提供了各种过滤器对数据进行筛选，得到较为精确的选择结果。</p><h3 id="筛选选择结果"><a href="#筛选选择结果" class="headerlink" title="筛选选择结果"></a>筛选选择结果</h3><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">$(<span class="hljs-string">&#x27;div&#x27;</span>).has(<span class="hljs-string">&#x27;p&#x27;</span>);<span class="hljs-comment">//选择包含p元素的div元素</span><br>$(<span class="hljs-string">&#x27;div&#x27;</span>).not(<span class="hljs-string">&#x27;.myClass&#x27;</span>);<span class="hljs-comment">//选择class不等于myClass的div元素</span><br>$(<span class="hljs-string">&#x27;div&#x27;</span>).filter(<span class="hljs-string">&#x27;.myClass&#x27;</span>);<br>$(<span class="hljs-string">&#x27;div&#x27;</span>).first();<br>$(<span class="hljs-string">&#x27;div&#x27;</span>).eq(<span class="hljs-number">5</span>);<span class="hljs-comment">//选择索引等于5的元素（第六个元素）</span><br></code></pre></div></td></tr></table></figure><h3 id="通过遍历DOM树进行筛选"><a href="#通过遍历DOM树进行筛选" class="headerlink" title="通过遍历DOM树进行筛选"></a><a href="https://api.jquery.com/category/traversing/tree-traversal/">通过遍历DOM树进行筛选</a></h3><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">$(<span class="hljs-string">&#x27;div&#x27;</span>).next(<span class="hljs-string">&#x27;p&#x27;</span>);<span class="hljs-comment">//同级下一个元素</span><br>$(<span class="hljs-string">&#x27;div&#x27;</span>).parent();<br>$(<span class="hljs-string">&#x27;div&#x27;</span>).children();<br>$(<span class="hljs-string">&#x27;div&#x27;</span>).find();<span class="hljs-comment">//选择后代元素</span><br>$(<span class="hljs-string">&#x27;div&#x27;</span>).siblings();<br>$(<span class="hljs-string">&#x27;div&#x27;</span>).closest(<span class="hljs-string">&#x27;form&#x27;</span>);<span class="hljs-comment">//选择最近元素</span><br></code></pre></div></td></tr></table></figure><h2 id="链式操作"><a href="#链式操作" class="headerlink" title="链式操作"></a>链式操作</h2><p>jQuery允许将各种操作连在一起，以链式语法形式书写，有效简化代码。</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">//$(&#x27;.test&#x27;).find(&#x27;.child&#x27;).addClass(&#x27;red&#x27;).addClass(&#x27;blue&#x27;).addClass(&#x27;green&#x27;).end().html(&#x27;修改test&#x27;);</span><br><br><span class="hljs-comment">//分解写法，便于读代码</span><br>$(<span class="hljs-string">&#x27;.test&#x27;</span>)<br>     .find(<span class="hljs-string">&#x27;.child&#x27;</span>)<br>     .addClass(<span class="hljs-string">&#x27;red&#x27;</span>)<br>     .addClass(<span class="hljs-string">&#x27;blue&#x27;</span>)<br>     .addClass(<span class="hljs-string">&#x27;green&#x27;</span>)<br>     .end()<span class="hljs-comment">// end()回退上一次选择的节点，然后进行后续操作</span><br>     .html(<span class="hljs-string">&#x27;修改test&#x27;</span>);<br></code></pre></div></td></tr></table></figure><p>jQuery提供<code>end()</code>方法使当前选择器回退到上一次选择的节点，然后对其进行操作。上面的<code>html()</code>方法最终作用在<code>.test</code>元素上。<code>end()</code>方法使得jQuery链式操作不会因为选择器的来回切换而断开，因此是<strong>“真”链式操作</strong>。</p><h2 id="读写操作"><a href="#读写操作" class="headerlink" title="读写操作"></a>读写操作</h2><p>jQuery可以使用同一个方法来完成<code>get</code>和<code>set</code>操作：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">$(<span class="hljs-string">&#x27;header&#x27;</span>).html();<span class="hljs-comment">//读取header的html内容</span><br>$(<span class="hljs-string">&#x27;header&#x27;</span>).html(<span class="hljs-string">&#x27;andy8421&#x27;</span>);<span class="hljs-comment">//设置header值为andy8421</span><br></code></pre></div></td></tr></table></figure><p>常见读写操作函数:</p><p>​    <a href="http://api.jquery.com/html/">html()</a> 取出或设置html内容</p><p>　<a href="http://api.jquery.com/text/">text()</a> 取出或设置text内容，读取时只有<strong>文本内容</strong>（不含html标签）</p><p>　<a href="http://api.jquery.com/attr/">attr()</a> </p><p>　<a href="http://api.jquery.com/width/">width()</a> </p><p>　<a href="http://api.jquery.com/height/">height()</a> </p><p>　<a href="http://api.jquery.com/val/">val()</a> 取出或设置某个<strong>表单元素</strong>的值</p><p>需要注意的是，如果结果集包含多个元素，那么赋值的时候，将对其中所有的元素赋值；取值的时候，则是<strong>只取出第一个元素的值</strong>。</p><p><strong>text()除外</strong>，它读取<strong>所有元素</strong>的text内容。</p><h3 id="html-、text-和val-的区别"><a href="#html-、text-和val-的区别" class="headerlink" title="html()、text()和val()的区别"></a>html()、text()和val()的区别</h3><ul><li><p><code>html()</code>读取<strong>已被渲染的内容</strong>，未被渲染的标签不会读取</p></li><li><p><code>text()</code>只读取<strong>文本内容</strong>，但是读取的是<strong>所有元素</strong>的文本内容</p></li><li><p><code>var()</code>操作对象是<strong>表单元素</strong>，主要用于读写表单元素的value</p></li></ul><p>举例：</p><p>index.html</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;div1&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">strong</span>&gt;</span>HelloWorld<span class="hljs-tag">&lt;/<span class="hljs-name">strong</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;div2&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">em</span>&gt;</span>/FrontEnd<span class="hljs-tag">&lt;/<span class="hljs-name">em</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;input1&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;val读取内容&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br><br>    html()是：<br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;html&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>    text()是：<br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;text&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>    val()是：<br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;val&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br><br>    input的value设为html：<br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;htmlVal&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br>    input的value设为text：<br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;textVal&quot;</span> /&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.bootcdn.net/ajax/libs/jquery/3.6.0/jquery.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;main.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>main.js</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">$(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-comment">/* 拿到文本值 */</span><br>    <span class="hljs-keyword">let</span> strHtml = $(<span class="hljs-string">&#x27;div&#x27;</span>).html();<br>    <span class="hljs-keyword">let</span> strText = $(<span class="hljs-string">&#x27;div&#x27;</span>).text();<br>    <span class="hljs-keyword">let</span> strVal = $(<span class="hljs-string">&#x27;#input1&#x27;</span>).val();<br><br>    <span class="hljs-comment">/* 设置文本值 */</span><br>    $(<span class="hljs-string">&quot;#html&quot;</span>).html(strHtml);<br>    $(<span class="hljs-string">&quot;#text&quot;</span>).text(strText);<br><br><br>    $(<span class="hljs-string">&quot;#val&quot;</span>).val(strVal);<br>    <span class="hljs-built_in">console</span>.log(strVal);<br>    <span class="hljs-built_in">console</span>.log($(<span class="hljs-string">&#x27;#val&#x27;</span>).val());<br><br>    <span class="hljs-comment">/* input的value设置为html */</span><br>    <span class="hljs-comment">// $(&quot;#htmlVal&quot;).val(strHtml);</span><br>    <span class="hljs-built_in">console</span>.log($(<span class="hljs-string">&quot;#htmlVal&quot;</span>).val(strHtml).val());<br>    <br>    <span class="hljs-comment">/* input的value设置为text */</span><br>    <span class="hljs-built_in">console</span>.log($(<span class="hljs-string">&quot;#textVal&quot;</span>).val(strText).val());<br>&#125;);<br></code></pre></div></td></tr></table></figure><p>输出结果：</p><p><img src="/2020/01/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jQuery%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/1618739381161.png" alt="1618739381161"></p><h2 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h2><h3 id="外部插入"><a href="#外部插入" class="headerlink" title="外部插入"></a><a href="https://api.jquery.com/category/manipulation/dom-insertion-outside/">外部插入</a></h3><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">$(<span class="hljs-string">&#x27;aside&#x27;</span>).insertAfter($(<span class="hljs-string">&#x27;article&#x27;</span>));<br>$(<span class="hljs-string">&#x27;article&#x27;</span>).after($(<span class="hljs-string">&#x27;aside&#x27;</span>));<br><br>$(<span class="hljs-string">&#x27;h2&#x27;</span>).insertBefore($(<span class="hljs-string">&#x27;section&#x27;</span>));<br>$(<span class="hljs-string">&#x27;section&#x27;</span>).before($(<span class="hljs-string">&#x27;h2&#x27;</span>));<br></code></pre></div></td></tr></table></figure><h3 id="内部插入"><a href="#内部插入" class="headerlink" title="内部插入"></a><a href="https://api.jquery.com/category/manipulation/dom-insertion-inside/">内部插入</a></h3><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">$(<span class="hljs-string">&#x27;footer&#x27;</span>).appendTo(<span class="hljs-built_in">document</span>.body);<br>(<span class="hljs-built_in">document</span>.body).append($(<span class="hljs-string">&#x27;footer&#x27;</span>));<span class="hljs-comment">//可用于创建元素</span><br><br>$(<span class="hljs-string">&#x27;header&#x27;</span>).prependTo(<span class="hljs-built_in">document</span>.body);<br>(<span class="hljs-built_in">document</span>.body).prepend(<span class="hljs-string">&#x27;header&#x27;</span>);<br></code></pre></div></td></tr></table></figure><p>以上内部插入和外部操作中，成对的两个代码操作效果相同。jQuery之所以这样设计是为了便于链式操作，可以灵活选择。</p><h2 id="元素的复制、删除"><a href="#元素的复制、删除" class="headerlink" title="元素的复制、删除"></a>元素的复制、删除</h2><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">$(<span class="hljs-string">&#x27;div&#x27;</span>).clone();<br><br>$(<span class="hljs-string">&#x27;div&#x27;</span>).remove();<span class="hljs-comment">//真删除</span><br>$(<span class="hljs-string">&#x27;div&#x27;</span>).detach();<span class="hljs-comment">//假删除，保留被删除元素的事件</span><br><br>$(<span class="hljs-string">&#x27;header&#x27;</span>).empty;<span class="hljs-comment">//清空header元素内容，而不删除header元素</span><br></code></pre></div></td></tr></table></figure><h2 id="用jQuery的设计思想封装DOM库"><a href="#用jQuery的设计思想封装DOM库" class="headerlink" title="用jQuery的设计思想封装DOM库"></a>用jQuery的设计思想封装DOM库</h2><p>为进一步简化手写DOM操作，我使用jQuery设计思想，即封装了DOM库。</p><p><a href="https://github.com/yichang8421/jQueryDOM/blob/master/src/jquery.js">源码连接</a></p><h3 id="获取网页元素"><a href="#获取网页元素" class="headerlink" title="获取网页元素"></a>获取网页元素</h3><p>使用jQuery的第一步，就是要得到你选中的元素，放在jQuery()（或者$()）里面。</p><p><strong>实现方法:</strong> 使用重载设计模式获取对应的元素，利用闭包，在调用方法时使用到<code>elements</code></p><h3 id="链式操作-1"><a href="#链式操作-1" class="headerlink" title="链式操作"></a>链式操作</h3><p><strong>链式操作</strong>: 选中网页元素以后，可以对它进行一系列操作，并且所有操作可以连接在一起，以链条的形式写出来.</p><p><strong>实现思想：</strong> 于每一步的jQuery操作，返回的都是一个新的jQuery对象。</p><h3 id="方法放在原型上"><a href="#方法放在原型上" class="headerlink" title="方法放在原型上"></a>方法放在原型上</h3><p><strong>优点：</strong></p><ul><li>把方法都移到jQuery原型身上，这样每次创建一个jQuery对象时，就不会再去开一块内存存放方法了。</li><li>所有创建的jQuery对象中的方法都放在原型上，这样省内存。</li></ul>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>Front end</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>排序算法——JavaScript实现</title>
    <link href="/2020/01/01/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <url>/2020/01/01/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><h2 id="选择排序O-n-2"><a href="#选择排序O-n-2" class="headerlink" title="选择排序O(n^2)"></a>选择排序O(n^2)</h2><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">//返回数列的最小值</span><br><span class="hljs-comment">//递归方法</span><br><span class="hljs-keyword">let</span> min = <span class="hljs-function">(<span class="hljs-params">number</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (number.length &gt; <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-keyword">return</span> min([number[<span class="hljs-number">0</span>], min(number.slice(<span class="hljs-number">1</span>))]);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.min.apply(<span class="hljs-literal">null</span>, number);<br>    &#125;<br>&#125;;<br><span class="hljs-comment">//循环方法</span><br><span class="hljs-comment">// let minCycle = (number) =&gt; &#123;</span><br><span class="hljs-comment">//     return number[minIndexCycle(number)];</span><br><span class="hljs-comment">// &#125;;</span><br><br><span class="hljs-comment">//选择排序</span><br><span class="hljs-comment">//递归方法</span><br><span class="hljs-keyword">let</span> minIndex = <span class="hljs-function">(<span class="hljs-params">number</span>) =&gt;</span> number.indexOf(min(number));<br><br><span class="hljs-comment">//递归方法</span><br><span class="hljs-keyword">let</span> sort = <span class="hljs-function">(<span class="hljs-params">number</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (number.length &gt; <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-keyword">let</span> index = minIndex(number);<br>        <span class="hljs-keyword">let</span> min = number[index];<br>        number.splice(index, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> [min].concat(sort(number));<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> number[<span class="hljs-number">0</span>] &lt; number[<span class="hljs-number">1</span>] ? number : number.reverse();<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">//选择排序</span><br><span class="hljs-comment">//循环方法</span><br><span class="hljs-keyword">let</span> minIndexCycle = <span class="hljs-function">(<span class="hljs-params">number</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">let</span> minIndex = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; number.length; i++) &#123;<br>        <span class="hljs-keyword">if</span> (number[i] &lt; number[minIndex])<br>            minIndex = i;<br>    &#125;<br>    <span class="hljs-keyword">return</span> minIndex;<br>&#125;;<br><br><span class="hljs-keyword">let</span> swap = <span class="hljs-function">(<span class="hljs-params">number, a, b</span>) =&gt;</span> &#123;<br>    number[a] = number[a] ^ number[b];<br>    number[b] = number[a] ^ number[b];<br>    number[a] = number[a] ^ number[b];<br>    <span class="hljs-keyword">return</span> number;<br>&#125;<br><br><span class="hljs-comment">//循环方法</span><br><span class="hljs-keyword">let</span> sortCycle = <span class="hljs-function">(<span class="hljs-params">number</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; number.length - <span class="hljs-number">1</span>; i++) &#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;------&quot;</span>);<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`i:<span class="hljs-subst">$&#123;i&#125;</span>`</span>);<br>        <span class="hljs-comment">// let tempNumber = number.slice(i);</span><br>        <span class="hljs-comment">// let minIndex = minIndexCycle(tempNumber) + i;</span><br>        <span class="hljs-comment">// 第i项及之前数列都是排好序的，只用考虑第i项之后的数列排序</span><br>        <span class="hljs-comment">// minIndexCycle(tempNumber)得到的是剔除前i项排好序数列之后的新数组中，最小数在该数组中的下标</span><br>        <span class="hljs-comment">// 由于新数组下标是重新从零开始的，要找到此最小数在number中对应的下标。应该加i。</span><br>        <span class="hljs-keyword">let</span> minIndex = minIndexCycle(number.slice(i)) + i;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`minIndex:<span class="hljs-subst">$&#123;minIndex&#125;</span>`</span>);<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`min:<span class="hljs-subst">$&#123;number[minIndex]&#125;</span>`</span>);<br>        <span class="hljs-comment">//找到number中最小数字的下标，然后将其与当前下标的数字交换位置</span><br>        <span class="hljs-keyword">if</span> (minIndex != i)<br>            swap(number, minIndex, i);<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`number:[<span class="hljs-subst">$&#123;number&#125;</span>]`</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> number;<br>&#125;;<br><br></code></pre></div></td></tr></table></figure><h2 id="快速排序O-nlog2n"><a href="#快速排序O-nlog2n" class="headerlink" title="快速排序O(nlog2n)"></a>快速排序O(nlog2n)</h2><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">//快速排序</span><br><span class="hljs-comment">//递归方法</span><br><span class="hljs-keyword">let</span> quickSort = <span class="hljs-function"><span class="hljs-params">arr</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (arr.length &lt;= <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> arr;<br>    <span class="hljs-comment">// 基准数字选择arr中间位置最大整数数(向下取整)</span><br>    <span class="hljs-keyword">let</span> pivotIndex = <span class="hljs-built_in">Math</span>.floor(arr.length / <span class="hljs-number">2</span>);<br>    <span class="hljs-comment">// 取出基准数字</span><br>    <span class="hljs-keyword">let</span> pivot = arr.splice(pivotIndex, <span class="hljs-number">1</span>)[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">let</span> left = [];<br>    <span class="hljs-keyword">let</span> right = [];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>        <span class="hljs-comment">// 如果剩余数小于基准数，则将其放入左边数组；反之放入右边数组</span><br>        <span class="hljs-keyword">if</span> (arr[i] &lt; pivot) &#123;<br>            left.push(arr[i]);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            right.push(arr[i]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> quickSort(left).concat([pivot], quickSort(right));<br>&#125;;<br><br></code></pre></div></td></tr></table></figure><h2 id="归并排序O-nlog2n"><a href="#归并排序O-nlog2n" class="headerlink" title="归并排序O(nlog2n)"></a>归并排序O(nlog2n)</h2><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 归并排序</span><br><span class="hljs-comment">// 先分解，再合并</span><br><span class="hljs-comment">// 递归方法</span><br><br><span class="hljs-comment">// 分解</span><br><span class="hljs-keyword">let</span> mergeSort = <span class="hljs-function"><span class="hljs-params">arr</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (arr.length === <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span> arr;<br>    &#125;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`----`</span>);<br>    <span class="hljs-comment">/* slice() 方法返回一个新的数组对象，这一对象是一个由 begin 和 end 决定的原数组的浅拷贝（包括 begin，不包括end）。原始数组不会被改变。*/</span><br>    <span class="hljs-keyword">let</span> left = arr.slice(<span class="hljs-number">0</span>, <span class="hljs-built_in">Math</span>.floor(arr.length / <span class="hljs-number">2</span>));<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`left:<span class="hljs-subst">$&#123;left&#125;</span>`</span>);<br>    <span class="hljs-keyword">let</span> right = arr.slice(<span class="hljs-built_in">Math</span>.floor(arr.length / <span class="hljs-number">2</span>),);<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`right:<span class="hljs-subst">$&#123;right&#125;</span>`</span>);<br>    <span class="hljs-keyword">return</span> merge(mergeSort(left), mergeSort(right));<br>&#125;;<br><br><span class="hljs-comment">// 合并</span><br><span class="hljs-keyword">let</span> merge = <span class="hljs-function">(<span class="hljs-params">left, right</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (!left.length)<br>        <span class="hljs-comment">// 当left数组已经全部拿空了，那么就直接将right数组连接到新数组</span><br>        <span class="hljs-keyword">return</span> right;<br>    <span class="hljs-keyword">if</span> (!right.length)<br>        <span class="hljs-keyword">return</span> left;<br><br>    <span class="hljs-keyword">if</span> (left[<span class="hljs-number">0</span>] &gt; right[<span class="hljs-number">0</span>]) &#123;<br>        <span class="hljs-comment">// right[0]是两个数组中的最小数，先放在左边。然后left和right剩余部分按相同方法进行合并。</span><br>        <span class="hljs-keyword">return</span> [right[<span class="hljs-number">0</span>]].concat(merge(left, right.slice(<span class="hljs-number">1</span>,)))<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> [left[<span class="hljs-number">0</span>]].concat(merge(left.slice(<span class="hljs-number">1</span>,), right));<br>    &#125;<br>    <span class="hljs-comment">// return left[0] &gt; right[0] ? [right[0]].concat(merge(left, right.slice(1))) : [left[0]].concat(merge(left.slice(1), right));</span><br>&#125;;<br></code></pre></div></td></tr></table></figure><h2 id="计数排序O-n-max"><a href="#计数排序O-n-max" class="headerlink" title="计数排序O(n+max)"></a>计数排序O(n+max)</h2><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 计数排序</span><br><span class="hljs-keyword">let</span> countSort = <span class="hljs-function"><span class="hljs-params">arr</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">let</span> count = &#123;&#125;,<br>        <span class="hljs-comment">// count用一个哈希表定义，便于计数</span><br>        max = <span class="hljs-number">0</span>,<br>        result = [];<br><br>    <span class="hljs-comment">// 遍历数组，对所有数字计数。获得哈希表count</span><br>    <span class="hljs-comment">// 这样做的目的是便于下一步循环，判断数字是否应该压入数组</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>; index &lt; arr.length; index++) &#123;<br>        <span class="hljs-keyword">if</span> (!(arr[index] <span class="hljs-keyword">in</span> count)) &#123;<br>            count[arr[index]] = <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            count[arr[index]] += <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (arr[index] &gt; max)<br>            max = arr[index];<br>    &#125;<br><br>    <span class="hljs-comment">// 遍历哈希表，从小到大依次将所有数字压入新数组</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> value = <span class="hljs-number">0</span>; value &lt;= max; value++) &#123;<br>        <span class="hljs-keyword">if</span> (value <span class="hljs-keyword">in</span> count) &#123;<br>    <span class="hljs-comment">// 将所有数字都压入新数组。count记录了几次，value就要压入几次</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; count[value]; i++) &#123;<br>                result.push(value);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><h2 id="各种排序方法的比较"><a href="#各种排序方法的比较" class="headerlink" title="各种排序方法的比较"></a>各种排序方法的比较</h2><p><img src="/2020/01/01/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.jpeg"></p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>Front end</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>实践篇-—JS对象基本用法</title>
    <link href="/2019/11/29/JS%E5%AF%B9%E8%B1%A1%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/"/>
    <url>/2019/11/29/JS%E5%AF%B9%E8%B1%A1%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="JS对象基本用法"><a href="#JS对象基本用法" class="headerlink" title="JS对象基本用法"></a>JS对象基本用法</h1><h2 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h2><ol><li>声明对象的两种语法</li><li>如何删除对象的属性</li><li>如何查看对象的属性</li><li>如何修改或增加对象的属性</li><li>‘name’ in obj和obj.hasOwnProperty(‘name’) 的区别</li></ol><h2 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL;DR"></a>TL;DR</h2><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 删</span><br><span class="hljs-keyword">delete</span> obj[<span class="hljs-string">&#x27;name&#x27;</span>]<br><span class="hljs-string">&#x27;name&#x27;</span> <span class="hljs-keyword">in</span> obj <span class="hljs-comment">//查是否含有name属性</span><br>obj.hasOwnProperty(<span class="hljs-string">&#x27;name&#x27;</span>)  <span class="hljs-comment">//查name属性是否时自由属性</span><br><br><span class="hljs-comment">// 查</span><br><span class="hljs-built_in">Object</span>.keys(obj)<br><span class="hljs-built_in">console</span>.dir(obj)<br>obj[<span class="hljs-string">&#x27;name&#x27;</span>]<br>obj.name <span class="hljs-comment">// 记住这里的 name 是字符串</span><br>obj[name]  <span class="hljs-comment">// 记住这里的 name 是变量</span><br><br><span class="hljs-comment">// 改和增</span><br>obj[<span class="hljs-string">&#x27;name&#x27;</span>] = <span class="hljs-string">&#x27;jack&#x27;</span><span class="hljs-comment">//改自身</span><br><span class="hljs-built_in">Object</span>.assign(obj, &#123;<span class="hljs-attr">age</span>:<span class="hljs-number">18</span>, ...&#125;) <span class="hljs-comment">//批量改自身 </span><br><span class="hljs-built_in">Object</span>.prototype[<span class="hljs-string">&#x27;toString&#x27;</span>] = <span class="hljs-string">&#x27;xxx&#x27;</span><span class="hljs-comment">//改共有属性 </span><br><span class="hljs-keyword">let</span> obj = <span class="hljs-built_in">Object</span>.create(common)<span class="hljs-comment">//改原型 </span><br></code></pre></div></td></tr></table></figure><h2 id="对象的声明"><a href="#对象的声明" class="headerlink" title="对象的声明"></a>对象的声明</h2><h3 id="键值对"><a href="#键值对" class="headerlink" title="键值对"></a>键值对</h3><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> obj = &#123;<span class="hljs-string">&#x27;name&#x27;</span>:<span class="hljs-string">&#x27;andy8421&#x27;</span>,<span class="hljs-string">&#x27;age&#x27;</span>:<span class="hljs-number">18</span>&#125;;<br><span class="hljs-keyword">let</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>&#123;<span class="hljs-string">&#x27;name&#x27;</span>:<span class="hljs-string">&#x27;andy8421&#x27;</span>&#125;;<br><br><span class="hljs-comment">//以变量做为属性名</span><br><span class="hljs-keyword">let</span> x = <span class="hljs-string">&#x27;name&#x27;</span>;<br><span class="hljs-keyword">let</span> obj = &#123;[x]:<span class="hljs-string">&#x27;andy8421&#x27;</span>&#125;<span class="hljs-comment">//key值是变量x，x为&#x27;name&#x27;</span><br></code></pre></div></td></tr></table></figure><p>★ <strong>不能使用</strong><code>let obj = &#123;x:&#39;andy8421&#39;&#125;;</code>，这样得到的key值为字符串x，不是变量x。</p><ul><li>键名是任意字符组成的字符串，不是标识符</li><li>引号可以省略。若省略引号，则只能写标识符</li><li>省略引号，键名仍然是字符串</li></ul><h3 id="对象的隐藏属性"><a href="#对象的隐藏属性" class="headerlink" title="对象的隐藏属性"></a>对象的隐藏属性</h3><ol><li><p>JS中每一个对象都有一个隐藏属性（<code>__proto__</code>）</p></li><li><p>这个隐藏属性储存着<strong>共有属性所组成对象</strong>的地址</p></li><li><p>这个<strong>共有属性组成的对象</strong>叫原型</p></li><li><p>隐藏属性存储着原型的地址</p></li></ol><h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h3><ol><li><strong>每个对象</strong>都有原型<ol><li>obj的原型就是一个对象</li><li><code>obj.__proto__</code>存着这个对象的地址</li><li>这个对象（即原型）里有toString/valueOf/constructor等属性（即共有属性）</li></ol></li><li>原型里存着对象的共有属性</li><li>对象的原型也是对象</li><li>所以对象的原型也由原型<ol><li>obj的原型，即<code>obj.__proto__</code>，为所有对象的原型</li><li>这个原型包含所有对象的共有属性，是对象的<strong>根</strong></li><li>这个原型也有原型（对象的根的原型），但是值为null。<code>obj.__proto__.__proto__===null</code>(浏览器查不到这个属性，因为值为null)</li></ol></li></ol><p><img src="/2019/11/29/JS%E5%AF%B9%E8%B1%A1%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/js%E5%8E%9F%E5%9E%8B%E9%93%BE%EF%BC%88%E8%A1%A5%E5%85%85%EF%BC%89.jpg"></p><p>图中，#8421和#1024分别指向的就是Object和Array两个原型，它们分别含有toString()和push()，这两个方法并不是obj和arr自身的属性，而是obj和arr两个对象的原型<code>obj.__proto__</code>和<code>arr.__proto__</code>的属性，称为共有属性。</p><h2 id="对象属性的增删改查操作"><a href="#对象属性的增删改查操作" class="headerlink" title="对象属性的增删改查操作"></a>对象属性的增删改查操作</h2><h3 id="删除对象的属性"><a href="#删除对象的属性" class="headerlink" title="删除对象的属性"></a>删除对象的属性</h3><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> obj = &#123;<span class="hljs-attr">key1</span>:<span class="hljs-string">&#x27;value1&#x27;</span>,<span class="hljs-string">&#x27;key2&#x27;</span>:<span class="hljs-string">`value2`</span>&#125;;<br><br><span class="hljs-keyword">delete</span> obj.key1;<span class="hljs-comment">//正确删除对象的属性方法</span><br></code></pre></div></td></tr></table></figure><p>★ <strong>不能使用</strong><code>obj.key1 = undefined;</code>。它只是将obj的key1值设置为undefined，<strong>并不能删除</strong>obj的key1属性。</p><h3 id="查看对象的属性（读）"><a href="#查看对象的属性（读）" class="headerlink" title="查看对象的属性（读）"></a>查看对象的属性（读）</h3><p><code>in</code>判断对象<strong>是否含有</strong>某个属性（一般用于判断属性是否被删除）：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;xxx&#x27;</span> <span class="hljs-keyword">in</span> obj;<span class="hljs-comment">//return:false表示obj不含有xxx属性。（反之含有）</span><br><br><span class="hljs-string">&#x27;xxx&#x27;</span> <span class="hljs-keyword">in</span> obj &amp;&amp; obj.xxx;<span class="hljs-comment">//return:undefined表示obj含有xxx属性，但是属性值为undefined。</span><br><span class="hljs-comment">//如果return:false则表示同上一句，不赘述。</span><br><span class="hljs-comment">//这证明了为什么删除属性xxx不能使用obj.key1 = undefined;</span><br></code></pre></div></td></tr></table></figure><p>使用<code>in</code>时，前面待判断key值<strong>引号不能省</strong>，否则表示变量xxx。</p><p>证明: 对象的根存在原型，且该原型值为null：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> obj = &#123;&#125;;<br><br><span class="hljs-string">&#x27;__proto__&#x27;</span> <span class="hljs-keyword">in</span> obj.__proto__;<span class="hljs-comment">//return:true;</span><br>obj.__proto__.__proto__===<span class="hljs-literal">null</span>;<span class="hljs-comment">//return:true;</span><br></code></pre></div></td></tr></table></figure><p>查看属性的键值对：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> obj = &#123;<span class="hljs-attr">key1</span>:<span class="hljs-string">&#x27;value1&#x27;</span>,<span class="hljs-string">&#x27;key2&#x27;</span>:<span class="hljs-string">`value2`</span>&#125;;<br><br><span class="hljs-comment">//查看自身属性</span><br><span class="hljs-built_in">Object</span>.values(obj);<span class="hljs-comment">//return:obj的所有属性值</span><br><span class="hljs-built_in">Object</span>.keys(obj);<span class="hljs-comment">//return:obj的所有key值</span><br><span class="hljs-built_in">Object</span>.entries(obj);<span class="hljs-comment">//return:obj的所有由键值对组成的数组</span><br><br><span class="hljs-comment">//查看自身属性和共有属性</span><br><span class="hljs-built_in">console</span>.dir(obj);<br>obj.__proto__;<span class="hljs-comment">//不规范，不推荐</span><br></code></pre></div></td></tr></table></figure><p>判断一个属性是<strong>自身属性</strong>还是共有属性：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">obj.hasOwnProperty(<span class="hljs-string">&#x27;key1&#x27;</span>);<span class="hljs-comment">//true</span><br>obj.hasOwnProperty(<span class="hljs-string">&#x27;toString&#x27;</span>);<span class="hljs-comment">//false</span><br></code></pre></div></td></tr></table></figure><p>★ <strong>不能使用</strong><code>&#39;xxx&#39; in obj;</code>。它只是判断对象<em>是否含有</em>某个属性，不能判断是否为自有属性。</p><p>查看单个属性的key值：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> obj = &#123;<span class="hljs-attr">key1</span>:<span class="hljs-string">&#x27;value1&#x27;</span>,<span class="hljs-string">&#x27;key2&#x27;</span>:<span class="hljs-string">`value2`</span>&#125;;<br><br><span class="hljs-comment">/* 等价写法 */</span><br><span class="hljs-comment">//中括号语法：</span><br>obj[<span class="hljs-string">&#x27;key1&#x27;</span>];<br><span class="hljs-comment">//点语法：</span><br>obj.key1;<br></code></pre></div></td></tr></table></figure><p>★ <strong>错误语法：</strong><code>obj[key1];</code>，这表示变量key1，而不是字符串key1。</p><h3 id="增加或修改对象的属性（写）"><a href="#增加或修改对象的属性（写）" class="headerlink" title="增加或修改对象的属性（写）"></a>增加或修改对象的属性（写）</h3><p>直接赋值：</p><h2 id="‘name’-in-obj和onj-hasOwnProperty-‘mame’-的区别"><a href="#‘name’-in-obj和onj-hasOwnProperty-‘mame’-的区别" class="headerlink" title="‘name’ in obj和onj.hasOwnProperty(‘mame’)的区别"></a>‘name’ in obj和onj.hasOwnProperty(‘mame’)的区别</h2><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> obj = &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;andy8421&#x27;</span>&#125; ;<span class="hljs-comment">// name 是字符串</span><br>obj.name = <span class="hljs-string">&#x27;andy8421&#x27;</span>;<span class="hljs-comment">// name 是字符串</span><br>obj[<span class="hljs-string">&#x27;name&#x27;</span>] = <span class="hljs-string">&#x27;andy8421&#x27;</span>; <br>obj[name] = <span class="hljs-string">&#x27;andy8421&#x27;</span>; <span class="hljs-comment">// 错，此处name为变量</span><br>obj[<span class="hljs-string">&#x27;na&#x27;</span>+<span class="hljs-string">&#x27;me&#x27;</span>] = <span class="hljs-string">&#x27;andy8421&#x27;</span>;<br><br><span class="hljs-keyword">let</span> key = <span class="hljs-string">&#x27;name&#x27;</span>; obj[key] = <span class="hljs-string">&#x27;andy8421&#x27;</span>;<br><span class="hljs-keyword">let</span> key = <span class="hljs-string">&#x27;name&#x27;</span>; obj.key = <span class="hljs-string">&#x27;andy8421&#x27;</span>; <span class="hljs-comment">// 错，这表示给obj增加一个属性key，值为andy8421。</span><br></code></pre></div></td></tr></table></figure><p>批量赋值：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">Object</span>.assign(obj, &#123;<span class="hljs-attr">age</span>: <span class="hljs-number">18</span>, <span class="hljs-attr">gender</span>: <span class="hljs-string">&#x27;man&#x27;</span>&#125;);<br></code></pre></div></td></tr></table></figure><h4 id="修改或增加共有属性"><a href="#修改或增加共有属性" class="headerlink" title="修改或增加共有属性"></a>修改或增加共有属性</h4><ul><li>JS默认设定共有属性为<strong>只读</strong>属性。</li><li>无法通过对象自身修改或增加共有属性（修改最终指作用于对象本身，不影响原型）</li></ul><p>强行修该原型的属性的方法：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">obj.__proto__.toString = <span class="hljs-string">&#x27;xxx&#x27;</span>;<span class="hljs-comment">// 不推荐用 __proto__</span><br><span class="hljs-built_in">Object</span>.prototype.toString = <span class="hljs-string">&#x27;xxx&#x27;</span>;<br></code></pre></div></td></tr></table></figure><p>修改对象原型的方法（<strong>修改原型链</strong>）：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">//不推荐使用__proto__</span><br><span class="hljs-comment">//推荐使用Object.create</span><br><span class="hljs-keyword">let</span> obj = <span class="hljs-built_in">Object</span>.create(common);<span class="hljs-comment">//以common为原型创建对象obj</span><br>obj.key = <span class="hljs-string">&#x27;value&#x27;</span>;<br><br><span class="hljs-comment">//或者</span><br><span class="hljs-keyword">let</span> obj = <span class="hljs-built_in">Object</span>.create(common,&#123;<br>    <span class="hljs-attr">key</span>:&#123;<span class="hljs-attr">value</span>:<span class="hljs-string">&#x27;value&#x27;</span>&#125;<br>    ...<br>&#125;);<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>Front end</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript继承</title>
    <link href="/2019/10/29/JavaScript%E7%BB%A7%E6%89%BF/"/>
    <url>/2019/10/29/JavaScript%E7%BB%A7%E6%89%BF/</url>
    
    <content type="html"><![CDATA[<h1 id="JavaScript继承"><a href="#JavaScript继承" class="headerlink" title="JavaScript继承"></a>JavaScript继承</h1><p>谈OOP怎么可能不提继承呢😄！在<a href>原型链</a>中，已经介绍，OOP语言支持两种继承方式：<code>接口继承</code>和<code>实现继承</code>。接口继承只继承方法签名，而实现继承则继承实际的方法。 在 <code>ECMAScript</code> 中无法实现接口继承。<code>ECMAScript</code> 只支持实现继承，而且其实现继承主要是依靠原型链 来实现的。</p><p>《JavaScript高级程序设计（4th）》中介绍了介绍原型链、构造函数继承、组合继承、原型式继承、寄生式继承、寄生组合式继承等6种方法。</p><p>但是通过细心研读可以发现，书中真正推荐使用继承方法只有两个：组合继承（combination inheritance）或寄生组合式继承，以及<code>class</code>关键字</p><h2 id="（寄生）组合继承"><a href="#（寄生）组合继承" class="headerlink" title="（寄生）组合继承"></a>（寄生）组合继承</h2><p>组合继承（combination inheritance）又称伪经典继承（pseudo classical inheritance），它使用原型链实现对原型属性和方法的继承，而通过构造函数实现对实例属性的继承。</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs JavaScript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Parent</span>(<span class="hljs-params">name1</span>)</span>&#123;<br>  <span class="hljs-built_in">this</span>.name1 = name1;<br>&#125;<br>Parent.prototype.pMethod = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name1);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Child</span>(<span class="hljs-params">name2, name1</span>)</span>&#123;<br>    <span class="hljs-comment">// 调用构造函数</span><br>    <span class="hljs-comment">// inherit instance properties</span><br>    Parent.call(<span class="hljs-built_in">this</span>, name1) ;<br>    <span class="hljs-built_in">this</span>.name2 = name2;<br>&#125;<br><br><span class="hljs-keyword">const</span> empty = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;&#125;<br><span class="hljs-comment">// 调用构造函数</span><br><span class="hljs-comment">// inherit instance properties</span><br>empty.prototype = Parent.prototype;<br><span class="hljs-comment">// inherit methods</span><br>Child.prototype = <span class="hljs-keyword">new</span> empty();<br><span class="hljs-comment">// Child.prototype.__proto__ = Parent.prototype ;</span><br><br><br>Child.prototype.cMethod = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name2);<br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li>共用方法写在 <code>Parent.prototype</code> 中，通过原型链实现继承</li><li>非共用属性（<code>name1</code>）放在构造函数中，让每一个实例都有自己的副本</li><li>组合继承方式调用了两次构造函数，一次是创建子类 <code>Child</code> 的原型 <code>prototype</code> 时，一次是在子类的构造函数中借用构造函数时。这样可能得到一些没用的实例属性，同时复杂的构造函数可能会影像性能。</li></ul><p>为了优化这个过程，就出现了寄生组合继承模式：把<code>new</code>关键字换成 <code>Object.create()</code> 方法即可</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs JavaScript"><span class="hljs-comment">// Child.prototype = new Parent();</span><br>Child.prototype = <span class="hljs-built_in">Object</span>.create(Parent.prototype);<br>Child.prototype.constructor = Child;<br>Child.prototype.childMethod = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;&#125;;<br></code></pre></div></td></tr></table></figure><h2 id="基于-class-关键字继承"><a href="#基于-class-关键字继承" class="headerlink" title="基于 class 关键字继承"></a>基于 class 关键字继承</h2><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs JavaScript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parent</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name1</span>)</span>&#123;<br>        <span class="hljs-built_in">this</span>.name1 = name1;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">pMethod</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name1);<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Parent</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name2, name1</span>)</span>&#123;<br>        <span class="hljs-comment">// inherit instance properties</span><br>        <span class="hljs-built_in">super</span>(name1) <span class="hljs-comment">// 调用parent构造函数</span><br>        <span class="hljs-built_in">this</span>.name2 = name2;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">cMethod</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name2);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>派生类的方法可以通过 <code>super</code> 关键字引用它们的原型。这个关键字只能在派生类中使用，而且仅<br>限于类构造函数、实例方法和静态方法内部。在类构造函数中使用 <code>super</code> 可以调用父类构造函数。 </p><p>不能在调用 <code>super</code> 之前使用<code>this</code>，否则会抛出 <code>ReferenceError</code> </p><h2 id="总结：重要继承模式"><a href="#总结：重要继承模式" class="headerlink" title="总结：重要继承模式"></a>总结：重要继承模式</h2><ul><li>原型链继承 : 得到方法<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Parent</span>(<span class="hljs-params"></span>)</span>&#123;&#125;;<br>Parent.prototype.test = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;&#125;;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Child</span>(<span class="hljs-params"></span>)</span>&#123;&#125;;<br>Child.prototype = <span class="hljs-keyword">new</span> Parent(); <span class="hljs-comment">// 子类型的原型指向父类型实例</span><br>Child.prototype.constructor = Child<br><span class="hljs-keyword">var</span> child = <span class="hljs-keyword">new</span> Child(); <span class="hljs-comment">//有test()</span><br></code></pre></div></td></tr></table></figure></li><li>借用构造函数 : inherit instance properties<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Parent</span>(<span class="hljs-params">xxx</span>)</span>&#123;<span class="hljs-built_in">this</span>.xxx = xxx&#125;<br>Parent.prototype.test = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;&#125;;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Child</span>(<span class="hljs-params">xxx,yyy</span>)</span>&#123;<br>    Parent.call(<span class="hljs-built_in">this</span>, xxx);<span class="hljs-comment">//借用构造函数   this.Parent(xxx)</span><br>&#125;<br><span class="hljs-keyword">var</span> child = <span class="hljs-keyword">new</span> Child(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>);  <span class="hljs-comment">//child.xxx为&#x27;a&#x27;, 但child没有test()</span><br></code></pre></div></td></tr></table></figure></li><li>组合<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Parent</span>(<span class="hljs-params">xxx</span>)</span>&#123;<span class="hljs-built_in">this</span>.xxx = xxx&#125;<br>Parent.prototype.test = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;&#125;;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Child</span>(<span class="hljs-params">xxx,yyy</span>)</span>&#123;<br>    Parent.call(<span class="hljs-built_in">this</span>, xxx);<span class="hljs-comment">//借用构造函数   this.Parent(xxx)</span><br>&#125;<br>Child.prototype = <span class="hljs-keyword">new</span> Parent(); <span class="hljs-comment">//得到test()</span><br><span class="hljs-keyword">var</span> child = <span class="hljs-keyword">new</span> Child(); <span class="hljs-comment">//child.xxx为&#x27;a&#x27;, 也有test()</span><br></code></pre></div></td></tr></table></figure></li></ul><ul><li><p>原型式继承—— <a href="%5BObject.create(">Object.create()</a> - JavaScript | MDN (mozilla.org)](<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create</a>)) 的内部逻辑 </p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">object</span>(<span class="hljs-params">o</span>) </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">F</span>(<span class="hljs-params"></span>) </span>&#123;&#125;<br>    F.prototype = o;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> F();<br>&#125;<br></code></pre></div></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>Front end</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavsScript属性类型</title>
    <link href="/2019/10/20/JavaScript%E5%B1%9E%E6%80%A7%E7%B1%BB%E5%9E%8B/"/>
    <url>/2019/10/20/JavaScript%E5%B1%9E%E6%80%A7%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="JavsScript属性类型"><a href="#JavsScript属性类型" class="headerlink" title="JavsScript属性类型"></a>JavsScript属性类型</h1><h2 id="数据属性"><a href="#数据属性" class="headerlink" title="数据属性"></a>数据属性</h2><p>数据属性包含一个数值的位置，这个位置可以读取和写入数值。它有4个描述其行为的特性：<br>    <code>[[Configurable]]</code>：表示能否通过 delete 删除属性从而重新定义属性，默认值为true<br>    <code>[[Enumerable]]</code>：表示能否通过 for-in 循环返回属性。默认值为true<br>    <code>[[Writable]]</code>：表示能否修改属性的值。默认值为true<br>    <code>[[Value]]</code>：包含这个属性的数据值。默认值为undefined<br>（具体细节详见《JavaScript高级程序设计（第4版）》第139页）<br>在ES5中，要修改属性默认的特性必须使用<code>Objext.defineProperty(obj, prop, descriptor)</code>方法。其中描述符对象（descriptor）的属相必须是：configurable，enumerable，writable和value。</p><h2 id="访问器属性"><a href="#访问器属性" class="headerlink" title="访问器属性"></a>访问器属性</h2><p>访问器属性不包含数据值，而是包含一个getter属性和一个setter属性(但这两个属性并不是非要同时设定)。在读取访问器属性时，会调用 getter 函数，这个函数负责返回有效的值；在写入访问器属性时，会调用setter 函数并传入新值，这个函数负责决定如何处理数据。访问器属性有如下 4 个特性。<br>    <code>[[Configurable]]</code>：表示能否通过 delete 删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为数据属性。对于直接在对象上定义的属性，这个特性的默认值为true。<br>    <code>[[Enumerable]]</code>：表示能否通过 for-in 循环返回属性。对于直接在对象上定义的属性，这个特性的默认值为 true。<br>    <code>[[Get]]</code>：在读取属性时调用的函数。默认值为 undefined。<br>    <code>[[Set]]</code>：在写入属性时调用的函数。默认值为 undefined。<br>访问器属性不能直接定义，必须使用Object.defineProperty()来定义。</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> book=&#123;<br>    <span class="hljs-attr">_year</span>:<span class="hljs-number">2004</span>,<span class="hljs-comment">//_year是通过对象方法访问的属性。</span><br>     <span class="hljs-attr">edition</span>:<span class="hljs-number">1</span><br>&#125;;<br><span class="hljs-built_in">Object</span>.defineProperty(book,<span class="hljs-string">&quot;year&quot;</span>,&#123;<span class="hljs-comment">//year是一个访问器属性，包含一个getter函数和setter函数。</span><br>    <span class="hljs-attr">get</span>:  <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<span class="hljs-comment">//读取属性时调用的函数，设置get表示允许读，此处表示以this._year的值返回this.year的值</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>._year;<br>    &#125;,<br>    <span class="hljs-attr">set</span>:  <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">newValue</span>)</span>&#123;<span class="hljs-comment">//在写入属性时调用的函数，设置set表示允许写入，即允许对原对象属性做相关操作</span><br>        <span class="hljs-keyword">if</span>(newValue &gt; <span class="hljs-number">2004</span>)&#123;<br>            <span class="hljs-built_in">this</span>._year = newValue;<br>            <span class="hljs-built_in">this</span>.edition += newValue - <span class="hljs-number">2004</span>;<br>        &#125;<br>    &#125;<br>&#125;);<br>book.year=<span class="hljs-number">2005</span>;<span class="hljs-comment">//把year属性修改为2005会导致_year变成2005，而edition变成2</span><br><span class="hljs-built_in">console</span>.log(book._year + <span class="hljs-string">&#x27;年出第&#x27;</span> + book.edition + <span class="hljs-string">&#x27;版&#x27;</span>);<span class="hljs-comment">//2005年出第2版</span><br></code></pre></div></td></tr></table></figure><p>以上代码创建了一个 book 对象，并给它定义两个默认的属性： _year和edition。_year前面的下划线是一种常用的记号，用于表示只能通过对象方法访问的属性。还定义了一个访问器属性year，包含一个getter函数和一个setter函数。getter函数返回_year的值，setter函数通过计算来确定正确的版本。因此，把 year属性修改为 2005会导致_year变成 2005，而 edition变为 2。这是使用访问器属性的常见方式，即设置一个属性的值会导致其他属性发生变化。具体测试过程见自己总结的CH6Attributies.js</p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>Front end</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript对象</title>
    <link href="/2019/07/29/JavaScript%E5%AF%B9%E8%B1%A1/"/>
    <url>/2019/07/29/JavaScript%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="JavaScript对象"><a href="#JavaScript对象" class="headerlink" title="JavaScript对象"></a>JavaScript对象</h1><p>OOP似乎是编程领域绝对避不开的话题😄。我个人的理解面向对象就是对问题的抽象，将问题抽象成一个个小的模块分而治之，模块之间的关系尽量单一清晰，这样代码在扩展和维护的时候所花费的精力最小，也就是所谓的高内聚，低耦合。之所以它并不容易掌握，就是这个抽象能力是需要通过各种复杂的问题不断训练的。很多时候我们只是想着将写出来的代码进行复用，不要写出重复的代码，但其实最重要的是对问题的抽象，划分出合理的模块和设计模块之间的耦合关系，代码复用只是这个过程中自然而然产生的现象，我们应该明白问题的本质。</p><p>JavaScript并不像一些强类型语言那样使用class继承，而是基于原型的方式继承。从ES6开始，出现了<code>class</code>关键字，这让JavaScript看看起来更像面向对象的编程语言。但是，实际上ES6的<code>class</code>关键字不过是原型继承的语法糖而已。</p><h2 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h2><h3 id="①-工厂模式-Factory-Pattern-创建类对象"><a href="#①-工厂模式-Factory-Pattern-创建类对象" class="headerlink" title="① 工厂模式(Factory Pattern)创建类对象"></a>① 工厂模式(Factory Pattern)创建类对象</h3><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Car</span>(<span class="hljs-params">color,doors,oil</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> tempCar = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();<br>     tempCar.color = <span class="hljs-string">&#x27;red&#x27;</span>;<br>     tempCar.doors = <span class="hljs-number">4</span>;<br>     tempCar.oil = <span class="hljs-string">&#x27;10%&#x27;</span>;<br>     tempCar.showOil = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>          alert(<span class="hljs-built_in">this</span>.oil);<br>     &#125;;<br>     <span class="hljs-keyword">return</span> tempCar;<br>&#125;<br><br><span class="hljs-keyword">let</span> car = Car(<span class="hljs-string">&#x27;red&#x27;</span>,<span class="hljs-number">4</span>,<span class="hljs-number">75</span>%);<br></code></pre></div></td></tr></table></figure><ul><li> 工厂模式创建对象非常<strong>容易理解</strong>，将创建对象，添加属性的过程封装为一个函数，属性值作为函数的参数传入，当我们想要一个对象的时候，执行这个函数即可。</li><li> 但是工厂模式有一个<strong>缺点</strong>，就是所有有其创建的实例都是使用用<code>Object</code>构造的，不易区分。</li></ul><h3 id="②-构造函数-constructor-创建类"><a href="#②-构造函数-constructor-创建类" class="headerlink" title="② 构造函数(constructor)创建类"></a>② 构造函数(constructor)创建类</h3><ul><li>构造函数相比工厂函数的区别在于:构造函数方法的目的是创建模版，使用了<code>this</code>关键字。</li></ul><p>与工厂模式相比，构造函数方法<strong>优点</strong>是<strong>没有显式地创建对象</strong>，而是直接将属性和方法赋值给了<code>this</code>对象，在构造函数内部，<code>this</code>指向构造出来的内部对象。此外，这种方法没有<code>return</code>语句,构造函数默认返回this，即新实例对象 。其次构造函数创建的对象<strong>可识别</strong>。</p><p>调用函数时，构造函数创建类<strong>一定会使用</strong><code>new</code>操作符。</p><ul><li>构造函数没有返回值，这一点类似于一些语言创建类的方法（例如Java、C++和Python都以 class 关键字来创建类，都没有return关键字）<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Vehicle</span>(<span class="hljs-params">vCholor,vDoors,vOil</span>)</span>&#123;<br>    <span class="hljs-built_in">this</span>.color = vCholor;<br>    <span class="hljs-built_in">this</span>.doors = vDoors;<br>    <span class="hljs-built_in">this</span>.oil = vOil;<br>   <span class="hljs-built_in">this</span>.showOil = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    alert(<span class="hljs-built_in">this</span>.oil);<br>    &#125;;<br>&#125;<br><br><span class="hljs-keyword">let</span> vehicle1 = <span class="hljs-keyword">new</span> Vehicle(<span class="hljs-string">&#x27;red&#x27;</span>,<span class="hljs-number">4</span>,<span class="hljs-string">&#x27;75%&#x27;</span>);<br><br><span class="hljs-built_in">console</span>.log(vehicle1.constructor === Vehicle);    <span class="hljs-comment">//true</span><br><span class="hljs-built_in">console</span>.log(vehicle1 <span class="hljs-keyword">instanceof</span> Vehicle);   <span class="hljs-comment">//true</span><br></code></pre></div></td></tr></table></figure></li></ul><p>当然，构造函数也有<strong>缺点</strong>：会将方法在每个实例上都创建一遍。</p><h3 id="③-基于原型-构造函数创建类对象"><a href="#③-基于原型-构造函数创建类对象" class="headerlink" title="③ 基于原型+构造函数创建类对象"></a>③ 基于原型+构造函数创建类对象</h3><p>这种方法完全基于JavaScript原型机制创建，体现出原型继承思想的精髓。</p><ul><li>每创建一个函数就有一个prototype（原型）属性，这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。如果按照字面意思来理解，那么 prototype 就是通过调用构造函数而创建的那个对象实例的原型对象。使用原型对象的好处是可以让所有对象实例共享它所包含的属性和方法。<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params">name,age</span>) </span>&#123;<br>    <span class="hljs-built_in">this</span>.name = name;<br>    <span class="hljs-built_in">this</span>.age = age;<br>    <span class="hljs-built_in">this</span>.frients = [<span class="hljs-string">&#x27;JackieChan&#x27;</span>, <span class="hljs-string">&#x27;EasonChan&#x27;</span>];<br>&#125;;<br>Person.prototype = &#123;<br>    <span class="hljs-attr">constructor</span>: Person,<br><span class="hljs-attr">job</span>: <span class="hljs-string">&quot;Software Engineer&quot;</span>,<br>sayName () &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.name;<br>    &#125;<br>&#125;;<br><span class="hljs-keyword">let</span> person1 = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;andy8421&quot;</span>, <span class="hljs-number">18</span>);<br><span class="hljs-keyword">let</span> person2 = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;googleplex&quot;</span>, <span class="hljs-number">25</span>);<br><span class="hljs-comment">// 也可以使用Object.create()方法创建实例</span><br></code></pre></div></td></tr></table></figure>使用这种方法是有一个关键点：引用类型<strong>不要</strong>放到原型上，例如上代码中<code>this.frients = [&#39;JackieChan&#39;, &#39;EasonChan&#39;];</code>不能放到<code>Person.prototype</code>中，否则会出现修改冲突：当person1修改friends时，person2的friends也会被修改。这也是为什么一般不单独使用原型模式创建对象，而是使用原型+构造函数组合模式创建的原因。</li></ul><h3 id="④-class关键字"><a href="#④-class关键字" class="headerlink" title="④ class关键字"></a>④ class关键字</h3><p>从ES6开始出现<code>class</code>关键字，它使得JavaScript看起来更像面向对象的编程语言。然而实质上，<code>class</code>关键字是基于原型+构造函数创建类对象的一个<code>语法糖</code>而已。</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name,age</span>)</span>&#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    <span class="hljs-built_in">this</span>.frients = [<span class="hljs-string">&#x27;JackieChan&#x27;</span>, <span class="hljs-string">&#x27;EasonChan&#x27;</span>];<br>    &#125;<br>    job = <span class="hljs-string">&quot;Software Engineer&quot;</span>;<br>sayName () &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.name;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">let</span> person1 = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;andy8421&quot;</span>, <span class="hljs-number">18</span>);<br><span class="hljs-keyword">let</span> person2 = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;googleplex&quot;</span>, <span class="hljs-number">25</span>);<br><span class="hljs-comment">// 也可以使用Object.create()方法创建实例</span><br></code></pre></div></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="对象的创建模式"><a href="#对象的创建模式" class="headerlink" title="对象的创建模式"></a>对象的创建模式</h3><ul><li><p>Object构造函数模式</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;&#125;;<br>obj.name = <span class="hljs-string">&#x27;Tom&#x27;</span><br>obj.setName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name</span>)</span>&#123;<span class="hljs-built_in">this</span>.name=name&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>对象字面量模式</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;<br>  <span class="hljs-attr">name</span> : <span class="hljs-string">&#x27;Tom&#x27;</span>,<br>  <span class="hljs-attr">setName</span> : <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name</span>)</span>&#123;<span class="hljs-built_in">this</span>.name = name&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>构造函数模式</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params">name, age</span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.name = name;<br>  <span class="hljs-built_in">this</span>.age = age;<br>  <span class="hljs-built_in">this</span>.setName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name</span>)</span>&#123;<span class="hljs-built_in">this</span>.name=name;&#125;;<br>&#125;<br><span class="hljs-keyword">new</span> Person(<span class="hljs-string">&#x27;tom&#x27;</span>, <span class="hljs-number">12</span>);<br></code></pre></div></td></tr></table></figure></li><li><p>构造函数+原型的组合模式</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params">name, age</span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.name = name;<br>  <span class="hljs-built_in">this</span>.age = age;<br>&#125;<br>Person.prototype.setName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name</span>)</span>&#123;<span class="hljs-built_in">this</span>.name=name;&#125;;<br><span class="hljs-keyword">new</span> Person(<span class="hljs-string">&#x27;tom&#x27;</span>, <span class="hljs-number">12</span>);<br></code></pre></div></td></tr></table></figure></li><li><p>class关键字</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span> </span>&#123;&#125;<br><br><span class="hljs-comment">// 构造函数的类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bar</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;&#125;<br>&#125;<br><br><span class="hljs-comment">// 获取函数的类 </span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Baz</span> </span>&#123;<br><span class="hljs-keyword">get</span> <span class="hljs-title">myBaz</span>() &#123;&#125;<br>&#125;<br><br><span class="hljs-comment">//静态方法的类 </span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Qux</span> </span>&#123;<br><span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-title">myQux</span>(<span class="hljs-params"></span>)</span> &#123;&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="OOP的特点"><a href="#OOP的特点" class="headerlink" title="OOP的特点"></a>OOP的特点</h3></li></ul><ul><li>面向对象（OOP）的三大基本特性</li></ul><blockquote><p>封装：隐藏对象的属性和实现细节，仅对外公开接口，控制程序中属性读和修改的访问级。将数据与操作数据的源代码进行有机结合，形成‘类’。其中的数据和函数都是类的成员。<br>继承：使子类具有父类的属性。<br>多态：同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果。</p></blockquote><ul><li>面向对象语言的四个基本准则：</li></ul><blockquote><p>抽象：忽略主题中与当前目标无关的那些方面，以便更充分地注意与当前目标有关的方面。<br>继承: 使得子类具有父类的属性和方法或者重新定义、追加属性和方法等。<br>封装: 隐藏对象的属性和实现细节，仅对外公开接口，控制在程序中属性的读和修改的访问级别<br>多态: 接口可以有多种不同的实现方式</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>Front end</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>原型链</title>
    <link href="/2019/07/25/%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    <url>/2019/07/25/%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
    
    <content type="html"><![CDATA[<p>.</p><!--more--><h3 id="显式原型和隐式原型基本概念"><a href="#显式原型和隐式原型基本概念" class="headerlink" title="显式原型和隐式原型基本概念"></a>显式原型和隐式原型基本概念</h3><ul><li><p>所有的构造函数(对象)都有一个属性:</p><ul><li><code>prototype</code> : 显式原型(属性)，默认指向它的原型对象。显示原型在定义函数时自动添加，一般可以进行人为操作。</li><li>每个原型对象中有一个属性：constructor，默认指向这个函数对象</li></ul></li><li><p>由函数对象创建的实例对象都有一个属性:</p><ul><li><code>[[Prototype]]</code>(实际中是<code>__proto__</code>) : 隐式原型(属性)，默认指向它构造函数对象的原型对象。隐式原型在创建对象时自动添加，它是内部指针，一般禁止对其进行直接操作。<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params"></span>)</span>&#123;<br>&#125;<br><br>Person.prototype.name = <span class="hljs-string">&#x27;Nicholas&#x27;</span>;<br>Person.prototype.age = <span class="hljs-number">29</span>;<br>Person.prototype.job = <span class="hljs-string">&#x27;Software Engineer&#x27;</span>;<br>Person.prototype.sayName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name);<br>&#125;;<br><br><span class="hljs-keyword">var</span> person1 = <span class="hljs-keyword">new</span> Person();<br><span class="hljs-keyword">var</span> person2 = <span class="hljs-keyword">new</span> Person();<br><span class="hljs-built_in">console</span>.log(person1.sayName === person2.sayName);    <span class="hljs-comment">//true</span><br></code></pre></div></td></tr></table></figure><img src="/2019/07/25/%E5%8E%9F%E5%9E%8B%E9%93%BE/%E6%98%BE%E7%A4%BA%E5%8E%9F%E5%9E%8B%E5%92%8C%E9%9A%90%E5%BC%8F%E5%8E%9F%E5%9E%8B.png" alt="enter description here"></li></ul></li></ul><p><strong>显式原型和隐形原型的关系</strong>：构造函数的显式原型的值和它实例对象的隐式原型的值相同,都指向构造函数的原型对象。</p><h3 id="显式原型和隐式原型的生成过程"><a href="#显式原型和隐式原型的生成过程" class="headerlink" title="显式原型和隐式原型的生成过程"></a>显式原型和隐式原型的生成过程</h3><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">//定义构造函数</span><br>   <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Fn</span>(<span class="hljs-params"></span>) </span>&#123;   <span class="hljs-comment">// 内部语句: this.prototype = &#123;&#125;;</span><br>   &#125;<br><br>   <span class="hljs-comment">// 1. 每个函数function都有一个prototype，即显式原型, 默认指向一个空的Object对象</span><br>   <span class="hljs-built_in">console</span>.log(Fn.prototype);<br><br>   <span class="hljs-comment">// 2. 每个实例对象都有一个__proto__，即隐式原型</span><br>   <span class="hljs-keyword">var</span> fn = <span class="hljs-keyword">new</span> Fn();  <span class="hljs-comment">// 内部语句: this.__proto__ = Fn.prototype</span><br>   <span class="hljs-built_in">console</span>.log(fn.__proto__);<br><br>   <span class="hljs-comment">// 3. 对象的隐式原型的值为其对应构造函数的显式原型的值（构造函数的显式原型对象 === 其构造函数实例对象的隐式原型对象）</span><br>   <span class="hljs-built_in">console</span>.log(Fn.prototype === fn.__proto__); <span class="hljs-comment">// true</span><br><br>   <span class="hljs-comment">//给原型添加方法</span><br>   Fn.prototype.test = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>       <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;test()&#x27;</span>);<br>   &#125;;<br>   <span class="hljs-comment">//通过实例调用原型的方法</span><br>   fn.test();<br></code></pre></div></td></tr></table></figure><p>以上过程的内存解析：<br><img src="/2019/07/25/%E5%8E%9F%E5%9E%8B%E9%93%BE/%E5%8E%9F%E5%9E%8B%E5%86%85%E5%AD%98%E8%A7%A3%E6%9E%90.png" alt="原型内存解析"></p><p><strong>显示原型和隐式原型</strong></p><ol><li>每创建一个函数，该函数就有一个prototype，即显式原型属性（简称显式原型），指向一个空的Object对象（原型对象）</li><li>每给函数创建一个实例对象，该对象就有一个__proto__（书写上写作[[prototype]]）, 即隐式原型属性（简称隐式原型），其值为其对应构造函数的显式原型的值。简而言之，隐式原型和显式原型中保存的地址值是相同的，都指向原型对象。ES5之前的版本，一般不宜对__proto__做直接操作。</li><li>对象的隐式原型的值为其对应构造函数显式原型的值</li><li>对于函数Function()，它有一个prototype，该函数自身的实例对象Function有一个__proto__。它们都指向原型对象。简而言之，Function函数的显式原型和该函数自己创建的隐式原型的值相同（其他函数并不存在这一点特征）。</li><li><strong>函数所有实例的隐式原型__proto__的值都等于该函数显式原型prototype的值，并等于原型对象的地址。</strong></li></ol><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Fn</span>(<span class="hljs-params"></span>) </span>&#123;<br>     <span class="hljs-comment">//浏览器引擎内部自动添加语句：this.prototype = &#123; &#125;;</span><br>&#125;<br><span class="hljs-built_in">console</span>.log(Fn.prototype);  <span class="hljs-comment">//一个Object实例</span><br><span class="hljs-keyword">var</span> fn = <span class="hljs-keyword">new</span> Fn();<br><span class="hljs-built_in">console</span>.log(fn.__proto__);     <span class="hljs-comment">//内部语句：this.__proto__ = Fn.prototype</span><br><span class="hljs-built_in">console</span>.log(Fn.prototype === fn.__proto__);     <span class="hljs-comment">//true</span><br><br><span class="hljs-comment">//给原型对象添加方法</span><br>Fn.prototype.test = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;test&#x27;</span>);<br>&#125;<br>fn.test();      <span class="hljs-comment">//test。这一步是通过实例对象调用原型对象的方法。当实例对象中没有外部属性时，浏览器自动根据__proto__的值，即原型对象的地址，来寻找原型对象中的相关属性。</span><br><br><span class="hljs-built_in">console</span>.log(fn.__proto__ === Fn.prototype); <span class="hljs-comment">//true</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Function</span>.__proto__ === <span class="hljs-built_in">Function</span>.prototype); <span class="hljs-comment">//true</span><br><span class="hljs-built_in">console</span>.log(Fn.__proto__ === Fn.prototype);  <span class="hljs-comment">//false</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.prototype.__proto__);       <span class="hljs-comment">//null</span><br></code></pre></div></td></tr></table></figure><h1 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h1><p>原型链（隐式原型属性链）：访问一个对象属性时，先在自身属性中查找，可以找到就返回该属性值；若没有找到，则沿着__proto__这条链依次向上查找；若果在Object原型对象（原型链的尽头）仍没有找到该属性，则返回undefined。</p><p>但是JavaScript设定：Object的原型对象指向null</p><p>许多面向对象语言都支持两种继承方式：<code>接口继承</code>和<code>实现继承</code>。接口继承只继承方法签名，而实现继承则继承实际的方法。由于函数没有签名，在 ECMAScript中无法实现接口继承。ECMAScript只支持实现继承，而且其实现继承主要是依靠原型链（又称隐式原型链）来实现的。</p><p><strong>主要思想</strong>：利用原型让一个引用类型继承另一个引用类型的属性和方法。<br><strong>依据</strong>：每一个构造函数都有一个原型对象，原型对象包含一个指向构造函数的指针（<code>constructor</code>），而函数的实例对象都存在一个指向原型对象的指针（<code>__proto__</code>）。假如实例所指向的原型对象本身又是另一个构造函数的实例对象（称另一个类的实例），那么此时原型对象（记为原型对象1）中就包含一个指向另一个原型对象（记为原型对象2）的指针，相应的，另一个原型对象包含一个指向另一个构造函数的指针。进一步可知，原实例对象与原型对象2的关系是：原实例对象的隐式原型的隐式原型指向原型对象2。事实上，原型对象2是原型对象1的父类型，原型对象1是原实例对象的父类型。<br><strong>原型链的作用</strong>：访问对象属性</p><ul><li>访问一个对象的属性时，<br>① 先在实例对象自身属性中查找，看是否有该属性，若找到则直接返回该属性<br>② 如果没有找到, 再沿着<code>__proto__</code>这条链(即原型链)向上查找, 直到找到则返回该属性<br>③ 若始终没有找到，这种沿着原型链向上游查找也不是无限制的。JS中，一切对象都是Object()的实例对象，所以，它的原型对象将作为查找的终点。如果最终在Object()的原型对象Object.prototype中仍没有找到该属性, 则返回undefined（这个对象再没有实际指向了，它的隐式原型<code>Object.prototype.__proto__</code>值为null，是个空指针）<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">//创建父类</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params">name, age</span>) </span>&#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.age = age;<br>&#125;<br><br><span class="hljs-comment">//创建子类</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Student</span>(<span class="hljs-params">name, age, sex</span>) </span>&#123;<br>    Person.call(<span class="hljs-built_in">this</span>, name, age);  <span class="hljs-comment">// 提取父类的属性</span><br>    <span class="hljs-built_in">this</span>.sex = sex; <span class="hljs-comment">//子类自己添加sex属性</span><br>&#125;<br><br>    Student.prototype = <span class="hljs-keyword">new</span> Person();  <span class="hljs-comment">// 真正实现继承</span><br>    Student.prototype.constructor = Student;  <span class="hljs-comment">//修正constructor属性</span><br><br><span class="hljs-comment">//为Student创建一个实例对象girl</span><br><span class="hljs-keyword">var</span> girl = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;silybily&quot;</span>, <span class="hljs-number">26</span>, <span class="hljs-string">&quot;female&quot;</span>);<br><br><span class="hljs-comment">//检验：</span><br><span class="hljs-built_in">console</span>.log(girl);<br>girl.__proto__ === Student.prototype;  <span class="hljs-comment">//true</span><br>girl.__proto__.__proto__ ===  Person.prototype;  <span class="hljs-comment">//true</span><br>girl.__proto__.__proto__.__proto__ === <span class="hljs-built_in">Object</span>.prototype;<span class="hljs-comment">//true</span><br>girl.__proto__.__proto__.__proto__.__proto__ === <span class="hljs-literal">null</span>;  <span class="hljs-comment">//true</span><br><br><span class="hljs-built_in">console</span>.log(girl.name);   <span class="hljs-comment">//silybily</span><br><span class="hljs-built_in">console</span>.log(girl.hobby);  <span class="hljs-comment">//undefined</span><br></code></pre></div></td></tr></table></figure><img src="/2019/07/25/%E5%8E%9F%E5%9E%8B%E9%93%BE/%E5%8E%9F%E5%9E%8B%E9%93%BE.png" alt="原型链"><br>有一点需要特别注意的是：构造函数本身，首先是一个对象，理解了这一点，上面的过成就不难理解了</li></ul><h1 id="探索instanceof"><a href="#探索instanceof" class="headerlink" title="探索instanceof"></a>探索instanceof</h1><p><strong>作用</strong>：判断函数的显式原型是否在另一个对象的原型链上<br><strong>语法</strong>：<code>A instanceof B</code> 判断<code>B函数的显式原型</code>是否在<code>A对象</code>的原型链上。如果存在则返回true，否则返回false</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">//案例1</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Foo</span>(<span class="hljs-params"></span>) </span>&#123;  &#125;<br><span class="hljs-keyword">var</span> f1 = <span class="hljs-keyword">new</span> Foo();<br><span class="hljs-built_in">console</span>.log(f1 <span class="hljs-keyword">instanceof</span> Foo);  <span class="hljs-comment">// true</span><br><span class="hljs-built_in">console</span>.log(f1 <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Object</span>);  <span class="hljs-comment">// true</span><br></code></pre></div></td></tr></table></figure><p>由<code>function Foo() &#123;  &#125;</code>，构造函数Foo()的显式原型指向一个空的Object原型对象{ }<br>由<code>var f1 = new Foo();</code>，声明了一个变量f1指向函数Foo()的实例对象<br>由以上两步可知，<code>Foo.prototype === f1.__proto__ === &#123; &#125;</code>因此Foo()的显式原型在对象f1的原型链上<br>Object是任何实例的构造函数，显然在f1的原型链上</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">//案例二</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Function</span>); <span class="hljs-comment">// true</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Object</span>); <span class="hljs-comment">// true</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Function</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Function</span>); <span class="hljs-comment">// true</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Function</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Object</span>); <span class="hljs-comment">// true</span><br></code></pre></div></td></tr></table></figure><p>这个是怎么一回事呢？仍要回头看instanceof得定义：A instanceof B判断A的原型链上是否存在B.prototype。而在JavaScript中，Object和Function之间的关系可以用一张图来说明：<br><img src="/2019/07/25/%E5%8E%9F%E5%9E%8B%E9%93%BE/Function%E5%92%8CObject.png" alt="enter description here"><br>从上图中抽离Function和Object的关系，即：<br> <img src="/2019/07/25/%E5%8E%9F%E5%9E%8B%E9%93%BE/%E6%8A%BD%E7%A6%BBFunction%E5%92%8CObject%E7%9A%84%E5%85%B3%E7%B3%BB%E5%9B%BE.png" alt="enter description here"><br>根据该图①，再来看一下代码就一目了然了：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">//①构造器Function的构造器是它自身</span><br><span class="hljs-built_in">Function</span>.constructor=== <span class="hljs-built_in">Function</span>;  <span class="hljs-comment">//true</span><br><br><span class="hljs-comment">//②构造器Object的构造器是Function（由此可知所有构造器的constructor都指向Function）</span><br><span class="hljs-built_in">Object</span>.constructor === <span class="hljs-built_in">Function</span>;  <span class="hljs-comment">//true</span><br><br><span class="hljs-comment">//③构造器Function的__proto__是一个特殊的匿名函数function() &#123;&#125;</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Function</span>.__proto__);  <span class="hljs-comment">//function() &#123;&#125;</span><br><br><span class="hljs-comment">//④这个特殊的匿名函数的__proto__指向Object的prototype原型。</span><br><span class="hljs-built_in">Function</span>.__proto__.__proto__ === <span class="hljs-built_in">Object</span>.prototype;  <span class="hljs-comment">//true</span><br><br><span class="hljs-comment">//⑤Object的__proto__指向Function的prototype，也就是上面③中所述的特殊匿名函数</span><br><span class="hljs-built_in">Object</span>.__proto__ === <span class="hljs-built_in">Function</span>.prototype;  <span class="hljs-comment">//true</span><br><span class="hljs-built_in">Function</span>.prototype === <span class="hljs-built_in">Function</span>.__proto__;  <span class="hljs-comment">//true</span><br></code></pre></div></td></tr></table></figure><p>如果看完以上，你还觉得上面的关系看晕了的话，只需要记住下面两个最重要的关系，其他关系就可以推导出来了：</p><p>1、所有的构造器的constructor都指向Function</p><p>2、Function的prototype指向一个特殊匿名函数，而这个特殊匿名函数的__proto__指向Object.prototype</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>显式原型与隐式原型的关系<ul><li>函数的prototype: 定义函数时被自动赋值, 原型对象的值默认为{}</li><li>实例对象的__proto__: 在创建实例对象时被自动添加, 并赋值为构造函数的prototype值</li><li>原型对象即为当前实例对象的父对象</li></ul></li><li>原型链<ul><li>所有的实例对象都有__proto__属性, 它指向的就是原型对象</li><li>这样通过__proto__属性就形成了一个链的结构—-&gt;原型链</li><li>当给对象属性赋值时不会使用原型链, 而只是在当前对象中进行操作</li><li>当查找对象内部的属性/方法时, js引擎自动沿着这个原型链查找</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>Front end</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS小结</title>
    <link href="/2019/06/28/CSS%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    <url>/2019/06/28/CSS%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="CSS小结"><a href="#CSS小结" class="headerlink" title="CSS小结"></a>CSS小结</h1><h3 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL;DR"></a>TL;DR</h3><p><strong>防止margin合并的方法</strong>：</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-comment">/* 防止同级元素发生margin合并： */</span><br><span class="hljs-selector-class">.chiled</span>&#123;<br>    <span class="hljs-attribute">display</span>:inline-block;<br>&#125;<br><br><span class="hljs-comment">/* 防止子元素和父级元素发生margin合并 */</span><br><span class="hljs-selector-class">.parent</span>&#123;<br>  <span class="hljs-comment">/* 方法一：父级元素添加border（top或bottom） */</span><br>    <span class="hljs-attribute">border-top</span>:<span class="hljs-number">1px</span> solid red;<br>  <span class="hljs-comment">/* 方法二：父级元素添加padding */</span><br>    <span class="hljs-attribute">padding</span>:<span class="hljs-number">1px</span>;<br>  <span class="hljs-comment">/* 方法三：父级元素添加overflow:hidden; */</span><br>    <span class="hljs-attribute">overflow</span>:hidden;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>float 布局</strong></p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-comment">/*避免元素脱离文档流。使用float布局时，此选择器必须写*/</span><br><span class="hljs-selector-class">.clearfix</span>&#123;<br>    <span class="hljs-attribute">content</span>:<span class="hljs-string">&#x27;&#x27;</span>;<br> <span class="hljs-attribute">display</span>:block;<br>    <span class="hljs-attribute">clear</span>:both;<br>&#125;<br><br><span class="hljs-comment">/*设置float布局*/</span><br><span class="hljs-selector-class">.floatelement</span>&#123;<br>    <span class="hljs-attribute">float</span><span class="hljs-selector-pseudo">:left</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>flex控制元素水平垂直居中</strong></p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span>&#123;<br>  <span class="hljs-attribute">display</span>:flex;<br>  <span class="hljs-attribute">justify-content</span>:center;<br>  <span class="hljs-attribute">align-items</span>:center;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100vh</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="CSS动画"><a href="#CSS动画" class="headerlink" title="CSS动画"></a>CSS动画</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/transition"><code>transition</code></a>可以为一个元素在不同状态之间切换的时候定义不同的<strong>过渡动画</strong>效果。比如在不同的伪元素之间切换，像是 <code>:hover</code>，<code>:active</code> 或者通过 JavaScript 实现的状态变化。</p><p>伪代码举例：</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.heart</span>&#123;<br>     <span class="hljs-attribute">transition</span>:all <span class="hljs-number">1s</span>;<br>     <span class="hljs-comment">/* transition定义:hover的过度动画为1s内完成全部动作 */</span><br>&#125;<br><br><span class="hljs-selector-class">.heart</span><span class="hljs-selector-pseudo">:hover</span>&#123;<br>    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">scale</span>(<span class="hljs-number">1.2</span>);<br>    <span class="hljs-comment">/* 缩放或扩大 */</span><br>    <span class="hljs-comment">/* transform: translate(50px); */</span><br>    <span class="hljs-comment">/* 位移*/</span><br>    <span class="hljs-comment">/* transform: rotate(-135deg); */</span><br>    <span class="hljs-comment">/* 旋转*/</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/animation"><code>animation</code></a>定义了元素在<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/@keyframes"><strong>关键帧</strong>（<code>@keyframes</code>）</a>之间变化的参数，间接控制动画效果。</p><p>伪代码举例：</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.heart</span>&#123;<br>    <span class="hljs-attribute">animation</span>:.<span class="hljs-number">5s</span> heart infinite alternate;<br>    / * <span class="hljs-attribute">animation</span>定义heart关键帧之间变化的动画效果在<span class="hljs-number">0.5s</span>以内完成（周期<span class="hljs-number">0.5s</span>），infinite表示动画效果无限次循环，alternate表示在关键帧之间循环往复 */<br>&#125;<br><br><span class="hljs-keyword">@keyframes</span> heart&#123;<br>    <span class="hljs-number">0%</span>&#123;<br>        <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">scale</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-number">50%</span>&#123;<br>        <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">scale</span>(<span class="hljs-number">1.2</span>)<br>    &#125;<br>    <span class="hljs-number">100%</span>&#123;<br>        <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">scale</span>(<span class="hljs-number">1.5</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/* @keyframes heart&#123;</span><br><span class="hljs-comment">    from&#123;</span><br><span class="hljs-comment">        transform: scale(1);</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">    to&#123;</span><br><span class="hljs-comment">        transform: scale(1.5);</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">&#125; */</span><br><span class="hljs-comment">/* from先当于0%，to相当于100% */</span><br></code></pre></div></td></tr></table></figure><h3 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h3><p><a href="https://yichang8421.github.io/css-demo-HeartSheep/">用纯CSS制作红心（transition配合:hover）</a></p><p>源码：<a href="https://github.com/yichang8421/css-demo-HeartSheep/blob/main/index.html">https://github.com/yichang8421/css-demo-HeartSheep/blob/main/index.html</a></p><p><a href="https://yichang8421.github.io/BeatingHeart/">用纯CSS制作跳动的心（animation）</a></p><p>源码：<a href="https://github.com/yichang8421/BeatingHeart">https://github.com/yichang8421/BeatingHeart</a></p><h2 id="浏览器渲染过程"><a href="#浏览器渲染过程" class="headerlink" title="浏览器渲染过程"></a>浏览器渲染过程</h2><p>参考：<a href="https://developer.mozilla.org/zh-CN/docs/Web/Performance/How_browsers_work">渲染页面：浏览器的工作原理</a></p><p><strong>解析</strong>：</p><ol><li>构建DOM树：处理HTML标记并构造DOM树。</li><li>构建CSSOM树：处理CSS并构建CSSOM树。</li></ol><p><strong>渲染</strong>：</p><ol start="3"><li><p>构建Render树：将DOM和CSSOM组合成一个Render树。</p></li><li><p>Layout布局：在渲染树上运行布局以计算每个节点的几何体。例如，文档流、盒模型、计算大小和位置</p></li><li><p>Paint：将各个节点边框颜色、文字颜色、阴影等绘制到屏幕上。</p></li><li><p>Compose合成：根据层叠关系展示画面。当文档的各个部分以不同的层绘制，相互重叠时，必须进行合成，以确保它们以正确的顺序绘制到屏幕上，并正确显示内容。</p></li></ol><p>使用js更新样式时，浏览器有三种更新方式：</p><p><img src="/2019/06/28/CSS%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/1615733900881.png" alt="1615733900881"></p><h3 id="CSS动画优化总结"><a href="#CSS动画优化总结" class="headerlink" title="CSS动画优化总结"></a>CSS动画优化总结</h3><p>参考：<a href="https://developers.google.com/web/fundamentals/performance/rendering/optimize-javascript-execution">https://developers.google.com/web/fundamentals/performance/rendering/optimize-javascript-execution</a></p><p>​    <strong>JS优化</strong>：<code>setTimeout</code>/<code>setInterval</code> =&gt; <code>requestAnimationFrame</code></p><p>   <strong>CSS优化</strong>：<code>left</code>/<code>right</code>/<code>top</code>/<code>bottom</code> =&gt; <code>transform:translate</code></p><h2 id="文档流"><a href="#文档流" class="headerlink" title="文档流"></a>文档流</h2><p>inline 从左到右，超过部分会分割换行。宽度由其内inline元素的宽度之和决定。高度由<strong>行高</strong>间接确定，一般设置的只是inline的可视高度。</p><p>block 从上到小，独占一行。宽度为auto。高度为其内文档流元素的高度之和决定。</p><p>（经验：**尽量不要写width: 100%**）</p><p>inline-block  从左到右，会换行但是元素成块不会分割跨行。</p><p>文档流超出边框时overflow，一般只使用<code>overflew: auto;</code></p><p>overflew: visible；</p><p>overflew: hidden;</p><p>overflew: auto;</p><p>overflew: scroll;  横纵向都有滚动条，这个值可以完全被auto替代。</p><h3 id="脱离文档流"><a href="#脱离文档流" class="headerlink" title="脱离文档流"></a>脱离文档流</h3><p>元素脱离文档流的方法：</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-comment">/*方法一：position设为absolute或fixed*/</span><br><span class="hljs-attribute">position</span>: absolute;<br><span class="hljs-comment">/*方法二：*/</span><br><span class="hljs-attribute">float</span>: left;<br></code></pre></div></td></tr></table></figure><h2 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h2><p>盒模型是网页布局的基础，它制定了元素如何在页面中显示。</p><ul><li><p>css中盒模型按boder-sizing的不同分为content-box和border-box。</p></li><li><p>二者的区别是content-box宽度只包含content（内容）；而border-box宽度包含border（边框）、padding（内边距）、content（内容）。</p></li><li><p>当没有指定border和padding值时，二者是相同的。</p></li></ul><p>实际开发中使用border-box更多。</p><h3 id="margin合并"><a href="#margin合并" class="headerlink" title="margin合并"></a>margin合并</h3><p>元素设置margin值时可能会出现合并问题：</p><ul><li><p>margin合并问题只出现在两个元素<strong>垂直方向</strong>上同时设置margin时，水平方向同时设置margin<strong>不会</strong>出现此问题。</p></li><li><p>当垂直方向上兄弟元素同时设置上下margin时，则兄弟元素的上下margin会重合。</p></li><li><p>当父级元素和孩子元素同时设置上下margin时，则父级元素会和其<strong>第一个</strong>孩子元素以及<strong>最后一个</strong>孩子元素发生margin重合。</p></li></ul><p><strong>防止margin合并的方法</strong>：</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-comment">/* 防止同级元素发生margin合并： */</span><br><span class="hljs-selector-class">.chiled</span>&#123;<br>    <span class="hljs-attribute">display</span>:inline-block;<br>&#125;<br><br><span class="hljs-comment">/* 防止子元素和父级元素发生margin合并 */</span><br><span class="hljs-selector-class">.parent</span>&#123;<br>  <span class="hljs-comment">/* 方法一：父级元素添加border（top或bottom） */</span><br>    <span class="hljs-attribute">border-top</span>:<span class="hljs-number">1px</span> solid red;<br>  <span class="hljs-comment">/* 方法二：父级元素添加padding */</span><br>    <span class="hljs-attribute">padding</span>:<span class="hljs-number">1px</span>;<br>  <span class="hljs-comment">/* 方法三：父级元素添加overflow:hidden; */</span><br>    <span class="hljs-attribute">overflow</span>:hidden;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux常用命令——增删改查</title>
    <link href="/2019/06/20/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <url>/2019/06/20/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux常用命令"><a href="#Linux常用命令" class="headerlink" title="Linux常用命令"></a>Linux常用命令</h1><h1 id="start"><a href="#start" class="headerlink" title="start"></a>start</h1><p>脚本文件：</p><p><a href="https://zh.wikipedia.org/wiki/Shebang">什么是shebang？</a></p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-meta">#!/usr/bin/env sh//shebang，用于指定脚本解释器。表示使用env程序搜索路径找到脚本文件，同时使用shall解释器执行这个脚本文件。env即environment</span><br>mkdir <span class="hljs-variable">$1</span>//创建文件夹，文件夹名为代传参数.<span class="hljs-variable">$1</span>表示待传参数<br><span class="hljs-built_in">cd</span> <span class="hljs-variable">$1</span>//进入到用户设置的文件夹中<br>touch index.html style.css main.js//创建三个文件<br><br><span class="hljs-built_in">echo</span> -e <span class="hljs-string">&quot;&lt;!DOCTYPE html&gt;\n&lt;h1&gt;标题&lt;/h1&gt;&quot;</span> &gt;&gt; index.html//设置index.html的内容<br></code></pre></div></td></tr></table></figure><p>命令行操作：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">touch 脚本文件//创建脚本文件（可以不设置扩展名）<br>start 脚本文件//使用默认软件打开（未设置扩展名时，此命令将执行失败）<br>code 脚本文件//使用vscode打开脚本文件<br>chmod +x 脚本文件//为脚本文件添加可执行权限（Windows下此句无用途）<br>./脚本文件  <span class="hljs-built_in">test</span>//执行脚本文件<br><br>/* 或者使用当前的shall解释器执行脚本文件 */<br>sh 脚本文件 <span class="hljs-built_in">test</span><br><br>/* 如果脚本文件中添加了shebang申明，同时将脚本文件路径加入到PATH环境变量中，也可以将脚本文件直接作为一个命令执行 */<br>脚本文件 <span class="hljs-built_in">test</span><br></code></pre></div></td></tr></table></figure><p><strong>命令的本质是可执行脚本文件（可执行程序）</strong>。</p><p>使用<code>which</code>可以查看命令对应的<strong>可执行程序</strong>的位置</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">which</span> 脚本文件<br></code></pre></div></td></tr></table></figure><h1 id="命令行增删该查"><a href="#命令行增删该查" class="headerlink" title="命令行增删该查"></a>命令行增删该查</h1><h2 id="命令行缩写"><a href="#命令行缩写" class="headerlink" title="命令行缩写"></a>命令行缩写</h2><table><thead><tr><th>命令</th><th>含义</th><th>命令</th><th>含义</th></tr></thead><tbody><tr><td>mk</td><td>make</td><td>ls</td><td>list</td></tr><tr><td>mv</td><td>move</td><td>ln</td><td>link</td></tr><tr><td>rm</td><td>remove</td><td>find</td><td>find</td></tr><tr><td>cp</td><td>copy</td><td>cd</td><td>change directory</td></tr><tr><td>pwd</td><td>print work directory</td><td>cat</td><td>concatenate</td></tr></tbody></table><h2 id="查：查看文件"><a href="#查：查看文件" class="headerlink" title="查：查看文件"></a>查：查看文件</h2><p>pwd 查看文件目录绝对路径</p><p>（绝对路径是所有以/开头的路径。特例~也是绝对路径，它是<code>/c/User/</code>的缩写）</p><p>cat 查看文件的全部内容</p><p>head 查看文件开始的一部分内容  选项-n设置查看行数</p><p>tail 查看文件末尾的一部分内容 选项-n设置查看的行数</p><p>less 按页查看文件内容</p><p>ls 查看当前路径下的文件</p><p>​    -l 选项为长格式查看，包含文件日期等</p><h2 id="增：创建文件"><a href="#增：创建文件" class="headerlink" title="增：创建文件"></a>增：创建文件</h2><p>touch 创建空文件</p><p>echo [文件内容] &gt; [文件名] 创建带内容的文件</p><p>echo [文件内容] &gt;&gt; [文件名] 为已存在的文件追加内容</p><p>​    -e 选项激活转移字符</p><p>mkdir 创建目录</p><p>​    -p 选项创嵌套目录</p><p>cp 复制文件</p><p>​    -r 选项复制文件夹</p><p>例：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">touch 1.txt//创建文件1.txt<br><span class="hljs-built_in">echo</span> hi &gt; 1.txt//创建文件1.txt。内容是“hi”<br><span class="hljs-built_in">echo</span> hihi &gt;&gt; 1.txt//为1.txt增加内容“hihi”<br><span class="hljs-built_in">echo</span> -e <span class="hljs-string">&quot;1\n2&quot;</span> &gt; 1.txt//创建1.txt。内容是“1（换行）2”.此命令的1.txt会覆盖之前的1.txt<br>cp 1.txt 2.txt//将1.txt的内容复制到2.txt（如果2.txt不存在就创建一个和1.txt内容完全相同的2.txt）<br>cp -r a b//将a文件夹的内容复制到b文件夹（若b文件夹不存在则创建b文件夹）<br>mkdir a//创建a文件夹<br>mkdir -p a/b/c//创建a/b/c文件路径<br>touch 3.txt 4.txt//创建3.txt文件和4.txt文件<br>mkdir c d//创建c、d两个文件夹<br></code></pre></div></td></tr></table></figure><h2 id="删：删除文件"><a href="#删：删除文件" class="headerlink" title="删：删除文件"></a>删：删除文件</h2><p>rm 删除文件</p><p>​    -r 选项删除文件夹</p><p>​    -rf 强制删除文件(夹)</p><h2 id="改：对文件进行相应修改"><a href="#改：对文件进行相应修改" class="headerlink" title="改：对文件进行相应修改"></a>改：对文件进行相应修改</h2><h3 id="追加文件内容"><a href="#追加文件内容" class="headerlink" title="追加文件内容"></a>追加文件内容</h3><p>使用echo追加文件内容：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> hi &gt; 1.txt//创建文件1.txt。内容是“hi”<br><span class="hljs-built_in">echo</span> hihi &gt;&gt; 1.txt//为1.txt增加内容“hihi”<br></code></pre></div></td></tr></table></figure><h3 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h3><p>用<code>start</code> 命令使用默认软件打开</p><h3 id="清空文件内容"><a href="#清空文件内容" class="headerlink" title="清空文件内容"></a>清空文件内容</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;&#x27;</span> &gt; 1.txt //将1.txt内容清空（当1.txt本身不存在时，创建空文件1.txt）<br></code></pre></div></td></tr></table></figure><h3 id="移动文件目录"><a href="#移动文件目录" class="headerlink" title="移动文件目录"></a>移动文件目录</h3><p>mv  [文件]  [文件夹/文件路径]</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">mv 1.txt get-demo-1 //将1.txt移动到get-demo-1文件夹<br>mv mv get-demo-1/1.txt . //将get-demo-1中的1.txt移到当前目录<br></code></pre></div></td></tr></table></figure><h3 id="重命名文件"><a href="#重命名文件" class="headerlink" title="重命名文件"></a>重命名文件</h3><figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">mv</span> <span class="hljs-number">1</span>.txt <span class="hljs-number">2</span>.txt //将<span class="hljs-number">1</span>.txt文件名改为<span class="hljs-number">2</span>.txt<br></code></pre></div></td></tr></table></figure><h3 id="更行文件的最后更新时间"><a href="#更行文件的最后更新时间" class="headerlink" title="更行文件的最后更新时间"></a>更行文件的最后更新时间</h3><figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">touch</span> <span class="hljs-number">1</span>.txt//当<span class="hljs-number">1</span>.txt存在时，此命令更新<span class="hljs-number">1</span>.txt最新更新时间<br></code></pre></div></td></tr></table></figure><h2 id="脚本文件"><a href="#脚本文件" class="headerlink" title="脚本文件"></a>脚本文件</h2><ul><li>查看前一条命令执行情况</li></ul><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">echo $?<br><span class="hljs-regexp">/* 如果上一题命令执行成功则返回0；如果失败则返回非0 */</span><br></code></pre></div></td></tr></table></figure><ul><li><code>&amp;&amp;</code>操作</li></ul><p>只有当<code>&amp;&amp;</code>前一条命令执行成功，<code>&amp;&amp;</code>后一条命令才能执行。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">touch test.txt<br>rm test.txt &amp;&amp; <span class="hljs-built_in">echo</span> $?<br>/* 执行结果：0。 */<br></code></pre></div></td></tr></table></figure><ul><li><code>;</code>操作</li></ul><p>命令之间相互分开，各自执行各自的。不论其他命令是否执行成功，每条命令都执行。</p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>阶乘计算升级版</title>
    <link href="/2019/06/20/%E9%98%B6%E4%B9%98%E8%AE%A1%E7%AE%97%E5%8D%87%E7%BA%A7%E7%89%88/"/>
    <url>/2019/06/20/%E9%98%B6%E4%B9%98%E8%AE%A1%E7%AE%97%E5%8D%87%E7%BA%A7%E7%89%88/</url>
    
    <content type="html"><![CDATA[<p>本题目出自于拼题A，基础编程题6-10. 阶乘计算升级版 (20 分)</p><p>该题要求实现一个打印非负整数阶乘的函数。<br>函数接口定义：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Print_Factorial</span> <span class="hljs-params">( <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N )</span></span>;<br></code></pre></div></td></tr></table></figure><p>其中N是用户传入的参数，其值不超过1000。如果N是非负整数，则该函数必须在一行中打印出N!的值，否则打印“Invalid input”。<br>裁判测试程序样例：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Print_Factorial</span> <span class="hljs-params">( <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N )</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> N;<br><br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;N);<br>    Print_Factorial(N);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/* 你的代码将被嵌在这里 */</span><br></code></pre></div></td></tr></table></figure><p>输入样例：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">15</span><br></code></pre></div></td></tr></table></figure><p>输出样例：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1307674368000</span><br></code></pre></div></td></tr></table></figure><p><img src="/2019/06/20/%E9%98%B6%E4%B9%98%E8%AE%A1%E7%AE%97%E5%8D%87%E7%BA%A7%E7%89%88/%E9%98%B6%E4%B9%98%E8%AE%A1%E7%AE%97%E5%8D%87%E7%BA%A7%E7%89%88%E9%80%9A%E8%BF%87%E7%8E%87.png" alt="题目通过率"></p><p>这道题目的通过率仅为0.13，属于较难的题目。其难点主要在于：</p><ol><li>需要要计算大数乘法。由于int类型的范围包含4个字节，排除最高位符号位，其十进制最大可表示的数字是2,147,483,647‬（即2的31次方-1），超过该数就会出现栈溢出问题。用计算器计算一下可以发现，12！= 479,001,600 &lt;‬ 2,147,483,647,它用最简单的递归或者循环来做，没有问题。但是13！= 6,227,020,800 &gt; 2,147,483,647‬,出现栈溢出。</li><li>必须要使用数组来逐位计算数字乘法，同时考虑进位问题。</li></ol><p>解题思路：<br>① 定义一个数组result[ ]用来装阶乘结果。考虑N最大可以取1000，而1000^1000=10^3000 &gt;&gt; 1000!，因此将数组的长度设为3000位绰绰有余。<br>数组result[ ]的角标由小到大可以依次表示结果的低位到高位，最终输出结果，由大角标到小角标输出即可。<br>② 分别定义两个指针i和h，i表示当前运存所处的位置，j表示当前运算结果最高位的位置。<br>③ 每次做乘法，都是用当前阶乘元素n与当前位置i的值做乘法，同时，加上前一位保存的进位数carry。运算结果保存在outcome中。每次结束，指针i向后移动一位,继续计算乘积和加法，直到i与h重合，该轮乘法计算结束。<br>③ 如果运算至最高位（i与h重合）时，carry&gt;0，则需要向更高位进位，因此h向后移动。具体移动多少位，由carry的值决定(carry的值可能大于10)。</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Print_Factorial</span> <span class="hljs-params">( <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N )</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(N&lt;<span class="hljs-number">0</span>||N&gt;<span class="hljs-number">1000</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Invalid input&quot;</span>);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(N==<span class="hljs-number">0</span>||N==<span class="hljs-number">1</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-comment">//定义结果数组用于保存阶乘结果</span><br>        <span class="hljs-keyword">int</span> result[<span class="hljs-number">3000</span>]=&#123;<span class="hljs-number">0</span>&#125;;<br>        result[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> i,n,h=<span class="hljs-number">0</span>,carry=<span class="hljs-number">0</span>,outcome=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(n=<span class="hljs-number">2</span>; n&lt;=N; ++n)&#123;<br>            <span class="hljs-comment">// 当前n值与当前运算结果逐位做乘法,注意还需要加上之前得到的进位数carry</span><br>            <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;=h; ++i)&#123;<br>                outcome = result[i] * n + carry;<br>                <span class="hljs-comment">// 保存低位数字</span><br>                result[i] = outcome % <span class="hljs-number">10</span>;<br>                carry = outcome / <span class="hljs-number">10</span>;<br>            &#125;<br>            <span class="hljs-comment">// 最高位出现进位(carry&gt;0)时，需要将h向后移动一位</span><br>            <span class="hljs-keyword">for</span>(;carry;)&#123;<br>                ++h;<br>                result[h] = carry %<span class="hljs-number">10</span> ;<br>                carry /= <span class="hljs-number">10</span>;<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 由高到底逐位输出最终结果</span><br>        <span class="hljs-keyword">for</span>(i=h; i&gt;=<span class="hljs-number">0</span>; --i)&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,result[i]);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>运行结果如下：<br><img src="/2019/06/20/%E9%98%B6%E4%B9%98%E8%AE%A1%E7%AE%97%E5%8D%87%E7%BA%A7%E7%89%88/%E6%A0%B7%E4%BE%8B1.png" alt="enter description here"><br>计算1000的阶乘没有问题：<br><img src="/2019/06/20/%E9%98%B6%E4%B9%98%E8%AE%A1%E7%AE%97%E5%8D%87%E7%BA%A7%E7%89%88/%E6%A0%B7%E4%BE%8B2.png" alt="enter description here"><br>提交结果完全正确：<br><img src="/2019/06/20/%E9%98%B6%E4%B9%98%E8%AE%A1%E7%AE%97%E5%8D%87%E7%BA%A7%E7%89%88/%E6%88%90%E7%BB%A9.png" alt="enter description here"></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>乘法运算</tag>
      
      <tag>C/C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git常用命令</title>
    <link href="/2019/06/01/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <url>/2019/06/01/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="git常用命令"><a href="#git常用命令" class="headerlink" title="git常用命令"></a>git常用命令</h1><h2 id="git本地仓库"><a href="#git本地仓库" class="headerlink" title="git本地仓库"></a>git本地仓库</h2><p>初始化文件目录，在当前文件路径中添加.git文件</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">git init<br></code></pre></div></td></tr></table></figure><p>声明哪些变动需要commit    （the modification to be committed）</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">git add<br></code></pre></div></td></tr></table></figure><p><strong>.gitignore文件</strong>    文件内容表明哪些变动不需要commit    (the modification not to be committed)</p><p>示例</p><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk"><span class="hljs-regexp">/.cache/</span><br><span class="hljs-regexp">/node_modules/</span><br></code></pre></div></td></tr></table></figure><h3 id="将文件变动提交到本地仓库"><a href="#将文件变动提交到本地仓库" class="headerlink" title="将文件变动提交到本地仓库"></a>将文件变动提交到本地仓库</h3><p>将add后的变动提交到本地仓库（不常用），将目前代码复制一份到.git目录</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">git commit -m&quot;[版本描述]&quot;<br></code></pre></div></td></tr></table></figure><p>先打开代码，然后手动添加变动情况描述，最后将add后的代码提交到本地仓库——.git目录（常用）</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">git commit -v<br></code></pre></div></td></tr></table></figure><p>查看提交的所有分支的历史版本</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">git log<br></code></pre></div></td></tr></table></figure><p>查看所有分支的所有操作，包括所有commit和reset</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">git reflog<br></code></pre></div></td></tr></table></figure><h3 id="回滚版本"><a href="#回滚版本" class="headerlink" title="回滚版本"></a>回滚版本</h3><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">git reset --hard [版本号]切换代码版本<br></code></pre></div></td></tr></table></figure><p>一定要确保已经把所有add过的代码都commit了。因为这个操作会使所有add过而没有commit的文件消失。</p><p>版本号只要保证具有唯一性即可，对版本号的长度没有要求。</p><h3 id="分支操作"><a href="#分支操作" class="headerlink" title="分支操作"></a>分支操作</h3><p>创建分支x（新的时间线）</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">git branch x<br></code></pre></div></td></tr></table></figure><p>基于本地仓库里最新一次 commit（提交），创建一个新的分支 x</p><p>将当前分支切换到分支x</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">git checkout x<br></code></pre></div></td></tr></table></figure><p>切换分支的前提是，当前分支没有未commit的文件。</p><p><strong>会让当前目录的内容变成本地仓库里 x 分支的最新内容（可能会删除当前目录里的一些文件）</strong></p><p>查看当前分支情况，前面带*号的为当前所在分支</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">git branch<br></code></pre></div></td></tr></table></figure><h2 id="分支合并"><a href="#分支合并" class="headerlink" title="分支合并"></a>分支合并</h2><p>将x分支合并到当前分支</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">git merge x<br></code></pre></div></td></tr></table></figure><h3 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h3><ul><li><p>出现<strong>CONFLICT</strong>时，需要手动解决代码冲突，然后再add+commit</p></li><li><ol><li><p>使用<code>git status -sb</code>命令查看哪些文件出现冲突</p></li><li><p>次打开每个冲突文件</p></li><li><p>搜索出现====的部分</p></li><li><p>在上下个代码中手动调整需要修改的部分</p></li><li><p>删除不用的代码、&gt;&gt;&gt;&gt;、&lt;&lt;&lt;&lt;及====</p></li><li><p><code>git add</code>冲突文件</p></li><li><p>使用<code>git status -sb</code>命令查看出现冲突的文件情况，直到所有冲突全部解决完</p></li><li><p>运行<code>git commit</code></p></li><li><p>分支合并之后删除无用分支：<code>git branch -d x</code></p></li></ol></li></ul><p><strong>当误删了分支时怎么办？</strong></p><p>1.使用<code>git log -g</code> 找回之前commit分支的版本号<br>2.使用<code>git branch [自定义分支名] [分支版本号]</code>命令重新命名这个分支<br>3.检查文件是否存在</p><h2 id="push到远程仓库"><a href="#push到远程仓库" class="headerlink" title="push到远程仓库"></a>push到远程仓库</h2><h3 id="①-生成ssh-key-只做第一次，一劳永逸"><a href="#①-生成ssh-key-只做第一次，一劳永逸" class="headerlink" title="① 生成ssh key(只做第一次，一劳永逸)"></a>① 生成ssh key(只做第一次，一劳永逸)</h3><p>密钥分为公钥（id_rsa.pub）和私钥(id_rsa)</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 生成密钥</span><br>ssh-keygen -t rsa -b 4096 -c <br><span class="hljs-meta">#</span><span class="bash"> 查看公钥内容</span><br>cat ~/.ssh/id_rsa.pub<br><span class="hljs-meta">#</span><span class="bash"> 测试配置是否成功</span><br>ssh -T git@github.com<br></code></pre></div></td></tr></table></figure><p>使用ssh地址的好处是不用每次都输入密码。</p><h3 id="②-上传代码（经常做）"><a href="#②-上传代码（经常做）" class="headerlink" title="② 上传代码（经常做）"></a>② 上传代码（经常做）</h3><ol><li><p>新建GitHub repository，复制ssh地址</p></li><li><p>本地添加远程参考地址</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">git remote add origin git@xxxx<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 查看本地添加的远程仓库地址</span><br>git remote -v<br><span class="hljs-meta">#</span><span class="bash"> 删除远程仓库地址</span><br>git remote remove [name]<br></code></pre></div></td></tr></table></figure></li><li><p>(第一次)push到远程仓库</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">git push -u origin master<br></code></pre></div></td></tr></table></figure></li><li><p>(此步可能需要)当远程代码有修改时，在push之前还要进行pull操作</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">git pull origin master<br></code></pre></div></td></tr></table></figure></li><li><p>(非第一次)push</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">git push<br></code></pre></div></td></tr></table></figure></li></ol><h3 id="③-下载代码"><a href="#③-下载代码" class="headerlink" title="③ 下载代码"></a>③ 下载代码</h3><figure class="highlight crmsh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs crmsh">git <span class="hljs-keyword">clone</span> <span class="hljs-title">git</span>@xxxx<br></code></pre></div></td></tr></table></figure><h2 id="git-高级操作"><a href="#git-高级操作" class="headerlink" title="git 高级操作"></a>git 高级操作</h2><h3 id="自定义命令简写"><a href="#自定义命令简写" class="headerlink" title="自定义命令简写"></a>自定义命令简写</h3><p>举例：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">touch ~/.bashrc<br>echo &#x27;alias ga = &quot;git add&quot;&#x27; &gt;&gt; ~/.bashrc<br>source ~/.bashrc<br></code></pre></div></td></tr></table></figure><p>执行这三行代码之后就可以用 <code>ga</code> 代替 <code>git add</code>了</p><h3 id="其他高级操作"><a href="#其他高级操作" class="headerlink" title="其他高级操作"></a>其他高级操作</h3><p>将未提交的修改保存起来</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">git stash<br></code></pre></div></td></tr></table></figure><p>将保存而未提交的修改拉出来</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">git stash pop<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
