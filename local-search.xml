<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>.sync修饰符</title>
    <link href="/2021/07/15/%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BA%8B%E4%BB%B6%E4%B8%AD.sync%E4%BF%AE%E9%A5%B0%E7%AC%A6/"/>
    <url>/2021/07/15/%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BA%8B%E4%BB%B6%E4%B8%AD.sync%E4%BF%AE%E9%A5%B0%E7%AC%A6/</url>
    
    <content type="html"><![CDATA[<h1 id="sync修饰符"><a href="#sync修饰符" class="headerlink" title=".sync修饰符"></a><a href="https://cn.vuejs.org/v2/guide/components-custom-events.html#sync-%E4%BF%AE%E9%A5%B0%E7%AC%A6">.sync修饰符</a></h1><p>有时候，我们需要对组件进行双向绑定。这么做的目的时避免父组件和子组件分别改变同一个prop值而产生冲突。具体思路是，只允许子组件向父组件发出修改组件值得意图，而实际修改组件值得动作由父组件“监听-响应“动作来完成。</p><p>这个过程利用了 <code>EventBus</code> 来完成父子组件之间得通信。</p><p>而<code>.sync</code> (2.3.0+) 语法糖，会扩展成一个更新父组件绑定值的 <code>v-on</code> 侦听器。</p><h2 id="一个案例"><a href="#一个案例" class="headerlink" title="一个案例"></a>一个案例</h2><p>具体见一下例子：</p><p>App.vue：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">&lt;template&gt;<br>  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span></span><br><span class="xml">    <span class="hljs-comment">&lt;!-- 父组件可以监听那个事件并根据需要更新一个本地的数据 property --&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>爸爸计划代儿子去&#123;&#123; travelPlan &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">hr</span> /&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">child-idea</span> <span class="hljs-attr">:sendData.sync</span>=<span class="hljs-string">&quot;travelPlan&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">child-idea</span>&gt;</span></span><br><span class="xml"></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;fatherIdea&quot;</span>&gt;</span>爸爸要去<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&lt;/template&gt;<br><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="javascript"><span class="xml"><span class="hljs-keyword">import</span> childIdea <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./Child.vue&quot;</span>;</span></span><br><span class="javascript"><span class="xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="javascript"><span class="xml">  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;index&quot;</span>,</span></span><br><span class="javascript"><span class="xml">  <span class="hljs-attr">components</span>: &#123; childIdea &#125;,</span></span><br><span class="javascript"><span class="xml">  <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span> &#123;</span></span><br><span class="javascript"><span class="xml">    <span class="hljs-keyword">return</span> &#123;</span></span><br><span class="javascript"><span class="xml">      <span class="hljs-attr">travelPlan</span>: <span class="hljs-string">&quot;爬山&quot;</span>,</span></span><br><span class="javascript"><span class="xml">    &#125;;</span></span><br><span class="javascript"><span class="xml">  &#125;,</span></span><br><span class="javascript"><span class="xml">  <span class="hljs-attr">methods</span>: &#123;</span></span><br><span class="javascript"><span class="xml">    <span class="hljs-function"><span class="hljs-title">fatherIdea</span>(<span class="hljs-params"></span>)</span> &#123;</span></span><br><span class="javascript"><span class="xml">      <span class="hljs-built_in">this</span>.travelPlan = <span class="hljs-string">&quot;爬山&quot;</span>;</span></span><br><span class="javascript"><span class="xml">    &#125;,</span></span><br><span class="javascript"><span class="xml">  &#125;,</span></span><br><span class="javascript"><span class="xml">&#125;;</span></span><br><span class="javascript"><span class="xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></div></td></tr></table></figure><p>Child.vue：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">&lt;template&gt;<br>  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;child-idea&quot;</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>儿子知道爸爸要带他去:&#123;&#123; sendData &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;childSelect&quot;</span>&gt;</span>儿子要去<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&lt;/template&gt;<br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="javascript"><span class="xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="javascript"><span class="xml">  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;childIdea&quot;</span>,</span></span><br><span class="javascript"><span class="xml">  <span class="hljs-attr">props</span>: [<span class="hljs-string">&quot;sendData&quot;</span>], <span class="hljs-comment">// 用来接收父组件传给子组件的数据</span></span></span><br><span class="javascript"><span class="xml">  <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span> &#123;</span></span><br><span class="javascript"><span class="xml">    <span class="hljs-keyword">return</span> &#123;</span></span><br><span class="javascript"><span class="xml">      <span class="hljs-attr">travelSite</span>: <span class="hljs-string">`迪斯尼`</span>,</span></span><br><span class="javascript"><span class="xml">    &#125;;</span></span><br><span class="javascript"><span class="xml">  &#125;,</span></span><br><span class="javascript"><span class="xml">  <span class="hljs-attr">methods</span>: &#123;</span></span><br><span class="javascript"><span class="xml">    <span class="hljs-function"><span class="hljs-title">childSelect</span>(<span class="hljs-params"></span>)</span> &#123;</span></span><br><span class="javascript"><span class="xml">      <span class="hljs-comment">// 表达子组件要修改父组件值的意图</span></span></span><br><span class="javascript"><span class="xml">      <span class="hljs-built_in">this</span>.$emit(<span class="hljs-string">&quot;update:sendData&quot;</span>, <span class="hljs-built_in">this</span>.travelSite); </span></span><br><span class="javascript"><span class="xml">    &#125;,</span></span><br><span class="javascript"><span class="xml">  &#125;,</span></span><br><span class="javascript"><span class="xml">&#125;;</span></span><br><span class="javascript"><span class="xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></div></td></tr></table></figure><p>其中，</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">child-idea</span> <span class="hljs-attr">:sendData.sync</span>=<span class="hljs-string">&quot;travelPlan&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">child-idea</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>展开写就是</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs HTML"><span class="hljs-tag">&lt;<span class="hljs-name">child-idea</span></span><br><span class="hljs-tag">    <span class="hljs-attr">:sendData</span>=<span class="hljs-string">&quot;travelPlan&quot;</span></span><br><span class="hljs-tag">    @<span class="hljs-attr">update:sendData</span>=<span class="hljs-string">&quot;travelPlan = $event&quot;</span></span><br><span class="hljs-tag">&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">child-idea</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h2 id="Vue中的EventBus"><a href="#Vue中的EventBus" class="headerlink" title="Vue中的EventBus"></a>Vue中的EventBus</h2><p>Vue封装了 EventBus：</p><ul><li>使用 <code>$emit</code> 定义并触发事件，并传参；事件名应为：<code>update:被监听的数据名</code></li><li>使用 <code>$event</code> 来获取其他组件中 <code>$emit</code> 的参数</li></ul><p>因此父组件可以监听事件<code>&quot;update:sendData&quot;</code>并根据需要更新本地的数据 property。</p><p><a href="https://codesandbox.io/s/jovial-murdock-qm5pk">点击这里看结果</a></p><p><img src="/2021/07/15/%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BA%8B%E4%BB%B6%E4%B8%AD.sync%E4%BF%AE%E9%A5%B0%E7%AC%A6/1626454149982.png" alt="1626454149982"></p><p>vue 修饰符sync的功能是：当一个子组件改变了一个 <code>prop</code> 的值时，这个变化也会同步到父组件中所绑定。这样就避免了父组件和子组件分别改变同一个prop值而产生冲突。</p>]]></content>
    
    
    <categories>
      
      <category>vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue数据响应式</title>
    <link href="/2021/07/01/Vue%E6%95%B0%E6%8D%AE%E5%93%8D%E5%BA%94%E5%BC%8F/"/>
    <url>/2021/07/01/Vue%E6%95%B0%E6%8D%AE%E5%93%8D%E5%BA%94%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="Vue数据相应式"><a href="#Vue数据相应式" class="headerlink" title="Vue数据相应式"></a>Vue数据相应式</h1><p>Vue数据相应式：就是当修改普通JavaScript对象时，视图（view）会进行更新。</p><h2 id="响应式系统"><a href="#响应式系统" class="headerlink" title="响应式系统"></a>响应式系统</h2><p><img src="/2021/07/01/Vue%E6%95%B0%E6%8D%AE%E5%93%8D%E5%BA%94%E5%BC%8F/1625895230359.png" alt="1625895230359"></p><p>当把一个普通的 JavaScript 对象传入 Vue 实例作为 <code>data</code> 选项，Vue 将遍历此对象所有的 property，并使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty"><code>Object.defineProperty</code></a> 把这些 property 全部转为 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Working_with_Objects#%E5%AE%9A%E4%B9%89_getters_%E4%B8%8E_setters">getter/setter</a>。</p><p>这些 getter/setter 对用户来说是不可见的，但是在内部它们让 Vue 能够追踪依赖，在 property 被访问和修改时通知变更。</p><p>具体来说，</p><ul><li>当执行get()响应时，会调用<code>dep.depend()</code>，此函数将target对象push进<strong>监听队列</strong>（subscris），然后读取property。</li><li>当执行set()响应时，会先拿到新值，然后调用<code>dep.notify()</code>，此函数执行监听队列中的每个target，重新更新。</li></ul><p>每个组件实例都对应一个 <strong>watcher</strong> 实例，它会在组件渲染的过程中把“接触（Touch）”过的数据 property 记录为依赖。之后当依赖项的 setter 触发时，会通知 watcher，从而使它关联的组件重新渲染。</p><p>举例：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> target, total<br><span class="hljs-keyword">let</span> data = &#123;<span class="hljs-attr">price</span>:<span class="hljs-number">5</span>, <span class="hljs-attr">quantity</span>:<span class="hljs-number">2</span>&#125;<br><br><span class="hljs-comment">// 定义依赖（dependency-tracking）。</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dep</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-built_in">this</span>.subscribers= []<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">depend</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-comment">// 存储被监听对象target</span><br>        <span class="hljs-keyword">if</span>(target &amp;&amp; !<span class="hljs-built_in">this</span>.subscribers.includes(target))&#123;<br>            <span class="hljs-built_in">this</span>.subscribers.push(target)<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">notify</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-comment">// 更新target</span><br>        <span class="hljs-built_in">this</span>.subscribers.forEach(<span class="hljs-function"><span class="hljs-params">sub</span> =&gt;</span> sub())<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 建立依赖（dependency-tracking）。在 property 被访问和修改时通知变更。</span><br><span class="hljs-built_in">Object</span>.keys(data).forEach(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span>&#123;<br>    <span class="hljs-keyword">let</span> internalValue = data[key]<br><br>    <span class="hljs-keyword">const</span> dep = <span class="hljs-keyword">new</span> Dep()<br><br>    <span class="hljs-comment">// 异步函数</span><br>    <span class="hljs-built_in">Object</span>.defineProperty(data, key, &#123;<br>        <span class="hljs-function"><span class="hljs-title">get</span>(<span class="hljs-params"></span>)</span>&#123;<br>            dep.depend()<br>            <span class="hljs-keyword">return</span> internalValue<br>        &#125;,<br>        <span class="hljs-function"><span class="hljs-title">set</span>(<span class="hljs-params">newValue</span>)</span>&#123;<br>            internalValue = newValue<br>            dep.notify()<br>        &#125;<br>    &#125;)<br>&#125;)<br><br><span class="hljs-comment">// 观察者函数（极简化版）</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">watcher</span>(<span class="hljs-params">myFunc</span>)</span>&#123;<br>    <span class="hljs-comment">// 监听和执行target</span><br>    target = myFunc<br>    target()<br>    target = <span class="hljs-literal">null</span><br>    <br>    <span class="hljs-comment">// ...记录依赖</span><br>    <span class="hljs-comment">// ...Trigger re-render重新渲染</span><br>&#125;<br><br>watcher(<span class="hljs-function">()=&gt;</span>&#123;<br>    total = data.price * data.quantity<br>&#125;)<br></code></pre></div></td></tr></table></figure><p>测试：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 测试</span><br><span class="hljs-built_in">console</span>.log(data.price)<span class="hljs-comment">//5</span><br><span class="hljs-built_in">console</span>.log(data.quantity)<span class="hljs-comment">//2</span><br><span class="hljs-built_in">console</span>.log(total)<span class="hljs-comment">//10</span><br><br>data.price=<span class="hljs-number">10</span><br><br><span class="hljs-built_in">console</span>.log(total)<span class="hljs-comment">//20</span><br><span class="hljs-comment">// 修改data.price之后，total自动更新了</span><br></code></pre></div></td></tr></table></figure><h2 id="异步更新队列"><a href="#异步更新队列" class="headerlink" title="异步更新队列"></a>异步更新队列</h2><p>上面例子中，watcher被极度简化。实际上，Vue 在更新 DOM 时是<strong>异步</strong>执行的。<strong>只要侦听到数据变化，Vue 将开启一个队列，并buffer在同一事件循环中发生的所有数据变更。</strong>如果同一个 watcher 被多次触发，只会被推入到队列中一次（数据去重），避免不必要的计算和 DOM 操作。然后，在下一个的事件循环“tick”中，Vue 刷新队列。</p><p>具体见一下例子：</p><p><a href="https://jsbin.com/mocotic/edit?html,js,output">https://jsbin.com/mocotic/edit?html,js,output</a></p><p>html:</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">span-a</span>&gt;</span><br>      &#123;&#123;obj.a&#125;&#125; <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">span-b</span>&gt;</span><br>      &#123;&#123;obj.b&#125;&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>JavaScript：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> app = <span class="hljs-keyword">new</span> Vue(&#123;<br>  <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#app&#x27;</span>,<br>  <span class="hljs-attr">data</span>: &#123;<br>    <span class="hljs-attr">obj</span>: &#123;<br>      <span class="hljs-attr">a</span>: <span class="hljs-string">&#x27;a&#x27;</span>,<br>    &#125;<br>  &#125;,<br>&#125;)<br><br>app.obj.b = <span class="hljs-string">&#x27;addB&#x27;</span><br><br><span class="hljs-comment">// oupput：a</span><br></code></pre></div></td></tr></table></figure><p>因为 b 一开始不是 obj 的 key，所以 Vue 并没有监听 b。所以即使 b 的值变了，视图也不会更新。</p><p>JavaScript:</p><figure class="highlight stylus"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stylus"><span class="hljs-selector-tag">var</span> app = new Vue(&#123;<br>  el: <span class="hljs-string">&#x27;#app&#x27;</span>,<br>  data: &#123;<br>    obj: &#123;<br>      <span class="hljs-selector-tag">a</span>: <span class="hljs-string">&#x27;a&#x27;</span>,<br>    &#125;<br>  &#125;,<br>&#125;)<br><br>app<span class="hljs-selector-class">.obj</span><span class="hljs-selector-class">.a</span> = <span class="hljs-string">&#x27;newA&#x27;</span><br>app<span class="hljs-selector-class">.obj</span><span class="hljs-selector-class">.b</span> = <span class="hljs-string">&#x27;addB&#x27;</span><br><br><span class="hljs-comment">// oupput：newA addB</span><br></code></pre></div></td></tr></table></figure><p>由于更新DOM过程是<strong>异步</strong>的。当更新a属性时，Vue监听到变化，先是开启了一个新的监听队列，将更新任务push到新的更新队列里。等到代码运行完毕，再更新DOM。此时页面展示的就是所有的跟新的数据。</p>]]></content>
    
    
    <categories>
      
      <category>vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue计算属性（computed）和侦听器（watcher）</title>
    <link href="/2021/06/30/Vue%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%EF%BC%88computed%EF%BC%89%EF%BC%89%E5%92%8C%E4%BE%A6%E5%90%AC%E5%99%A8%E4%BE%A6%E5%90%AC%E5%99%A8%EF%BC%88watcher%EF%BC%89/"/>
    <url>/2021/06/30/Vue%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%EF%BC%88computed%EF%BC%89%EF%BC%89%E5%92%8C%E4%BE%A6%E5%90%AC%E5%99%A8%E4%BE%A6%E5%90%AC%E5%99%A8%EF%BC%88watcher%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="Vue计算属性（computed）和侦听器（watcher）"><a href="#Vue计算属性（computed）和侦听器（watcher）" class="headerlink" title="Vue计算属性（computed）和侦听器（watcher）"></a>Vue计算属性（computed）和侦听器（watcher）</h1><h2 id="computed属性-API-—-Vue-js-vuejs-org"><a href="#computed属性-API-—-Vue-js-vuejs-org" class="headerlink" title="[computed属性](API — Vue.js (vuejs.org))"></a>[computed属性](<a href="https://cn.vuejs.org/v2/api/#computed">API — Vue.js (vuejs.org)</a>)</h2><blockquote><p>计算属性将被混入到 Vue 实例中。所有 getter 和 setter 的 this 上下文自动地绑定为 Vue 实例。</p><p>注意如果你为一个计算属性使用了箭头函数，则 <code>this</code> 不会指向这个组件的实例，不过你<strong>仍然可以</strong>将其实例作为函数的第一个参数来访问。</p><p>计算属性的结果会被缓存，除非依赖的响应式 property 变化才会重新计算。注意，如果某个依赖 (比如非响应式 property) 在该实例范畴之外，则计算属性是<strong>不会</strong>被更新的。</p></blockquote><p>举例：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;example&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Original message: &quot;&#123;&#123; message &#125;&#125;&quot;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Computed reversed message: &quot;&#123;&#123; reversedMessage &#125;&#125;&quot;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></div></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> Vue(&#123;<br>  <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#example&#x27;</span>,<br>  <span class="hljs-attr">data</span>: &#123;<br>    <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;Hello&#x27;</span>,<br>    <span class="hljs-attr">reverse</span>: <span class="hljs-literal">false</span><br>  &#125;,<br>  <span class="hljs-attr">computed</span>: &#123;<br>    <span class="hljs-attr">rev</span>: <span class="hljs-function"><span class="hljs-params">vm</span> =&gt;</span> vm.message.split(<span class="hljs-string">&#x27;&#x27;</span>).reverse().join(<span class="hljs-string">&#x27;&#x27;</span>),<br>    <span class="hljs-attr">reversedMessage</span>:&#123;<br>      <span class="hljs-function"><span class="hljs-title">get</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.rev<br>      &#125;,<br>      <span class="hljs-function"><span class="hljs-title">set</span>(<span class="hljs-params"></span>)</span>&#123;&#125;<br>    &#125;<br>  &#125;<br>&#125;)<br></code></pre></div></td></tr></table></figure><p>结果：</p><p>Original message: “Hello”</p><p>Computed reversed message: “olleH”</p><h2 id="watch属性-API-—-Vue-js-vuejs-org"><a href="#watch属性-API-—-Vue-js-vuejs-org" class="headerlink" title="[watch属性](API — Vue.js (vuejs.org))"></a>[watch属性](<a href="https://cn.vuejs.org/v2/api/#watch">API — Vue.js (vuejs.org)</a>)</h2><blockquote><p>methods 将被混入到 Vue 实例中。可以直接通过 VM 实例访问这些方法，或者在指令表达式中使用。方法中的 <code>this</code> 自动绑定为 Vue 实例。</p><p>注意，<strong>不应该使用箭头函数来定义 method 函数</strong> (例如 <code>plus: () =&gt; this.a++</code>)。理由是箭头函数绑定了父级作用域的上下文，所以 <code>this</code> 将不会按照期望指向 Vue 实例，<code>this.a</code> 将是 undefined。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">new</span> Vue(&#123;<br>  <span class="hljs-attr">data</span>: &#123;<br>    <span class="hljs-attr">n</span>: <span class="hljs-number">0</span>,<br>    <span class="hljs-attr">history</span>: [],<br>    <span class="hljs-attr">inUndoMode</span>: <span class="hljs-literal">false</span><br>  &#125;,<br>  <span class="hljs-attr">watch</span>: &#123;<br>    <span class="hljs-attr">n</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">newValue, oldValue</span>) </span>&#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.inUndoMode?<span class="hljs-string">&quot;正在撤销&quot;</span>:<span class="hljs-string">&#x27;&#x27;</span>);<br>      <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.inUndoMode) &#123;<br>        <span class="hljs-built_in">this</span>.history.push(&#123; <span class="hljs-attr">from</span>: oldValue, <span class="hljs-attr">to</span>: newValue &#125;);<br>      &#125;<br>    &#125;<br>  &#125;,<br>  <span class="hljs-comment">// 不如用 computed 来计算 displayName</span><br>  <span class="hljs-attr">template</span>: <span class="hljs-string">`</span><br><span class="hljs-string">    &lt;div&gt;</span><br><span class="hljs-string">      &#123;&#123;n&#125;&#125;</span><br><span class="hljs-string">      &lt;hr /&gt;</span><br><span class="hljs-string">      &lt;button @click=&quot;add1&quot;&gt;+1&lt;/button&gt;</span><br><span class="hljs-string">      &lt;hr/&gt;</span><br><span class="hljs-string">      &lt;button @click=&quot;undo&quot;&gt;撤销&lt;/button&gt;</span><br><span class="hljs-string">      &lt;hr/&gt;</span><br><span class="hljs-string"></span><br><span class="hljs-string">      &#123;&#123;history&#125;&#125;</span><br><span class="hljs-string">    &lt;/div&gt;</span><br><span class="hljs-string">  `</span>,<br>  <span class="hljs-attr">methods</span>: &#123;<br>    <span class="hljs-function"><span class="hljs-title">add1</span>(<span class="hljs-params"></span>)</span> &#123;<br>      <span class="hljs-built_in">this</span>.n += <span class="hljs-number">1</span>;<br>    &#125;,<br>    <span class="hljs-function"><span class="hljs-title">undo</span>(<span class="hljs-params"></span>)</span> &#123;<br>      <span class="hljs-keyword">const</span> last = <span class="hljs-built_in">this</span>.history.pop()<br>      <span class="hljs-built_in">console</span>.log(last)<br>      <span class="hljs-built_in">this</span>.inUndoMode = <span class="hljs-literal">true</span><br>      <span class="hljs-built_in">this</span>.n = last.from;<br>      <span class="hljs-built_in">this</span>.$nextTick(<span class="hljs-function">()=&gt;</span>&#123;<br>        <span class="hljs-built_in">this</span>.inUndoMode = <span class="hljs-literal">false</span><br>      &#125;,<span class="hljs-number">0</span>) <br>    &#125;<br>  &#125;<br>&#125;).$mount(<span class="hljs-string">&quot;#app&quot;</span>);<br><br></code></pre></div></td></tr></table></figure><p>测试：<a href="https://codesandbox.io/s/lucid-shamir-cpcw3?file=/src/main.js:89-1118">lucid-shamir-cpcw3 - CodeSandbox</a></p>]]></content>
    
    
    <categories>
      
      <category>vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入理解MVC</title>
    <link href="/2021/06/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3MVC/"/>
    <url>/2021/06/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3MVC/</url>
    
    <content type="html"><![CDATA[<h1 id="深入理解MVC"><a href="#深入理解MVC" class="headerlink" title="深入理解MVC"></a>深入理解MVC</h1><h2 id="MVC的三个对象"><a href="#MVC的三个对象" class="headerlink" title="MVC的三个对象"></a>MVC的三个对象</h2><p><strong>MVC</strong> **(Model-View-Controller)**是一种软件设计模式，它把软件设计分成三大模块：模型（Model）、视图（View）、控制器（Controller）。这样重构的代码：</p><ol><li>简化了后续对程序的修改和扩展简化，避免出现<em>意大利面条式</em>的代码</li><li>并使某一部分代码能够重复利用</li><li>同时，这一设计模式通过对复杂度的简化，使程序结构更加直观易于理解和维护。</li></ol><ul><li><strong>模型（Model）</strong> - 负责存放和处理（增删改查）数据。一般与Conterller存在耦合，M从<code>服务器</code>拿到数据后一般会通过<strong>eventBus</strong>传给Controller</li></ul><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> $ <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;jquery&#x27;</span>;<br><br><span class="hljs-keyword">const</span> eventBus = $(<span class="hljs-built_in">window</span>);<br><br><span class="hljs-keyword">const</span> m = &#123;<br>    <span class="hljs-comment">// 服务器获得的数据</span><br>    <span class="hljs-attr">data</span>:&#123;&#125;,<br>    <span class="hljs-comment">// 对数据进行增删改查</span><br>    <span class="hljs-function"><span class="hljs-title">create</span>(<span class="hljs-params"></span>)</span>&#123;&#125;,<br>    <span class="hljs-function"><span class="hljs-title">delete</span>(<span class="hljs-params"></span>)</span>&#123;&#125;,<br>    <span class="hljs-function"><span class="hljs-title">update</span>(<span class="hljs-params">data</span>)</span>&#123;<br>        <span class="hljs-comment">/* 调用m.update()时，通过eventBus.trigger()触发事件，而Conterller通过</span><br><span class="hljs-comment">        eventBus.on()来监听这个事件，以实现对象间通信 */</span><br>        <span class="hljs-built_in">Object</span>.assign(m.data, data);<span class="hljs-comment">//将data全部拷贝/覆盖给m.data</span><br>        eventBus.trigger(<span class="hljs-string">&#x27;m已更新&#x27;</span>);<span class="hljs-comment">//触发‘m已更新’这个事件</span><br>    &#125;,<br>    <span class="hljs-function"><span class="hljs-title">get</span>(<span class="hljs-params"></span>)</span>&#123;&#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><ul><li><strong>视图（View）</strong> - 负责所有UI界面</li></ul><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> v = &#123;<br>    <span class="hljs-attr">el</span>: <span class="hljs-literal">null</span>,<span class="hljs-comment">//待渲染元素</span><br>    <span class="hljs-attr">html</span>: <span class="hljs-string">`&lt;!--  要显示浏览器页面的内容  --&gt;`</span>,<br>    <span class="hljs-function"><span class="hljs-title">init</span>(<span class="hljs-params">container</span>)</span>&#123;<br>        <span class="hljs-comment">// 初始化带渲染元素</span><br>        v.el = $(container);<br>    &#125;,<br>    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params">data</span>)</span>&#123;<br>        <span class="hljs-comment">// 渲染元素</span><br>        <span class="hljs-keyword">if</span>(v.el.children) v.el.empty();   <span class="hljs-comment">// 如果v.el原来有内容，则先清空</span><br>        <span class="hljs-comment">//...然后重新渲染v.el</span><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><ul><li><strong>控制器（Controller）</strong>- 负责监听和处理View事件，同时监听Model数据变化（通过<strong>eventBus</strong>）</li></ul><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> c = &#123;<br>    <span class="hljs-function"><span class="hljs-title">init</span>(<span class="hljs-params">el</span>)</span>&#123;<br>        v.init(el);<br>        <span class="hljs-comment">// 第一次渲染</span><br>        v.render(data);<span class="hljs-comment">/* view = render(data)方式让render只在</span><br><span class="hljs-comment">        该更新的地方更新 */</span> <br>        c.autoBindEvents();<br>        eventBus.on(<span class="hljs-string">&#x27;m已更新&#x27;</span>,<span class="hljs-function">()=&gt;</span>&#123;<br>           <span class="hljs-comment">// eventBus监听‘m已更新’事件，每当该事件触发，就重新渲染</span><br>           v.render(data); <br>        &#125;);<br>    &#125;,<br>    <span class="hljs-attr">events</span>:&#123; <span class="hljs-comment">/* 一般使用哈希表存储 */</span> &#125;,<br>    <span class="hljs-function"><span class="hljs-title">method</span>(<span class="hljs-params"></span>)</span>&#123;&#125;,<br>    <span class="hljs-function"><span class="hljs-title">autoBindEvents</span>(<span class="hljs-params"></span>)</span>&#123;&#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>由于，v和c耦合度较高，一般将二者合为一个对象<strong>View</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> $ <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;jquery&#x27;</span>;<br><br><span class="hljs-keyword">const</span> eventBus = $(<span class="hljs-built_in">window</span>);<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">View</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">eventBus</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">options</span>)</span> &#123;<br>        <span class="hljs-built_in">super</span>();<span class="hljs-comment">/* 调用 super()会调用父类构造函数，并将返回的实例</span><br><span class="hljs-comment">        赋值给 this。不能在调用 super()之前引用 this。 */</span><br>        <span class="hljs-built_in">Object</span>.assign(<span class="hljs-built_in">this</span>,options);<br><br>        <span class="hljs-built_in">this</span>.el = $(<span class="hljs-built_in">this</span>.el);<br>        <span class="hljs-built_in">this</span>.render(<span class="hljs-built_in">this</span>.data);<br>        <span class="hljs-built_in">this</span>.autoBindEvents();<br>        <span class="hljs-built_in">this</span>.on(<span class="hljs-string">&#x27;m已更新&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-comment">// 继承eventBus的on方法</span><br>            <span class="hljs-built_in">this</span>.render(<span class="hljs-built_in">this</span>.data);<br>        &#125;);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-title">autoBindEvents</span>(<span class="hljs-params"></span>)</span> &#123;&#125;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> View;<br></code></pre></div></td></tr></table></figure><h2 id="EventBus-实现对象间通信"><a href="#EventBus-实现对象间通信" class="headerlink" title="EventBus 实现对象间通信"></a>EventBus 实现对象间通信</h2><p>EventBus就是一个以事件为驱动的消息服务总线，用来实现组件/对象之间的通信。</p><p>这样做的原理是：EventBus有三个关键的 API：on（监听事件），trigger（触发事件）或$emit（vue中）,off（取消监听)</p><p>以上c和m之间的通信就是使用EventBus的一个例子。</p><p>实际工作中一般不用<code>const eventBus = $(window);</code>，因为这样写不利于调用和后期代码维护。一般单独封装一个EventBus类进行解耦。</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> $ <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;jquery&quot;</span>;<br><br><span class="hljs-comment">//解耦EventBus</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EventBus</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-built_in">this</span>._eventBus = $(<span class="hljs-built_in">window</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-title">on</span>(<span class="hljs-params">eventName, fn</span>)</span> &#123;<br>        <span class="hljs-keyword">return</span>  <span class="hljs-built_in">this</span>._eventBus.on(eventName, fn);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-title">trigger</span>(<span class="hljs-params">eventName, fn</span>)</span> &#123;<br>       <span class="hljs-keyword">return</span>  <span class="hljs-built_in">this</span>._eventBus.trigger(eventName, fn);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-title">off</span>(<span class="hljs-params">eventName, fn</span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>._eventBus.off(eventName, fn);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> EventBus;<br></code></pre></div></td></tr></table></figure><h2 id="表驱动编程（Table-Driven-Approach）"><a href="#表驱动编程（Table-Driven-Approach）" class="headerlink" title="表驱动编程（Table-Driven Approach）"></a>表驱动编程（Table-Driven Approach）</h2><p>首先看一段冗余代码：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> $ <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;jquery&quot;</span>;<br><br><span class="hljs-keyword">const</span> testEl = $(<span class="hljs-built_in">window</span>);<br><br><span class="hljs-keyword">const</span> v = &#123;<br>    <span class="hljs-attr">el</span>: testEl,<br>    <span class="hljs-function"><span class="hljs-title">bindEvents</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-comment">// 重复代码过多</span><br>        v.cntnr.on(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-string">&quot;#add1&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>            data += <span class="hljs-number">1</span>;<br>        &#125;);<br><br>        v.cntnr.on(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-string">&quot;#minus1&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>            data -= <span class="hljs-number">1</span>;<br>        &#125;);<br><br>        v.cntnr.on(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-string">&quot;#multiply2&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>            data &lt;&lt;= <span class="hljs-number">1</span>;<br>        &#125;);<br>        v.cntnr.on(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-string">&quot;#divide2&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>            data &gt;&gt;= <span class="hljs-number">1</span>;<br>        &#125;);<br>    &#125;<br>&#125;;<br><br>v.bindEvents();<br></code></pre></div></td></tr></table></figure><p>以上这种绑定事件的方法有如下缺点：</p><ol><li>代码重复性：bindEvents方法明显存在大量重复代码，可以进一步提炼</li><li>可扩展性差：如果改变事件响应函数，就要改变bindEvents()方法，非常不方便</li><li>代码多的时候，不易读，主要程序逻辑被淹没在一些没用的冗余代码中</li></ol><p>表驱动编程：</p><p>为解决上面这些问题，可以将代码发生变化的那一部分（一般是数据部分）放到表中，一般使用哈希表。而其他不变的部分（一般是逻辑部分），单独封装。这样后期维护只需要对表进行响应修改即可。</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> $ <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;jquery&quot;</span>;<br><br><span class="hljs-keyword">const</span> testEl = $(<span class="hljs-built_in">window</span>);<br><br><span class="hljs-keyword">const</span> v = &#123;<br>    <span class="hljs-attr">el</span>:testEl,<br>    <span class="hljs-attr">events</span>:&#123;<br>    <span class="hljs-comment">// 数据部分（变化的部分）</span><br>        <span class="hljs-string">&#x27;click #add1&#x27;</span>: <span class="hljs-string">&#x27;add&#x27;</span>,<br>        <span class="hljs-string">&#x27;click #minus1&#x27;</span>: <span class="hljs-string">&#x27;minus&#x27;</span>,<br>        <span class="hljs-string">&#x27;click #mul2&#x27;</span>: <span class="hljs-string">&#x27;mul&#x27;</span>,<br>        <span class="hljs-string">&#x27;click #divide2&#x27;</span>: <span class="hljs-string">&#x27;divide&#x27;</span>,<br>&#125;,<br>        <br>    <span class="hljs-comment">// 逻辑部分（不变的部分）</span><br>    <span class="hljs-function"><span class="hljs-title">add</span>(<span class="hljs-params"></span>)</span> &#123;<br>        data += <span class="hljs-number">1</span>;<br>    &#125;,<br>    <span class="hljs-function"><span class="hljs-title">minus</span>(<span class="hljs-params"></span>)</span> &#123;<br>        data -= <span class="hljs-number">1</span>;<br>    &#125;,<br>    <span class="hljs-function"><span class="hljs-title">mul</span>(<span class="hljs-params"></span>)</span> &#123;<br>        data &lt;&lt;= <span class="hljs-number">1</span>;<br>    &#125;,<br>    <span class="hljs-function"><span class="hljs-title">divide</span>(<span class="hljs-params"></span>)</span> &#123;<br>        data &gt;&gt;= <span class="hljs-number">1</span>;<br>    &#125;,<br>    <span class="hljs-function"><span class="hljs-title">autoBindEvents</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> v.events)&#123;<br>            <span class="hljs-keyword">const</span> value = v[v.events[key]];<br>            <span class="hljs-keyword">const</span> spaceIndex = key.indexOf(<span class="hljs-string">&#x27; &#x27;</span>);<br>            <span class="hljs-keyword">const</span> part1 = key.slice(<span class="hljs-number">0</span>,spaceIndex);<br>            <span class="hljs-keyword">const</span> part2 = key.slice(spaceIndex+<span class="hljs-number">1</span>);<br>            v.el.on(part1,part2,value);<br>        &#125;<br>&#125;<br>&#125;;<br>    <br>v.autoBindEvents();<br></code></pre></div></td></tr></table></figure><p>表驱动编程的意义在于实现了<strong>逻辑与数据的分离。</strong></p><p>相应的，表驱动编程有以下<strong>优点</strong>：</p><ol><li>提高代码可读性。代码简化到：只需要看“表”，就能知道程序是干什么的。</li><li>减少重复代码</li><li>增加代码可扩展性，比较方便。同时更易于控制复杂度</li></ol><h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><p>模块化是指解决一个复杂问题时自顶向下逐层把系统划分成若干模块的过程，有多种属性，分别反映其内部特性。模块化设计，简单地说就是程序的编写不是一开始就逐条录入计算机语句和指令，而是首先用主程序、子程序、子过程等框架把软件的主要结构和流程描述出来，并定义和调试好各个框架之间的输入、输出链接关系逐步求精的结果是得到一系列以功能块为单位的算法描述。以功能块为单位进行程序设计，实现其求解算法的方法称为模块化。</p><p>模块化的<strong>目的</strong>是为了降低程序复杂度，使程序设计、调试和维护等操作简单化。</p><p>以上封装m、v、c，解耦EventBus，以及表驱动编程的例子都体现了模块化的思想。</p><p>模块化具有以下<strong>优点</strong>：</p><ol><li><p>控制了程序设计的复杂性。</p></li><li><p>提高了代码的重用性。</p></li><li><p>易于维护和功能扩充。</p></li><li><p>有利于团队开发。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>跨域</title>
    <link href="/2021/06/20/%E8%B7%A8%E5%9F%9F/"/>
    <url>/2021/06/20/%E8%B7%A8%E5%9F%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h1><h2 id="同源"><a href="#同源" class="headerlink" title="同源"></a>同源</h2><p><strong>同源</strong>：如果两个 URL 的 <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Protocol">protocol</a>、<a href="https://developer.mozilla.org/en-US/docs/Glossary/Port">port (en-US)</a> (如果有指定的话)和 <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Host">host</a> <strong>都相同</strong>的话，则这两个 URL 是<em>同源</em>。</p><p><strong>同源策略</strong>是一个重要的安全策略，它用于限制一个<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Origin">origin</a>的文档或者它加载的脚本如何能与另一个源的资源进行交互。</p><p>目的：它能帮助阻隔恶意文档，减少可能被攻击的媒介。</p><p>当两个URL的协议，或端口，或主机（域名）不同时，都不构成同源，此时无法进行资源交流。</p><p>这个方案也被称为“协议/主机/端口元组”，或者直接是 “元组”。（“元组” 是指一组项目构成的整体，双重/三重/四重/五重/等的通用形式）。</p><h2 id="跨域-1"><a href="#跨域-1" class="headerlink" title="跨域"></a>跨域</h2><p>目前，如果非同源，共有三种行为受到限制。</p><blockquote><p>（1） Cookie、LocalStorage 和 IndexDB 无法读取。</p><p>（2） DOM 无法获得。</p><p>（3） AJAX 请求不能发送。</p></blockquote><p>虽然这些限制是必要的，但是有时很不方便，合理的用途也受到影响。下面，我将详细介绍，如何规避上面三种限制。</p><p>若要实现服务器与客户端间的跨域通信，可以使用JSONP和CORS两种方法。</p><h2 id="JSONP跨域"><a href="#JSONP跨域" class="headerlink" title="JSONP跨域"></a>JSONP跨域</h2><p>JSONP基本思想是，网页通过添加一个<code>&lt;script&gt;</code>元素，向服务器请求JSON数据，这种做法不受同源政策限制；服务器收到请求后，将数据放在一个指定名字的回调函数里传回来。</p><p>具体地，在某些浏览器不支持cors进行跨域时，通过请求一个js文件，在这个js文件中执行一个回调，而回调中有我们需要的跨域数据。其中，回调的名字可以使用random随机生成，这个名字以callback参数传给后台，后台将函数返回并执行。</p><p><strong>jsonp的优点</strong></p><p>①兼容ie</p><p>②可以实现跨域</p><p><strong>jsonp的缺点</strong></p><p>①由于jsonp使用<code>&lt;script&gt;</code>标签，它无法像Ajax那样能读到精确状态码，也无法读到响应头，而只知道请求成功失败状态；</p><p>②script标签只能发送get请求，不支持post请求</p><h2 id="CORS（Cross-origin-resource-sharing）"><a href="#CORS（Cross-origin-resource-sharing）" class="headerlink" title="CORS（Cross-origin resource sharing）"></a>CORS（Cross-origin resource sharing）</h2><p>CORS是跨源资源分享（Cross-Origin Resource Sharing）的缩写。它是W3C标准，是跨源AJAX请求的根本解决方法。相比JSONP只能发<code>GET</code>请求，<strong>CORS允许任何类型的请求</strong>。</p><p>它允许浏览器向跨源服务器，发出<a href="https://www.ruanyifeng.com/blog/2012/09/xmlhttprequest_level_2.html"><code>XMLHttpRequest</code></a>请求，从而克服了AJAX只能<a href="https://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html">同源</a>使用的限制。</p><p>浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。</p><h3 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h3><p>只要同时满足以下两大条件，就属于简单请求。</p><blockquote><p>（1) 请求方法是以下三种方法之一：</p><ul><li>HEAD</li><li>GET</li><li>POST</li></ul><p>（2）HTTP的头信息不超出以下几种字段：</p><ul><li>Accept</li><li>Accept-Language</li><li>Content-Language</li><li>Last-Event-ID</li><li>Content-Type：只限于三个值<code>application/x-www-form-urlencoded</code>、<code>multipart/form-data</code>、<code>text/plain</code></li></ul></blockquote><p>对于简单请求，浏览器直接发出CORS请求。具体来说，就是在头信息之中，增加一个<code>Origin</code>字段。</p><p><strong>（1）Access-Control-Allow-Origin</strong></p><p>该字段是<strong>必须的</strong>。它的值要么是请求时<code>Origin</code>字段的值，要么是一个<code>*</code>，表示接受任意域名的请求。</p><p><strong>（2）Access-Control-Allow-Credentials</strong></p><p>该字段可选。它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为<code>true</code>，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为<code>true</code>，如果服务器不要浏览器发送Cookie，删除该字段即可。</p><p><strong>（3）Access-Control-Expose-Headers</strong></p><p>该字段可选。CORS请求时，<code>XMLHttpRequest</code>对象的<code>getResponseHeader()</code>方法只能拿到6个基本字段：<code>Cache-Control</code>、<code>Content-Language</code>、<code>Content-Type</code>、<code>Expires</code>、<code>Last-Modified</code>、<code>Pragma</code>。如果想拿到其他字段，就必须在<code>Access-Control-Expose-Headers</code>里面指定。上面的例子指定，<code>getResponseHeader(&#39;FooBar&#39;)</code>可以返回<code>FooBar</code>字段的值。</p><h3 id="非简单请求"><a href="#非简单请求" class="headerlink" title="非简单请求"></a>非简单请求</h3><p>非简单请求是那种对服务器有特殊要求的请求，比如请求方法是<code>PUT</code>或<code>DELETE</code>，或者<code>Content-Type</code>字段的类型是<code>application/json</code>。</p><p>非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为”预检”请求（preflight）。</p><p>浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的<code>XMLHttpRequest</code>请求，否则就报错。</p><p>非简单请求具体见MDN：<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS#%E9%A2%84%E6%A3%80%E8%AF%B7%E6%B1%82">跨源资源共享（CORS） - HTTP | MDN (mozilla.org)</a></p><h3 id="CORS与JSONP的比较"><a href="#CORS与JSONP的比较" class="headerlink" title="CORS与JSONP的比较"></a>CORS与JSONP的比较</h3><p>CORS与JSONP的使用目的相同，但是比JSONP更强大。</p><p>JSONP只支持<code>GET</code>请求，CORS支持所有类型的HTTP请求。JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。</p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>this和call/apply/bind</title>
    <link href="/2021/06/06/this%E5%92%8Ccall%E3%80%81apply%E3%80%81bind/"/>
    <url>/2021/06/06/this%E5%92%8Ccall%E3%80%81apply%E3%80%81bind/</url>
    
    <content type="html"><![CDATA[<h1 id="this和call-apply-bind"><a href="#this和call-apply-bind" class="headerlink" title="this和call/apply/bind"></a>this和call/apply/bind</h1><p>概括的说，call、apply、bind的用途是指定函数调用时所引用上下文对象（context object）的值，即<strong>this的值</strong>。</p><h2 id="深入理解this"><a href="#深入理解this" class="headerlink" title="深入理解this"></a>深入理解this</h2><h3 id="普通函数的this"><a href="#普通函数的this" class="headerlink" title="普通函数的this"></a>普通函数的this</h3><p>在最普通的函数调用中，this引用的是把函数当成方法调用的上下文对象，此时this值就是window。或者说，在网页的全局上下文中调用函数时，this指向window。</p><p>举例：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> hero = <span class="hljs-string">&#x27;Jackie Chan&#x27;</span>;<br><span class="hljs-comment">//window.hero = &#x27;Jackie Chan&#x27;;</span><br><br><span class="hljs-keyword">let</span> person = &#123;<br>    <span class="hljs-attr">hero</span>:<span class="hljs-string">&#x27;Eason Chan&#x27;</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myHero</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.hero;<br>&#125;<br><br>myHero();<span class="hljs-comment">//&#x27;Jackie Chan&#x27;</span><br><br>person.myHero = myHero;<br>person.myHero();<span class="hljs-comment">//&#x27;Eason Chan&#x27;</span><br></code></pre></div></td></tr></table></figure><p>定义在全局上下文中的函数 <code>myHero()</code>引用了 <code>this</code> 对象。这个 this 到底引用哪个对象必须到<br>函数被调用时才能确定。 </p><p>若想只调用<code>myHero()</code>就得到person.hero值，则可以使用call设定this指向：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs JavaScript">myhero();<span class="hljs-comment">//&#x27;Jackie Chan&#x27;</span><br>myHero.call(person,);<span class="hljs-comment">//&#x27;Eason Chan&#x27;</span><br><br>myHero.call(<span class="hljs-literal">null</span>,);<span class="hljs-comment">//&#x27;Jackie Chan&#x27;</span><br>myHero.call(<span class="hljs-literal">undefined</span>,);<span class="hljs-comment">//&#x27;Jackie Chan&#x27;</span><br>myHero.call(<span class="hljs-string">&#x27;&#x27;</span>,);<span class="hljs-comment">//undefined</span><br>...<br>myHero.call([其他falsy值],);  <span class="hljs-comment">//undefined</span><br></code></pre></div></td></tr></table></figure><p>浏览器里有一条规则：如果传的 context 是 null 或 undefined（不包括其他falsy值），那么 window 对象就是默认的 context（严格模式下默认 context 是 undefined），因此会出现第三行代码以后的结果。</p><h3 id="箭头函数的this"><a href="#箭头函数的this" class="headerlink" title="箭头函数的this"></a>箭头函数的this</h3><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> hero = <span class="hljs-string">&#x27;Jackie Chan&#x27;</span>;<br><span class="hljs-comment">//window.hero = &#x27;Jackie Chan&#x27;;</span><br><br><span class="hljs-keyword">let</span> person = &#123;<br>    <span class="hljs-attr">hero</span>:<span class="hljs-string">&#x27;Eason Chan&#x27;</span><br>&#125;;<br><br><span class="hljs-keyword">let</span> myHero = <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">this</span>.hero;<br><br>myHero();<span class="hljs-comment">//&#x27;Jackie Chan&#x27;</span><br><br>person.myHero = myHero;<br>person.myHero();<span class="hljs-comment">//&#x27;Jackie Chan&#x27;</span><br></code></pre></div></td></tr></table></figure><p>在箭头函数中，this 引用的是定义箭头函数的上下文。 由于箭头函数<code>myHero</code>是在全局作用域中定义的，所以this指向的都是window。</p><p>注意：<em><strong>箭头函数的this是固定的，不能被call/apply/bind修改。</strong></em></p><h3 id="闭包中的this"><a href="#闭包中的this" class="headerlink" title="闭包中的this"></a>闭包中的this</h3><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs JavaScript"><span class="hljs-keyword">var</span> color = <span class="hljs-string">&#x27;red&#x27;</span>;<br><span class="hljs-comment">// window.color = &#x27;red&#x27;;</span><br><br><span class="hljs-keyword">let</span> obj = &#123;<br>    <span class="hljs-attr">color</span>: <span class="hljs-string">&#x27;blue&#x27;</span>,<br>    <span class="hljs-function"><span class="hljs-title">sayColor</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">color</span>(<span class="hljs-params"></span>)</span>&#123;<br>         <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.color;   <br>        &#125;<br>&#125;<br>&#125;;<br><br>obj.sayColor()();<span class="hljs-comment">// &#x27;red&#x27;</span><br></code></pre></div></td></tr></table></figure><p>以上代码中，全局变量<code>color</code>和函数<code>color()</code>构成闭包。</p><p>具体解释：见<a href="https://yichang8421.github.io/2021/06/01/%E9%97%AD%E5%8C%85/">《闭包》</a></p><p>要想使<code>obj.sayColor()();</code>返回obj的blue，则应该让<code>obj.color</code>和函数<code>color()</code>构成闭包。可将this保存到闭包可以访问的另一个变量that中：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> color = <span class="hljs-string">&#x27;red&#x27;</span>;<br><span class="hljs-comment">// window.color = &#x27;red&#x27;;</span><br><br><span class="hljs-keyword">let</span> obj = &#123;<br>    <span class="hljs-attr">color</span>: <span class="hljs-string">&#x27;blue&#x27;</span>,<br>    <span class="hljs-function"><span class="hljs-title">sayColor</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">let</span> that = <span class="hljs-built_in">this</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">color</span>(<span class="hljs-params"></span>)</span>&#123;<br>         <span class="hljs-keyword">return</span> that.color;   <br>        &#125;<br>&#125;<br>&#125;;<br><br>obj.sayColor()();<span class="hljs-comment">// &#x27;blue&#x27;</span><br></code></pre></div></td></tr></table></figure><h3 id="回调函数中的this"><a href="#回调函数中的this" class="headerlink" title="回调函数中的this"></a>回调函数中的this</h3><p>回调函数中的this指向window。</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> hero = <span class="hljs-string">&#x27;Jackie Chan&#x27;</span>;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">peoplesHero</span>(<span class="hljs-params">fn</span>)</span>&#123;<br>fn();<br>    <span class="hljs-keyword">return</span> hero;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myHero</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-keyword">var</span> hero = <span class="hljs-string">&#x27;Eason Chan&#x27;</span>;<br>    <span class="hljs-keyword">return</span> hero;<br>&#125;<br><br>peoplesHero(myHero);<span class="hljs-comment">//&#x27;Jackie Chan&#x27;</span><br><br><span class="hljs-comment">//以上为同步回调，代码等价于：</span><br><span class="hljs-keyword">var</span> hero = <span class="hljs-string">&#x27;Jackie Chan&#x27;</span>;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">peoplesHero</span>(<span class="hljs-params"></span>)</span>&#123;<br>(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myHero</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-keyword">var</span> hero = <span class="hljs-string">&#x27;Eason Chan&#x27;</span>;<br>    <span class="hljs-keyword">return</span> hero;<br>&#125;)();<br>    <span class="hljs-keyword">return</span> hero;<br>&#125;<br><br>peoplesHero();<span class="hljs-comment">//&#x27;Jackie Chan&#x27;</span><br></code></pre></div></td></tr></table></figure><h2 id="call"><a href="#call" class="headerlink" title="call"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/call">call</a></h2><p><code>call()</code> 方法使用一个指定的 <code>this</code> 值和单独给出的一个或多个参数来调用一个函数。</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span>.call(thisArg, arg1, arg2, ...)<br></code></pre></div></td></tr></table></figure><p>代码举例在<strong>普通函数的this</strong>小节已经介绍，不再赘述。</p><p>注意：<strong>正确的函数调用方式是使用call/apply/bind指定this.</strong></p><h2 id="apply"><a href="#apply" class="headerlink" title="apply"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/apply">apply</a></h2><p><code>apply()</code> 方法调用一个具有给定<code>this</code>值的函数，以及以一个数组（或<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Indexed_collections#working_with_array-like_objects">类数组对象</a>）的形式提供的参数。</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span>.apply(thisArg, [argsArray])<br></code></pre></div></td></tr></table></figure><p><strong>注意：</strong>call()方法的作用和 apply() 方法非常非常类似，区别就是<code>call()</code>方法接受的是<strong>参数列表</strong>，而<code>apply()</code>方法接受的是<strong>一个参数数组</strong>。</p><h2 id="bind"><a href="#bind" class="headerlink" title="bind"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind">bind</a></h2><p><code>bind()</code> 方法创建一个<strong>新的函数</strong>，在 <code>bind()</code> 被调用时，这个新函数的 <code>this</code> 被指定为 <code>bind()</code> 的第一个参数，而其余参数将作为新函数的参数，供调用时使用。</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span>.bind(thisArg[, arg1[, arg2[, ...]]])<br></code></pre></div></td></tr></table></figure><p>举例：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> hero = <span class="hljs-string">&#x27;Jackie Chan&#x27;</span>;<br><span class="hljs-comment">//window.hero = &#x27;Jackie Chan&#x27;;</span><br><br><span class="hljs-keyword">let</span> person = &#123;<br>    <span class="hljs-attr">hero</span>:<span class="hljs-string">&#x27;Eason Chan&#x27;</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myHero</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.hero;<br>&#125;<br><br><span class="hljs-keyword">var</span> sayHero = myHero.bind(person);<br><span class="hljs-built_in">console</span>.log(sayHero);<span class="hljs-comment">//ƒ myHero()&#123; return this.hero; &#125;</span><br><br>myHero();<span class="hljs-comment">//&#x27;Jackie Chan&#x27;</span><br>sayHero();<span class="hljs-comment">//&#x27;Eason Chan&#x27;</span><br></code></pre></div></td></tr></table></figure><h2 id="call-apply-bind的应用场景"><a href="#call-apply-bind的应用场景" class="headerlink" title="call/apply/bind的应用场景"></a>call/apply/bind的应用场景</h2><p>参考：<a href="https://www.jianshu.com/p/bc541afad6ee">call、apply和bind方法的用法以及区别 - 简书</a></p><ul><li>求数组中的最大和最小值</li></ul><figure class="highlight jsx"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jsx"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">89</span>,<span class="hljs-number">46</span>]<br><span class="hljs-keyword">var</span> max = <span class="hljs-built_in">Math</span>.max.apply(<span class="hljs-literal">null</span>,arr)<span class="hljs-comment">//89</span><br><span class="hljs-keyword">var</span> min = <span class="hljs-built_in">Math</span>.min.apply(<span class="hljs-literal">null</span>,arr)<span class="hljs-comment">//1</span><br></code></pre></div></td></tr></table></figure><ul><li>将类数组转化为数组</li></ul><figure class="highlight jsx"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jsx"><span class="hljs-keyword">var</span> trueArr = <span class="hljs-built_in">Array</span>.prototype.slice.call(arrayLike)<br></code></pre></div></td></tr></table></figure><ul><li>数组追加</li></ul><figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp"><span class="hljs-keyword">var</span> arr1 = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];<br><span class="hljs-keyword">var</span> arr2 = [<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>];<br><span class="hljs-keyword">var</span> total = [].push.apply(arr1, arr2);<span class="hljs-comment">//6</span><br><span class="hljs-comment">// arr1 [1, 2, 3, 4, 5, 6]</span><br><span class="hljs-comment">// arr2 [4,5,6]</span><br></code></pre></div></td></tr></table></figure><ul><li>判断变量类型</li></ul><figure class="highlight jsx"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isArray</span>(<span class="hljs-params">obj</span>)</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.prototype.toString.call(obj) == <span class="hljs-string">&#x27;[object Array]&#x27;</span>;<br>&#125;<br>isArray([]) <span class="hljs-comment">// true</span><br>isArray(<span class="hljs-string">&#x27;dot&#x27;</span>) <span class="hljs-comment">// false</span><br></code></pre></div></td></tr></table></figure><ul><li>利用call和apply做继承</li></ul><figure class="highlight jsx"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params">name,age</span>)</span>&#123;<br>    <span class="hljs-comment">// 这里的this都指向实例</span><br>    <span class="hljs-built_in">this</span>.name = name<br>    <span class="hljs-built_in">this</span>.age = age<br>    <span class="hljs-built_in">this</span>.sayAge = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.age)<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Female</span>(<span class="hljs-params"></span>)</span>&#123;<br>    Person.apply(<span class="hljs-built_in">this</span>,<span class="hljs-built_in">arguments</span>)<span class="hljs-comment">//将父元素所有方法在这里执行一遍就继承了</span><br>&#125;<br><span class="hljs-keyword">var</span> dot = <span class="hljs-keyword">new</span> Female(<span class="hljs-string">&#x27;Dot&#x27;</span>,<span class="hljs-number">2</span>)<br></code></pre></div></td></tr></table></figure><ul><li>使用 log 代理 console.log</li></ul><figure class="highlight jsx"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">log</span>(<span class="hljs-params"></span>)</span>&#123;<br>  <span class="hljs-built_in">console</span>.log.apply(<span class="hljs-built_in">console</span>, <span class="hljs-built_in">arguments</span>);<br>&#125;<br><span class="hljs-comment">// 当然也有更方便的 var log = console.log()</span><br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>闭包</title>
    <link href="/2021/06/01/%E9%97%AD%E5%8C%85/"/>
    <url>/2021/06/01/%E9%97%AD%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><h2 id="闭包是什么？"><a href="#闭包是什么？" class="headerlink" title="闭包是什么？"></a>闭包是什么？</h2><p>一个函数和对其周围状态的引用捆绑在一起，或者说函数被引用包围，这样的组合就是闭包。闭包让我们可以在一个内层函数中访问到其外层函数的作用域。</p><p>「函数」和「函数内部能访问到的变量」（也叫环境）的总和，就是一个闭包。</p><p>举例：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">init</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> name = <span class="hljs-string">&quot;andy8421&quot;</span>; <span class="hljs-comment">// name 是一个被 init 创建的局部变量</span><br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">displayName</span>(<span class="hljs-params"></span>) </span>&#123; <br>        alert(name);                <br>        <span class="hljs-comment">//displayName使用了父函数中声明的变量name，二者共同构成一个闭包。</span><br>  &#125;<br>   <span class="hljs-keyword">return</span> displayName;<br>&#125;<br><br><span class="hljs-keyword">let</span> myDetail = init();<br>myDetail();<br></code></pre></div></td></tr></table></figure><p><strong>注意</strong>，最后两句和<code>init()();</code>这种调用方法并不相同，后者并没有发挥闭包保存内部变量的作用，这不叫使用了闭包。</p><p>举例：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">a</span>(<span class="hljs-params"></span>)</span>&#123;<br><span class="hljs-keyword">let</span> m=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">let</span> n=<span class="hljs-number">2</span>;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">c</span>(<span class="hljs-params"></span>)</span>&#123;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">`m:<span class="hljs-subst">$&#123;m&#125;</span>`</span>);<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">`n:<span class="hljs-subst">$&#123;n&#125;</span>`</span>);<br>m++;<br>n++;<br>&#125;<br><span class="hljs-keyword">return</span> c;<br>&#125;;<br><br>a()();<span class="hljs-comment">//m:1, n:2</span><br>a()();<span class="hljs-comment">//m:1, n:2</span><br>a()();<span class="hljs-comment">//m:1, n:2</span><br><br><span class="hljs-keyword">let</span> f = a();<br>f();<span class="hljs-comment">//m:1, n:2</span><br>f();<span class="hljs-comment">//m:2, n:3</span><br>f();<span class="hljs-comment">//m:3, n:4</span><br></code></pre></div></td></tr></table></figure><h2 id="闭包的作用是什么？"><a href="#闭包的作用是什么？" class="headerlink" title="闭包的作用是什么？"></a>闭包的作用是什么？</h2><ol><li>访问块级作用域、封装私有变量、模拟私有方法</li></ol><p>举例：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)&#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>        <span class="hljs-built_in">console</span>.log(i);<br>    &#125;,<span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-comment">//控制台打印0，1，2，3，4</span><br></code></pre></div></td></tr></table></figure><p>当计时器（私有方法）开始执行时，for循环已经结束，每一次的<code>i</code>都是该次所在的块（块级作用域）中的<code>i</code>，所以打印的是当时的<code>i</code>（私有变量）值。</p><p>以上代码相当于：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)&#123;<br>    <span class="hljs-keyword">let</span> j=i<br>    <span class="hljs-comment">//const j=i</span><br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>        <span class="hljs-built_in">console</span>.log(j);<br>    &#125;,<span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-comment">//控制台打印0，1，2，3，4</span><br></code></pre></div></td></tr></table></figure><p>此处详细解释见：<a href="https://yichang8421.github.io/2021/03/28/JS%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E6%97%B6%E6%9C%BA/"><strong>JS函数的执行时机</strong></a></p><ol start="2"><li>暴露操作函数而隐藏局部变量</li></ol><p>有时，直接使用全局变量很不妥，会出先某些安全问题。我们不能直接访问这些变量，此时就要用到闭包来隐藏局部变量，而仅暴露一个访问器（函数）来间接访问这些变量。</p><p>​    详见：<a href="https://fangyinghang.com/closures-in-js/">JS 中的闭包是什么？</a></p><h2 id="闭包中的this对象"><a href="#闭包中的this对象" class="headerlink" title="闭包中的this对象"></a>闭包中的this对象</h2><p>问题引入：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> color = <span class="hljs-string">&#x27;red&#x27;</span>;<br><span class="hljs-comment">// window.color = &#x27;red&#x27;;</span><br><br><span class="hljs-keyword">let</span> obj = &#123;<br>    <span class="hljs-attr">color</span>: <span class="hljs-string">&#x27;blue&#x27;</span>,<br>    <span class="hljs-function"><span class="hljs-title">sayColor</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">color</span>(<span class="hljs-params"></span>)</span>&#123;<br>         <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.color;   <br>        &#125;<br>&#125;<br>&#125;;<br><br>obj.sayColor()();<span class="hljs-comment">// &#x27;red&#x27;</span><br></code></pre></div></td></tr></table></figure><p>为什么<code>obj.sayColor()();</code>返回的是window.color的值red,而不是obj的blue?</p><p>以上代码中，首先创建了一个全局变量color，之后又创建了包含color属性的对象obj。obj对象还包含一个名为sayColor的函数，而这个函数本身又返回的是一个函数color()。</p><p>由于函数内部的代码在访问变量时，会沿作用域链查找变量。当函数执行完毕后，局部活动对象会被销毁，内存中就只剩下全局作用域。因此<strong>内部函数永远不可能直接访问外部函数的this和arguments变量</strong>。</p><p>当执行<code>obj.sayColor()</code>后，在函数<code>color()</code>所处的执行上下文中，局部活动对象obj已经被销毁。此时<code>color()</code>只能访问全局作用域中的color变量。</p><p>以上代码中，全局变量<code>color</code>和函数<code>color()</code>构成闭包。</p><p>要想使<code>obj.sayColor()();</code>返回obj的blue，则应该让<code>obj.color</code>和函数<code>color()</code>构成闭包。</p><p>解决方法：</p><p>将this保存到闭包可以访问的另一个变量that中：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> color = <span class="hljs-string">&#x27;red&#x27;</span>;<br><span class="hljs-comment">// window.color = &#x27;red&#x27;;</span><br><br><span class="hljs-keyword">let</span> obj = &#123;<br>    <span class="hljs-attr">color</span>: <span class="hljs-string">&#x27;blue&#x27;</span>,<br>    <span class="hljs-function"><span class="hljs-title">sayColor</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">let</span> that = <span class="hljs-built_in">this</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">color</span>(<span class="hljs-params"></span>)</span>&#123;<br>         <span class="hljs-keyword">return</span> that.color;   <br>        &#125;<br>&#125;<br>&#125;;<br><br>obj.sayColor()();<span class="hljs-comment">// &#x27;blue&#x27;</span><br></code></pre></div></td></tr></table></figure><p>尽管当执行<code>obj.Color()</code>后，其执行上下文的作用域已经被销毁，但函数<code>color()</code>仍然引用了外部函数sayColor的变量(即this)，所以他的活动对象obj仍然保存在内存中，进而obj.color仍然可以访问到。</p><p><em>obj是在color()最终执行完毕才被销毁的。</em></p><h2 id="闭包的缺点是什么？"><a href="#闭包的缺点是什么？" class="headerlink" title="闭包的缺点是什么？"></a>闭包的缺点是什么？</h2><ol><li>因为闭包会保留它们包含函数的作用域，所以比其他函数更占用内存。过度使用闭<br>包可能导致内存过度占用 。</li><li>闭包会在父函数外部改变父函数内部变量的值</li></ol>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Promise</title>
    <link href="/2021/05/01/Promise/"/>
    <url>/2021/05/01/Promise/</url>
    
    <content type="html"><![CDATA[<h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><h2 id="Promise的用途"><a href="#Promise的用途" class="headerlink" title="Promise的用途"></a>Promise的用途</h2><p>如果异步任务有成功和失败两个结果时，如果想不阻塞程序运行，传统方法有两种：</p><p>① 回调接受两个参数：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">fs.readFile(<span class="hljs-string">&#x27;./1.txt&#x27;</span>,<span class="hljs-function">(<span class="hljs-params">error,data</span>)=&gt;</span>&#123;<br><span class="hljs-keyword">if</span>(error)&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;失败&#x27;</span>);<span class="hljs-keyword">return</span>;&#125;<br><span class="hljs-built_in">console</span>.log(data.toString());<br>&#125;);<br></code></pre></div></td></tr></table></figure><p>② 使用两个回调分别表示成功和失败</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 第一个函数时成功回调，第二个函数时失败回调</span><br>ajax(<span class="hljs-string">&#x27;get&#x27;</span>,<span class="hljs-string">&#x27;./1.json&#x27;</span>,<span class="hljs-function">(<span class="hljs-params">data</span>)=&gt;</span>&#123;&#125;,<span class="hljs-function">(<span class="hljs-params">error</span>)=&gt;</span>&#123;&#125;);<br><br><span class="hljs-comment">// 或者接受一个对象，这个对象有两个key分别表示成功和失败</span><br>ajax(<span class="hljs-string">&#x27;get&#x27;</span>,<span class="hljs-string">&#x27;./1.json&#x27;</span>,&#123;<br><span class="hljs-attr">success</span>:<span class="hljs-function">()=&gt;</span>&#123;&#125;,<br><span class="hljs-attr">fail</span>:<span class="hljs-function">()=&gt;</span>&#123;&#125;<br>&#125;);<br></code></pre></div></td></tr></table></figure><p>传统方法存在以下不足：</p><p>Ⅰ. 代码不规范</p><p>Ⅱ. 容易出现回调地狱</p><p>Ⅲ. 很难进行错误处理</p><p> 为了解决这些问题，前端程序员提出了Promise思想，制定了Promise/A+规范。</p><h2 id="创建Promise"><a href="#创建Promise" class="headerlink" title="创建Promise"></a>创建Promise</h2><figure class="highlight coffeescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs coffeescript"><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">(resolve,reject)</span>=&gt;</span>&#123;&#125;);<br></code></pre></div></td></tr></table></figure><p>任务成功则调用resolve(result)</p><p>任务失败则调用reject(error)</p><p>resolve和reject再通过then方法</p><h2 id="Promise-prototype-then"><a href="#Promise-prototype-then" class="headerlink" title="Promise.prototype.then"></a>Promise.prototype.then</h2><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">p.then(onFulfilled[, onRejected]);<br><br>p.then(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>  <span class="hljs-comment">// fulfillment</span><br>&#125;, <span class="hljs-function"><span class="hljs-params">reason</span> =&gt;</span> &#123;<br>  <span class="hljs-comment">// rejection</span><br>&#125;);<br></code></pre></div></td></tr></table></figure><p>then的第一个参数就是success</p><p>then的第二个参数就是fail</p><p>举例：</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  resolve(<span class="hljs-string">&#x27;Success！&#x27;</span>);<br>  <span class="hljs-comment">// or</span><br>  <span class="hljs-comment">// reject(new Error(&quot;fucking fucked！&quot;));</span><br>&#125;);<br><br>p1.then(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(value); <span class="hljs-comment">// Success！</span><br>&#125;, <span class="hljs-function"><span class="hljs-params">reason</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.error(reason); <span class="hljs-comment">// Error: fucking fucked!</span><br>&#125;);<br></code></pre></div></td></tr></table></figure><h2 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all"></a>Promise.all</h2><p>Promise.all() 方法接收一个promise的iterable类型（Array，Map，Set）的输入，并且只返回一个<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise"><code>Promise</code></a>实例， 那个输入的所有promise的resolve回调的结果是一个数组。</p><p>语法：</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-built_in">Promise</span>.all(iterable);<br></code></pre></div></td></tr></table></figure><p>返回值</p><ul><li>如果传入的参数是一个空的可迭代对象，则返回一个<strong>已完成（already resolved）</strong>状态的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise"><code>Promise</code></a>。</li><li>如果传入的参数不包含任何 <code>promise</code>，则返回一个<strong>异步完成（asynchronously resolved）</strong> <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise"><code>Promise</code></a>。注意：Google Chrome 58 在这种情况下返回一个<strong>已完成（already resolved）</strong>状态的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise"><code>Promise</code></a>。</li><li>其它情况下返回一个<strong>处理中（pending）</strong>的<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise"><code>Promise</code></a>。这个返回的 <code>promise</code> 之后会在所有的 <code>promise</code> 都完成或有一个 <code>promise</code> 失败时<strong>异步</strong>地变为完成或失败。 见下方关于“Promise.all 的异步或同步”示例。返回值将会按照参数内的 <code>promise</code> 顺序排列，而不是由调用 <code>promise</code> 的完成顺序决定。</li></ul><h2 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race"></a>Promise.race</h2><p><strong>Promise.race(iterable)</strong> 方法返回一个 promise，一旦迭代器中的某个promise解决或拒绝，返回的 promise就会解决或拒绝。</p><p>语法：</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-built_in">Promise</span>.race(iterable);<br></code></pre></div></td></tr></table></figure><p>参数</p><ul><li><p>iterable</p><p>可迭代对象，类似<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array"><code>Array</code></a>。详见 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols">iterable</a>。</p></li></ul><p>返回值</p><p>一个<strong>待定的</strong> <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise"><code>Promise</code></a> 只要给定的迭代中的一个promise解决或拒绝，就采用第一个promise的值作为它的值，从而<strong>异步</strong>地解析或拒绝（一旦堆栈为空）。</p><p>描述</p><p><code>race</code> 函数返回一个 <code>Promise</code>，它将与第一个传递的 promise 相同的完成方式被完成。它可以是完成（ resolves），也可以是失败（rejects），这要取决于第一个完成的方式是两个中的哪个。</p><p>如果传的迭代是空的，则返回的 promise 将永远等待。</p><p>如果迭代包含一个或多个非承诺值和/或已解决/拒绝的承诺，则<code> Promise.race</code> 将解析为迭代中找到的第一个值。</p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS函数的执行时机</title>
    <link href="/2021/03/28/JS%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E6%97%B6%E6%9C%BA/"/>
    <url>/2021/03/28/JS%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E6%97%B6%E6%9C%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="JS函数的执行时机"><a href="#JS函数的执行时机" class="headerlink" title="JS函数的执行时机"></a>JS函数的执行时机</h1><h2 id="问题引入（五个5问题）："><a href="#问题引入（五个5问题）：" class="headerlink" title="问题引入（五个5问题）："></a>问题引入（五个5问题）：</h2><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)&#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>        <span class="hljs-built_in">console</span>.log(i)<br>    &#125;,<span class="hljs-number">0</span>)<br>&#125;<br><span class="hljs-comment">//控制台打印五个5</span><br><span class="hljs-comment">//return为浏览器输出的，不关心。下文不再赘述。</span><br></code></pre></div></td></tr></table></figure><p>为什么控制台打印出了五个5，而不是0、1、2、3、4，<strong>why</strong>？</p><h2 id="深入理解JS函数的执行时机"><a href="#深入理解JS函数的执行时机" class="headerlink" title="深入理解JS函数的执行时机"></a>深入理解JS函数的执行时机</h2><p>输出以上结果的前提是：</p><p>① <code>var</code>声明使得<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/var#%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87"><strong>变量提升</strong></a>。使用var命令声明，同时<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/var#description">给未声明的变量赋值, 则执行赋值后, 该变量会被隐式地创建为全局变量（成为全局对象的属性)</a>。</p><p>因此，此代码中，for循环的i被提升为全局变量（<strong>for循环全程只有一个变量i</strong>）。</p><p>以上代码等价于：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> i<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)&#123;<br>   ...<br>&#125;<br></code></pre></div></td></tr></table></figure><p>感觉这个代码比较啰嗦，以下均使用for循环内部的<code>var</code>命令来声明全局的<code>i</code>。</p><p>② JavaScript是一门<strong>单线程语言</strong>。每一个任务只能按顺序依次进行。</p><p>上述代码中的<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout">window.setTimeout</a>设置了一个<strong>定时器</strong>，该定时器在一段时期后（可以理解为之前的任务完成后）才执行一个函数或指定的一段代码。</p><p>因此在执行<code>setTimeout(()=&gt;&#123;console.log(i);&#125;,0);</code>时，for循环已经结束，此时i的值为5.</p><p>所以此时每次执行的<code>console.log(i);</code>结果都为5。</p><p><strong>通俗的理解</strong>，在当前任务还没有完成时，就安排了下一个任务，而下一个任务的进行需要上一个任务得到的结果（这里前后两个任务分别是for循环和计时器）。那么JS会先把当前任务完成，然后再开始完成下一个任务。此时，下一个任务用到的数据应该是当前任务（for循环）完成之后（<strong>have done</strong>）的数据，而不是正在完成（<strong>v.ing</strong>）的数据。</p><h3 id="异步任务"><a href="#异步任务" class="headerlink" title="异步任务"></a><a href="https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Asynchronous">异步任务</a></h3><p>通常来说，程序都是顺序执行，同一时刻只会发生一件事。如果一个函数依赖于另一个函数的结果，它只能等待那个函数结束才能继续执行，从用户的角度来说，整个程序才算运行完毕。</p><p>使用<strong>异步函数</strong>可以设置函数队列的执行顺序。JS中最基本的异步函数有：</p><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout">window.setTimeout</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/WindowOrWorkerGlobalScope/setInterval">window.setInterval</a></li></ul><h2 id="灵活使用-TL-DR"><a href="#灵活使用-TL-DR" class="headerlink" title="灵活使用(TL;DR)"></a>灵活使用(TL;DR)</h2><p>如何打出想要的0-4？</p><p><strong>理解关键点</strong>：只要 ①在局部作用域中<strong>创造</strong>它的<strong>局部变量<code>i</code><strong>（方法一） 或者 ②在</strong>局部作用域</strong>中<strong>使用</strong>全局变量<code>i</code>（方法二和方法三）就能够达到目的。</p><p><strong>方法一</strong>（for循环内部使用let声明）：</p><p>可以将var声明改为<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/let"><code>let</code></a>声明。它能声明一个块级作用域的本地变量。</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)&#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>        <span class="hljs-built_in">console</span>.log(i);<br>    &#125;,<span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-comment">//控制台打印0，1，2，3，4</span><br></code></pre></div></td></tr></table></figure><p>let肯定不能放在for循环外面，上文已经解释。</p><p>此时，尽管计时器开始执行时，for循环已经结束，但每一次的<code>i</code>都是该次所在的块中的<code>i</code>，所以打印的是当时的i值。</p><p>注意，此时<strong>for循环将产生六个局部变量i</strong>，分别是0，1，2，3，4，5。</p><p>同样的道理，也可以在for循环中<strong>单独声明</strong>一个变量j（使用let或const）。此代码比较无聊，但对于理解方法一有帮助：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)&#123;<br>    <span class="hljs-keyword">let</span> j=i<br>    <span class="hljs-comment">//const j=i</span><br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>        <span class="hljs-built_in">console</span>.log(j);<br>    &#125;,<span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-comment">//控制台打印0，1，2，3，4</span><br></code></pre></div></td></tr></table></figure><p><strong>方法二</strong>（立即执行函数）：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)&#123;<br>    !<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">i</span>)</span>&#123;<br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>        <span class="hljs-built_in">console</span>.log(i)<br>    &#125;,<span class="hljs-number">0</span>)<br>    &#125;(i)<br>&#125;<br><span class="hljs-comment">//控制台打印0，1，2，3，4</span><br></code></pre></div></td></tr></table></figure><p>使用立即执行函数可以创造一个局部作用域，进而达到想要的效果：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">!<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>       <span class="hljs-comment">/*</span><br><span class="hljs-comment">       局部作用域。</span><br><span class="hljs-comment">       */</span><br>   &#125;()<br></code></pre></div></td></tr></table></figure><p><strong>方法三</strong>（setTimeout函数传参）：</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout">window.setTimeout</a>的第三个参数用于设定function的参数</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)&#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">i</span>)</span>&#123;<br>        <span class="hljs-built_in">console</span>.log(i)<br>    &#125;,<span class="hljs-number">0</span>,i)<br>&#125;<br><span class="hljs-comment">//控制台打印0，1，2，3，4</span><br></code></pre></div></td></tr></table></figure><p>此时，每一次进入for循环，第三个参数都告诉计时器：不用等for循环完成，你现在就能拿到i值给你的function执行了。所以每一次都能直接打印出当次的i值。</p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DOM事件模型和事件委托（下）</title>
    <link href="/2020/02/18/DOM%E4%BA%8B%E4%BB%B6%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
    <url>/2020/02/18/DOM%E4%BA%8B%E4%BB%B6%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98%EF%BC%88%E4%B8%8B%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="DOM事件模型和事件委托（下）"><a href="#DOM事件模型和事件委托（下）" class="headerlink" title="DOM事件模型和事件委托（下）"></a>DOM事件模型和事件委托（下）</h1><h2 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h2><p>当监听子元素时，事件冒泡会通过目标元素向上传递到父级，直到<code>document</code>，如果子元素不确定或者动态生成，<strong>可以通过监听祖先素来取代监听子元素。</strong></p><p>通俗理解：儿子办不成或难办成的事找爹办，爹也办不成的找爷爷办，总之谁有能力办成就找谁办。</p><h3 id="情形一：给多个按钮添加点击事件，具体哪个按钮不确定"><a href="#情形一：给多个按钮添加点击事件，具体哪个按钮不确定" class="headerlink" title="情形一：给多个按钮添加点击事件，具体哪个按钮不确定"></a>情形一：给多个按钮添加点击事件，具体哪个按钮不确定</h3><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">情形一：<br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;div1&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>click 1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>click 2<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>click 3<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>click 4<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>click 5<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>click 6<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>click 7<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>click 8<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>click 9<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>click 10<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>click 11<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>click 12<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>click 13<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>click 14<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>click 15<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>click 16<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>click 17<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>click 18<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>click 19<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>click 20<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>e.target是button，但操作哪个button并不确定，此时可以监听父元素div</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;.div1&#x27;</span>).addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> t = e.target;<br>    <span class="hljs-keyword">if</span>(t.tagName.toLowerCase() === <span class="hljs-string">&#x27;button&#x27;</span>)&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;button被点击了&#x27;</span>);<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;button内容是：&#x27;</span> + t.textContent);<br>    &#125;<br>&#125;);<br></code></pre></div></td></tr></table></figure><h3 id="情形二：监听原本不存在的元素"><a href="#情形二：监听原本不存在的元素" class="headerlink" title="情形二：监听原本不存在的元素"></a>情形二：监听原本不存在的元素</h3><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs HTML"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;div2&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>假设div的子元素button要在一段时间之后才生成，那也不能够直接监听button，此时也可以使用事件委托。</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> button = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;button&#x27;</span>);<br>    button.textContent = <span class="hljs-string">&#x27;click 21&#x27;</span>;<br>    div2.appendChild(button);<br>&#125;, <span class="hljs-number">500</span>);<br><br>div2.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> t = e.target;<br>    <span class="hljs-comment">// if (t.tagName.toLowerCase() === &#x27;button&#x27;) &#123;</span><br>    <span class="hljs-comment">//     console.log(&#x27;新添加的button被点击&#x27;);</span><br>    <span class="hljs-comment">// &#125;</span><br>    <span class="hljs-keyword">if</span> (t.matches(<span class="hljs-string">&#x27;button&#x27;</span>)) &#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;新添加的button被点击&#x27;</span>);<br>    &#125;<br>&#125;);<br></code></pre></div></td></tr></table></figure><h3 id="情形三：使用自定义函数监听不存在的元素"><a href="#情形三：使用自定义函数监听不存在的元素" class="headerlink" title="情形三：使用自定义函数监听不存在的元素"></a>情形三：使用自定义函数监听不存在的元素</h3><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;div3&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>自定义函数on()可以实现事件委托。</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">on</span>(<span class="hljs-params">eventType, element, selector, fn</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (!(element <span class="hljs-keyword">instanceof</span> Element)) &#123;<br>        element = <span class="hljs-built_in">document</span>.querySelector(element);<br>    &#125;<br>    element.addEventListener(eventType, <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> &#123;<br>        <span class="hljs-keyword">let</span> el = e.target;<br>        <span class="hljs-keyword">while</span> (!el.matches(selector)) &#123;<br>            <span class="hljs-keyword">if</span> (element === el) &#123;<br>            <span class="hljs-comment">//   如果当被操作元素已经等于传入元素（最顶端元素）仍不匹配selector时，说明被操作元素不存在，跳出循环</span><br>              el = <span class="hljs-literal">null</span>;<br>              <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-comment">// 当被造作元素不匹配selector时，就将指针移动到父元素</span><br>            el = el.parentNode;<br>        &#125;<br><br>        <span class="hljs-comment">// 当被操作元素部位falsy时，调用fn</span><br>        el &amp;&amp; fn.call(el, e, el);<br>      &#125;)<br>    <span class="hljs-keyword">return</span> element;<br>&#125;<br><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> button = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;button&#x27;</span>);<br>    <span class="hljs-keyword">const</span> span = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;span&#x27;</span>);<br>    span.textContent = <span class="hljs-string">&#x27;click 22&#x27;</span>;<br>    button.appendChild(span);<br>    div3.appendChild(button);<br>&#125;, <span class="hljs-number">500</span>);<br><br>on.call(<span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-string">&#x27;#div3&#x27;</span>, <span class="hljs-string">&#x27;button&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;自定义函数on()被触发&#x27;</span>);<br>&#125;);<br></code></pre></div></td></tr></table></figure><h4 id="可以将on封装到jQuery中，使用更方便："><a href="#可以将on封装到jQuery中，使用更方便：" class="headerlink" title="可以将on封装到jQuery中，使用更方便："></a>可以将on封装到jQuery中，使用更方便：</h4><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;div4&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>以下为封装jQuery的基本方法：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">/* 封装 */</span><br><span class="hljs-built_in">window</span>.$ = <span class="hljs-built_in">window</span>.jQuery = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">selectorOrArrayOrTemplate</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> elements;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> selectorOrArrayOrTemplate === <span class="hljs-string">&#x27;string&#x27;</span>) &#123;<br>        <span class="hljs-keyword">if</span> (selectorOrArrayOrTemplate[<span class="hljs-number">0</span>] === <span class="hljs-string">&#x27;&lt;&#x27;</span>) &#123;<br>            elements = [createElement(selectorOrArrayOrTemplate)];<br>            <span class="hljs-comment">/* 定义elements的目的是操作elements，应将其设置为数组 */</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            elements = <span class="hljs-built_in">document</span>.querySelectorAll(selectorOrArrayOrTemplate);<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (selectorOrArrayOrTemplate <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Array</span>) &#123;<br>        elements = selectorOrArrayOrTemplate;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createElement</span>(<span class="hljs-params">string</span>) </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> string === <span class="hljs-string">&#x27;string&#x27;</span>) &#123;<br>            <span class="hljs-keyword">const</span> container = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;template&#x27;</span>);<br>            container.innerHTML = string.trim();<br>            <span class="hljs-keyword">return</span> container.content.firstChild;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Error! please enter a string.&#x27;</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//设置jQuery原型，节约内存</span><br>    <span class="hljs-keyword">const</span> api = <span class="hljs-built_in">Object</span>.create(jQuery.prototype);<br>    <span class="hljs-comment">//创建对象api。api.__proto__=jQuery.prototype</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     api.elements = elements;</span><br><span class="hljs-comment">     api.oldApi = selectorOrArrayOrTemplate.oldApi;</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-built_in">Object</span>.assign(api, &#123;<br>        <span class="hljs-attr">elements</span>: elements,<br>        <span class="hljs-attr">oldApi</span>: selectorOrArrayOrTemplate.oldApi,<br>    &#125;);<br>    <span class="hljs-keyword">return</span> api;<br>&#125;;<br><br>jQuery.fn = jQuery.prototype = &#123;<br>    <span class="hljs-attr">constructor</span>: jQuery,<br>    <span class="hljs-attr">jQuery</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-comment">// 点击事件</span><br>    <span class="hljs-function"><span class="hljs-title">on</span>(<span class="hljs-params">eventType, element, selector, fn</span>)</span> &#123;<br>        <span class="hljs-keyword">if</span> (!(<span class="hljs-built_in">this</span>.element <span class="hljs-keyword">instanceof</span> Element)) &#123;<br>            <span class="hljs-built_in">this</span>.element = <span class="hljs-built_in">document</span>.querySelector(element);<br>        &#125;<br>        <span class="hljs-built_in">this</span>.element.addEventListener(eventType, <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> &#123;<br>            <span class="hljs-keyword">let</span> el = e.target;<br>            <span class="hljs-keyword">while</span> (!el.matches(selector)) &#123;<br>                <span class="hljs-keyword">if</span> (element === el) &#123;<br>                <span class="hljs-comment">//   如果当被操作元素已经等于传入元素（最顶端元素）仍不匹配selector时，说明被操作元素不存在，跳出循环</span><br>                  el = <span class="hljs-literal">null</span>;<br>                  <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-comment">// 当被造作元素不匹配selector时，就将指针移动到父元素</span><br>                el = el.parentNode;<br>            &#125;<br>    <br>            <span class="hljs-comment">// 当被操作元素部位falsy时，调用fn</span><br>            el &amp;&amp; fn.call(el, e, el);<br>          &#125;)<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/* 情形三 */</span><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> button = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;button&#x27;</span>);<br>    <span class="hljs-keyword">const</span> span = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;span&#x27;</span>);<br>    span.textContent = <span class="hljs-string">&#x27;click 22&#x27;</span>;<br>    button.appendChild(span);<br>    div4.appendChild(button);<br>&#125;, <span class="hljs-number">500</span>);<br><br><span class="hljs-comment">/* 调用jQuery方法 */</span><br>$(<span class="hljs-string">&#x27;#div4&#x27;</span>).on(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-string">&#x27;#div4&#x27;</span>, <span class="hljs-string">&#x27;button&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;自定义jQuery的on()函数被触发&#x27;</span>);<br>&#125;);<br></code></pre></div></td></tr></table></figure><p><strong>优点：</strong></p><ul><li>省监听数（内存）</li><li>可以监听动态元素</li></ul><h2 id="TL-DR-面试题"><a href="#TL-DR-面试题" class="headerlink" title="TL;DR 面试题"></a>TL;DR 面试题</h2><p>请简述事件委托。</p><p><strong>答：</strong></p><p>事件委托就是把事件监听放在祖先元素（如父元素、爷爷元素）上。<br>好处是：1 节约监听数量 2 可以监听动态生成的元素。</p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>Front end</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DOM事件模型和事件委托（上）</title>
    <link href="/2020/02/15/DOM%E4%BA%8B%E4%BB%B6%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
    <url>/2020/02/15/DOM%E4%BA%8B%E4%BB%B6%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98%EF%BC%88%E4%B8%8A%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="DOM事件模型和事件委托（上）"><a href="#DOM事件模型和事件委托（上）" class="headerlink" title="DOM事件模型和事件委托（上）"></a>DOM事件模型和事件委托（上）</h1><h2 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL;DR"></a>TL;DR</h2><h3 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h3><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml">add<span class="hljs-constructor">EventListener(&#x27;<span class="hljs-params">click</span>&#x27;,<span class="hljs-params">fn</span>,<span class="hljs-params">bool</span>)</span>;<br></code></pre></div></td></tr></table></figure><ul><li>如果bool值不传或为falsy，fn走冒泡</li><li>如果bool值为true，fn走捕获</li></ul><h3 id="target和currentTarget"><a href="#target和currentTarget" class="headerlink" title="target和currentTarget"></a><strong>target和currentTarget</strong></h3><ul><li><code>e.target</code> 是用户<strong>操作</strong>的元素</li><li><code>e.currentTarget</code> 是程序员<strong>监听</strong>的元素</li></ul><p>举例：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs text">div&gt;span&#123;文字&#125;<br>在div上绑定了事件监听函数<br>用户点击文字后，e.target 指span，e.currentTarget指div<br></code></pre></div></td></tr></table></figure><h3 id="event-stopPropagation-event-stopPropagation-Web-API-接口参考-MDN-mozilla-org"><a href="#event-stopPropagation-event-stopPropagation-Web-API-接口参考-MDN-mozilla-org" class="headerlink" title="[event.stopPropagation](event.stopPropagation - Web API 接口参考 | MDN (mozilla.org))"></a><strong>[event.stopPropagation](<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Event/stopPropagation">event.stopPropagation - Web API 接口参考 | MDN (mozilla.org)</a>)</strong></h3><p><strong>捕获和冒泡都可以阻止</strong>：阻止<strong>捕获</strong>和<strong>冒泡</strong>阶段中当前事件的进一步传播（注意是都可以，MDN文档有解释，实践也证明如此）。</p><p>但是，它不能防止任何<strong>默认行为</strong>的发生； 例如，对链接的点击仍会被处理。</p><p>如果要停止这些行为，请参见 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Event/preventDefault">preventDefault</a> 方法，它可以阻止事件触发后默认动作的发生。</p><h3 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/CustomEvent/CustomEvent">自定义事件</a></h3><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> event = <span class="hljs-keyword">new</span> CustomEvent(<span class="hljs-string">&quot;eventName&quot;</span>, customEventInit);<br></code></pre></div></td></tr></table></figure><p><code>customEventInit</code>包含detial、bubbles、cancelable三个key值。</p><h3 id="发派事件"><a href="#发派事件" class="headerlink" title="发派事件"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/dispatchEvent">发派事件</a></h3><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">target.dispatchEvent(event);<br></code></pre></div></td></tr></table></figure><ul><li>event 是要被派发的事件对象。</li><li>target被用来初始化 事件 和 决定将会触发 目标。</li></ul><h2 id="1-DOM事件模型"><a href="#1-DOM事件模型" class="headerlink" title="1. DOM事件模型"></a>1. DOM事件模型</h2><h3 id="1-1-DOM事件（流）"><a href="#1-1-DOM事件（流）" class="headerlink" title="1.1 DOM事件（流）"></a>1.1 DOM事件（流）</h3><p>根据[维基百科](<a href="https://zh.wikipedia.org/wiki/%E4%BA%8B%E4%BB%B6%E9%A9%85%E5%8B%95%E7%A8%8B%E5%BC%8F%E8%A8%AD%E8%A8%88">事件驱动程序设计 - 维基百科，自由的百科全书 (wikipedia.org)</a>)的定义：<strong>事件</strong>或者<strong>事件驱动程序设计</strong>（<strong>Event-driven programming</strong>）是一种程序设计模型。这种程序运行流程是由用户的动作（如鼠标点击，键盘的按键动作）或者是由其他程序的指令性事件来决定的。</p><p>当事件发生在<strong>某个DOM节点</strong>上时，事件会在DOM结构中进行逐级的传播（propagation）。<strong>这个传播过程称为事件流</strong>。</p><p>我们可以利用**<a href="%5BEventTarget.addEventListener(">事件监听</a> - Web API 接口参考 | MDN (mozilla.org)](<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/addEventListener))**%E6%9D%A5%E6%8E%A7%E5%88%B6%E9%A1%B5%E9%9D%A2%E5%AF%B9%E6%89%80%E8%A7%A6%E5%8F%91%E4%BA%8B%E4%BB%B6%E5%8F%91%E5%87%BA%E5%93%8D%E5%BA%94%EF%BC%9A%E5%BD%93%E4%BA%8B%E4%BB%B6%E8%A7%A6%E5%8F%91%E6%97%B6%E6%89%A7%E8%A1%8C%E7%9B%B8%E5%BA%94%E7%9A%84%E7%A8%8B%E5%BA%8F%EF%BC%8C%E8%BF%9B%E8%80%8C%E5%AE%9E%E7%8E%B0%E7%94%A8%E6%88%B7%E5%92%8C%E7%BD%91%E9%A1%B5%E7%9A%84%E4%BA%A4%E4%BA%92%E3%80%82">https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/addEventListener))**来控制页面对所触发事件发出响应：当事件触发时执行相应的程序，进而实现用户和网页的交互。</a></p><h3 id="1-2-DOM事件模型——捕获和冒泡"><a href="#1-2-DOM事件模型——捕获和冒泡" class="headerlink" title="1.2 DOM事件模型——捕获和冒泡"></a>1.2 DOM事件模型——捕获和冒泡</h3><p>根据W3C的[**DOM3级事件草案**](<a href="https://www.w3.org/TR/DOM-Level-3-Events/#dom-event-architecture">UI Events (w3.org)</a>)，浏览器应同时支持两种调用顺序，共三个事件阶段：</p><ul><li><strong>捕获阶段（capture phase）</strong>：事件对象从window开始，由目标元素的祖先传播到目标元素的的父母，自上而下传播。此阶段也称为<em>捕获阶段</em>。</li><li><strong>目标阶段（target phase）</strong>：事件对象到达它的的event target。此阶段也称为<em>目标阶段</em>。<ul><li> 如果<a href="https://www.w3.org/TR/DOM-Level-3-Events/#event-type">事件类型</a>指定了事件对象默认不冒泡（<code>bubbles: false</code>），则事件对象将在完成此阶段后停止。</li></ul></li><li><strong>冒泡阶段（bubbling phase）</strong>：事件对象以相反顺序自下向上，由目标元素开始，经过目标的父母向祖先元素传播，直到到window结束。此阶段也称为<em>冒泡阶段</em>。</li></ul><p><strong>W3C 事件模型/事件机制</strong>：对每个事件<strong>先捕获再冒泡</strong>。</p><p><img src="/2020/02/15/DOM%E4%BA%8B%E4%BB%B6%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98%EF%BC%88%E4%B8%8A%EF%BC%89/eventFlow.png" alt="Graphical representation of an event dispatched in a DOM tree using the DOM event flow"></p><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>预览：<a href="https://yichang8421.github.io/DOMEvent/dist/">https://yichang8421.github.io/DOMEvent/dist/</a></p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs HTML"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;level1 x&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;level2 x&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;level3 x&quot;</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;level4 x&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;level5 x&quot;</span>&gt;</span><br>              <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;level6 x&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;level7 x&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>              <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>          <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.bootcdn.net/ajax/libs/jquery/3.6.0/jquery.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;main.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></div></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> level1 = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;.level1&#x27;</span>);<br><span class="hljs-keyword">const</span> level2 = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;.level2&#x27;</span>);<br><span class="hljs-keyword">const</span> level3 = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;.level3&#x27;</span>);<br><span class="hljs-keyword">const</span> level4 = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;.level4&#x27;</span>);<br><span class="hljs-keyword">const</span> level5 = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;.level5&#x27;</span>);<br><span class="hljs-keyword">const</span> level6 = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;.level6&#x27;</span>);<br><span class="hljs-keyword">const</span> level7 = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;.level7&#x27;</span>);<br><br><span class="hljs-keyword">let</span> n = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">const</span> removeX = <span class="hljs-function">(<span class="hljs-params">e</span>)=&gt;</span>&#123;<br>  <span class="hljs-keyword">const</span> t = e.currentTarget;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>    t.classList.remove(<span class="hljs-string">&#x27;x&#x27;</span>);<br>  &#125;,n*<span class="hljs-number">500</span>);<br>  n+=<span class="hljs-number">1</span>;<br>&#125;;<br><span class="hljs-keyword">const</span> addX =<span class="hljs-function">(<span class="hljs-params">e</span>)=&gt;</span>&#123;<br>  <span class="hljs-keyword">const</span> t = e.currentTarget;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>    t.classList.add(<span class="hljs-string">&#x27;x&#x27;</span>);<br>  &#125;,n*<span class="hljs-number">500</span>);<br>  n+=<span class="hljs-number">1</span>;<br>&#125;;<br><br><span class="hljs-comment">// 在第四个div阻止冒泡</span><br>level4.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>,<span class="hljs-function">(<span class="hljs-params">e</span>)=&gt;</span>&#123;<br>  e.stopPropagation();<br>&#125;);<br><br><span class="hljs-comment">// 在第四个div阻止捕获</span><br><span class="hljs-comment">// level4.addEventListener(&#x27;click&#x27;,(e)=&gt;&#123;</span><br><span class="hljs-comment">//     e.stopPropagation();</span><br><span class="hljs-comment">//   &#125;,true);</span><br><br>$(<span class="hljs-string">&#x27;div&#x27;</span>).each(<span class="hljs-function">(<span class="hljs-params">i, e</span>) =&gt;</span> &#123;<br>    e.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, addX,);<br>&#125;);<br><br>$(<span class="hljs-string">&#x27;div&#x27;</span>).each(<span class="hljs-function">(<span class="hljs-params">i,e</span>)=&gt;</span>&#123;<br>  e.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>,removeX,<span class="hljs-literal">true</span>);<br>&#125;);<br></code></pre></div></td></tr></table></figure><h2 id="2-自定义事件"><a href="#2-自定义事件" class="headerlink" title="2. 自定义事件"></a>2. 自定义事件</h2><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;div1&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;button1&quot;</span>&gt;</span>点击触发 自定义 事件<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript">      button1.addEventListener(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;</span><br><span class="javascript">        <span class="hljs-comment">// 自定义事件</span></span><br><span class="javascript">        <span class="hljs-keyword">const</span> event = <span class="hljs-keyword">new</span> CustomEvent(<span class="hljs-string">&quot;newEvent&quot;</span>, &#123;</span><br><span class="javascript">          <span class="hljs-attr">detail</span>: &#123;</span><br><span class="javascript">            <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;andy8421&quot;</span>,</span><br><span class="javascript">            <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,</span><br><span class="javascript">          &#125;,</span><br><span class="javascript">          <span class="hljs-comment">// 设置可以冒泡</span></span><br><span class="javascript">          <span class="hljs-attr">bubbles</span>: <span class="hljs-literal">true</span>,</span><br><span class="javascript">          <span class="hljs-comment">// 不允许阻止冒泡</span></span><br><span class="javascript">          <span class="hljs-attr">cancelable</span>: <span class="hljs-literal">false</span>,</span><br><span class="javascript">        &#125;);</span><br><span class="javascript"></span><br><span class="javascript">        <span class="hljs-comment">// 将自定义的事件发派给button1</span></span><br><span class="javascript">        button1.dispatchEvent(event);</span><br><span class="javascript">      &#125;);</span><br><span class="javascript"></span><br><span class="javascript">      div1.addEventListener(<span class="hljs-string">&quot;newEvent&quot;</span>, <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;</span><br><span class="javascript">        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;触发newEvent事件&quot;</span>);</span><br><span class="javascript">        <span class="hljs-built_in">console</span>.log(e.detail);</span><br><span class="javascript">      &#125;);</span><br><span class="javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h2 id="面试题："><a href="#面试题：" class="headerlink" title="面试题："></a>面试题：</h2><p>请简述 DOM 事件模型或 DOM 事件机制。</p><p><strong>答：</strong></p><p>捕获：当用户点击按钮，浏览器会从 window 从上向下遍历至用户点击的按钮，逐个触发事件处理函数。<br>冒泡：浏览器从用户点击的按钮从下往上遍历至 window，逐个触发事件处理函数。<br>W3C 事件模型/事件机制：对每个事件先捕获再冒泡。</p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>Front end</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入理解JQuery设计思想--基于手写DOM库</title>
    <link href="/2020/01/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jQuery%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/"/>
    <url>/2020/01/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jQuery%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/</url>
    
    <content type="html"><![CDATA[<h1 id="深入理解JQuery设计思想"><a href="#深入理解JQuery设计思想" class="headerlink" title="深入理解JQuery设计思想"></a>深入理解JQuery设计思想</h1><h2 id="从封装DOM开始"><a href="#从封装DOM开始" class="headerlink" title="从封装DOM开始"></a>从封装DOM开始</h2><p>由于原生DOM操作比较麻烦，我使用原生JavaScript对常用DOM操作进行了封装。</p><p>[代码连接](<a href="https://github.com/yichang8421/jsDOM/blob/master/src/dom.js">jsDOM/dom.js at master · yichang8421/jsDOM (github.com)</a>)</p><p>API使用范例：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// document.createElement(&#x27;div&#x27;);</span><br><span class="hljs-keyword">const</span> div = dom.create(<span class="hljs-string">&quot;&lt;div&gt;newDiv1&lt;/div&gt;&quot;</span>);<br><span class="hljs-built_in">console</span>.log(div);<br><br><span class="hljs-comment">// dom.after()</span><br>dom.after(<span class="hljs-built_in">window</span>.test, div);<br><br><span class="hljs-keyword">const</span> div2 = dom.create(<span class="hljs-string">&quot;&lt;div&gt;newDiv2&lt;/div&gt;&quot;</span>);<br>dom.before(<span class="hljs-built_in">window</span>.test, div2);<br><br><span class="hljs-comment">// dom.wrap()</span><br><span class="hljs-keyword">const</span> div3 = dom.create(<span class="hljs-string">&quot;&lt;div id=&#x27;parent&#x27;&gt;&lt;/div&gt;&quot;</span>);<br>dom.wrap(<span class="hljs-built_in">window</span>.test, div3);<br><br><span class="hljs-comment">// dom.empty()</span><br><span class="hljs-keyword">const</span> node = dom.empty(<span class="hljs-built_in">window</span>.testEmpty);<br><span class="hljs-built_in">console</span>.log(node);<br><br><span class="hljs-comment">// dom.attr() </span><br><span class="hljs-comment">// 设置title属性</span><br>dom.attr(<span class="hljs-built_in">window</span>.test, <span class="hljs-string">&#x27;title&#x27;</span>, <span class="hljs-string">&#x27;helloWorld&#x27;</span>);<br><span class="hljs-comment">// 读取title属性</span><br><span class="hljs-keyword">const</span> title = dom.attr(<span class="hljs-built_in">window</span>.test, <span class="hljs-string">&#x27;title&#x27;</span>);<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">`title:<span class="hljs-subst">$&#123;title&#125;</span>`</span>);<br><br><span class="hljs-comment">// dom.text()</span><br><span class="hljs-comment">// 设置节点的文本内容(会整体替换节点内容)</span><br>dom.text(<span class="hljs-built_in">window</span>.test, <span class="hljs-string">&#x27;你好，这是新的内容&#x27;</span>);<br><span class="hljs-comment">//获取节点的文本内容</span><br>dom.text(<span class="hljs-built_in">window</span>.test);<br><br><span class="hljs-comment">// dom.style()</span><br><span class="hljs-comment">// 设置节点的样式</span><br>dom.style(<span class="hljs-built_in">window</span>.test, &#123;<span class="hljs-attr">border</span>: <span class="hljs-string">&#x27;1px solid red&#x27;</span>, <span class="hljs-attr">color</span>: <span class="hljs-string">&#x27;green&#x27;</span>&#125;);<br><span class="hljs-comment">// 获取节点的样式</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">`test.color: <span class="hljs-subst">$&#123;dom.style(<span class="hljs-built_in">window</span>.test, <span class="hljs-string">&#x27;color&#x27;</span>)&#125;</span>`</span>);<br><span class="hljs-comment">// 修改样式属性值</span><br>dom.style(<span class="hljs-built_in">window</span>.test, <span class="hljs-string">&#x27;color&#x27;</span>, <span class="hljs-string">&#x27;blue&#x27;</span>);<br><br><span class="hljs-comment">// dom.class.add()</span><br><span class="hljs-comment">// 给节点添加class属性</span><br>dom.class.add(<span class="hljs-built_in">window</span>.test, <span class="hljs-string">&#x27;red&#x27;</span>);<br><span class="hljs-comment">// 删除class属性</span><br>dom.class.remove(<span class="hljs-built_in">window</span>.test, <span class="hljs-string">&#x27;red&#x27;</span>);<br><span class="hljs-comment">// 判断某个class属性是否存在</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">`含有class=red? <span class="hljs-subst">$&#123;dom.<span class="hljs-keyword">class</span>.contains(<span class="hljs-built_in">window</span>.test, <span class="hljs-string">&#x27;red&#x27;</span>)&#125;</span>`</span>);<br><br><span class="hljs-keyword">const</span> testClick = <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;点击事件&#x27;</span>);<br>&#125;;<br><br><span class="hljs-comment">// dom.on()</span><br><span class="hljs-comment">// 添加点击事件</span><br>dom.on(<span class="hljs-built_in">window</span>.test, <span class="hljs-string">&#x27;click&#x27;</span>, testClick);<br><span class="hljs-comment">// 移出点击事件</span><br>dom.off(<span class="hljs-built_in">window</span>.test, <span class="hljs-string">&#x27;click&#x27;</span>, testClick);<br><br><span class="hljs-comment">// dom.find()</span><br><span class="hljs-keyword">const</span> testDiv = dom.find(<span class="hljs-string">&#x27;#test2&#x27;</span>)[<span class="hljs-number">0</span>];<br><span class="hljs-built_in">console</span>.log(testDiv);<br><span class="hljs-built_in">console</span>.log(dom.find(<span class="hljs-string">&#x27;.red&#x27;</span>,testDiv)[<span class="hljs-number">0</span>]);<br><br><span class="hljs-comment">// dom.parent()</span><br><span class="hljs-built_in">console</span>.log(dom.parent(<span class="hljs-built_in">window</span>.test));<br><br><span class="hljs-comment">// dom.siblings()</span><br><span class="hljs-keyword">const</span> sibling2 =dom.find(<span class="hljs-string">&#x27;#siblings2&#x27;</span>)[<span class="hljs-number">0</span>];<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;兄弟节点:&#x27;</span>);<br><span class="hljs-built_in">console</span>.log(dom.siblings(sibling2));<br><br><span class="hljs-comment">// dom.next()</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;前一个兄弟节点:&#x27;</span>);<br><span class="hljs-built_in">console</span>.log(dom.next(sibling2));<br><br><span class="hljs-comment">// dom.previous()</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;后一个兄弟节点:&#x27;</span>);<br><span class="hljs-built_in">console</span>.log(dom.previous(sibling2));<br><br><span class="hljs-comment">// dom.each()</span><br><span class="hljs-comment">// 设置子元素属性</span><br><span class="hljs-keyword">const</span> t = dom.find(<span class="hljs-string">&quot;#testTravel&quot;</span>)[<span class="hljs-number">0</span>];<br>dom.each(dom.children(t),<span class="hljs-function">(<span class="hljs-params">n</span>)=&gt;</span> dom.style(n,<span class="hljs-string">&#x27;color&#x27;</span>,<span class="hljs-string">&#x27;red&#x27;</span>));<br><br><span class="hljs-comment">// dom.index()</span><br><span class="hljs-comment">// 找到节点在平级节点中的索引</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">`siblings的索引：<span class="hljs-subst">$&#123;dom.index(sibling2)&#125;</span>`</span>);<br></code></pre></div></td></tr></table></figure><h2 id="jQuery基本用法"><a href="#jQuery基本用法" class="headerlink" title="jQuery基本用法"></a>jQuery基本用法</h2><p><strong>jQuery</strong>是一套跨浏览器的JavaScript函数库，它可以简化HTML与JavaScript之间的操作。其语法设计模式使得许多操作变得容易，如操作文档对象（document）、选择文档对象模型（DOM）元素、创建动画效果、处理事件、以及开发Ajax程序等等。</p><p>jQuery的核心特性可以总结为：具有独特的链式语法和短小清晰的多功能接口；具有高效灵活的css选择器，并且可对CSS选择器进行扩展；拥有便捷的插件扩展机制和丰富的插件；兼容各种主流浏览器（如IE 6.0+、FF 1.5+、Safari 2.0+、Opera 9.0+等）。</p><p>截至2021年2月，全球前1万名访问最高的网站中，有79.76%的网站使用了jQuery<a href="https://trends.builtwith.com/javascript/jQuery">[1]</a>，仍是目前最受欢迎的JavaScript函数库。</p><p><strong><a href="https://api.jquery.com/">jQuery官方文档</a></strong></p><h3 id="引入jQuery"><a href="#引入jQuery" class="headerlink" title="引入jQuery"></a>引入jQuery</h3><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 注意：要把JQuery库的引用放到第一个&lt;script&gt;引用前面，这样顺序执行后面的js文件才能识别$符号 --&gt;</span><br><br><span class="hljs-comment">&lt;!-- 1.yran add jquery后引入 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;jquery.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 2.https://jquery.com/download/</span><br><span class="hljs-comment">或 https://www.bootcdn.cn/jquery/ --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.bootcdn.net/ajax/libs/jquery/3.6.0/jquery.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h3 id="页面加载即执行jQuery"><a href="#页面加载即执行jQuery" class="headerlink" title="页面加载即执行jQuery"></a>页面加载即执行jQuery</h3><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// jQuery可以用$代替</span><br><span class="hljs-comment">/* 写法一：DOM树结构完整即执行 */</span><br>$(<span class="hljs-built_in">document</span>).ready(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>     <span class="hljs-comment">//  操作代码</span><br>&#125;);<br><br><span class="hljs-comment">/* 简写 */</span><br>$(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-comment">// 操作代码</span><br>&#125;);<br><br><span class="hljs-comment">/* 写法二：等整个窗口加载完毕（含图片）才执行 */</span><br><span class="hljs-built_in">window</span>.onload = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-comment">//操作代码</span><br>&#125;;<br></code></pre></div></td></tr></table></figure><p>写法一的简写形式较为多用。</p><h2 id="选择网页元素"><a href="#选择网页元素" class="headerlink" title="选择网页元素"></a>选择网页元素</h2><p>jQuery基本思想是：选择某个元素，然后对其进行操作。</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 选择表达式，类似JavaScript选择器</span><br>$(<span class="hljs-built_in">document</span>);<br>$(<span class="hljs-string">&#x27;#myId&#x27;</span>);<br>$(<span class="hljs-string">&#x27;div.myClass&#x27;</span>);<br>$(<span class="hljs-string">&#x27;input[name=first]&#x27;</span>);<br><br><span class="hljs-comment">//特有的选择表达式</span><br>$(<span class="hljs-string">&#x27;a:first&#x27;</span>);<br>$(<span class="hljs-string">&#x27;tr:odd&#x27;</span>);<span class="hljs-comment">//选择表格的奇数行</span><br>$(<span class="hljs-string">&#x27;#myForm :input&#x27;</span>);<br>$(<span class="hljs-string">&#x27;div:visible&#x27;</span>);<span class="hljs-comment">//选择可见的元素</span><br>$(<span class="hljs-string">&#x27;div:gt(2)&#x27;</span>);<span class="hljs-comment">//选择索引大于2的所有div元素</span><br>$(<span class="hljs-string">&#x27;div:animated&#x27;</span>);<span class="hljs-comment">//选择当前出于动画状态的div元素</span><br></code></pre></div></td></tr></table></figure><h2 id="改变数据集"><a href="#改变数据集" class="headerlink" title="改变数据集"></a>改变数据集</h2><p>jQuery提供了各种过滤器对数据进行筛选，得到较为精确的选择结果。</p><h3 id="筛选选择结果"><a href="#筛选选择结果" class="headerlink" title="筛选选择结果"></a>筛选选择结果</h3><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">$(<span class="hljs-string">&#x27;div&#x27;</span>).has(<span class="hljs-string">&#x27;p&#x27;</span>);<span class="hljs-comment">//选择包含p元素的div元素</span><br>$(<span class="hljs-string">&#x27;div&#x27;</span>).not(<span class="hljs-string">&#x27;.myClass&#x27;</span>);<span class="hljs-comment">//选择class不等于myClass的div元素</span><br>$(<span class="hljs-string">&#x27;div&#x27;</span>).filter(<span class="hljs-string">&#x27;.myClass&#x27;</span>);<br>$(<span class="hljs-string">&#x27;div&#x27;</span>).first();<br>$(<span class="hljs-string">&#x27;div&#x27;</span>).eq(<span class="hljs-number">5</span>);<span class="hljs-comment">//选择索引等于5的元素（第六个元素）</span><br></code></pre></div></td></tr></table></figure><h3 id="通过遍历DOM树进行筛选"><a href="#通过遍历DOM树进行筛选" class="headerlink" title="通过遍历DOM树进行筛选"></a><a href="https://api.jquery.com/category/traversing/tree-traversal/">通过遍历DOM树进行筛选</a></h3><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">$(<span class="hljs-string">&#x27;div&#x27;</span>).next(<span class="hljs-string">&#x27;p&#x27;</span>);<span class="hljs-comment">//同级下一个元素</span><br>$(<span class="hljs-string">&#x27;div&#x27;</span>).parent();<br>$(<span class="hljs-string">&#x27;div&#x27;</span>).children();<br>$(<span class="hljs-string">&#x27;div&#x27;</span>).find();<span class="hljs-comment">//选择后代元素</span><br>$(<span class="hljs-string">&#x27;div&#x27;</span>).siblings();<br>$(<span class="hljs-string">&#x27;div&#x27;</span>).closest(<span class="hljs-string">&#x27;form&#x27;</span>);<span class="hljs-comment">//选择最近元素</span><br></code></pre></div></td></tr></table></figure><h2 id="链式操作"><a href="#链式操作" class="headerlink" title="链式操作"></a>链式操作</h2><p>jQuery允许将各种操作连在一起，以链式语法形式书写，有效简化代码。</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">//$(&#x27;.test&#x27;).find(&#x27;.child&#x27;).addClass(&#x27;red&#x27;).addClass(&#x27;blue&#x27;).addClass(&#x27;green&#x27;).end().html(&#x27;修改test&#x27;);</span><br><br><span class="hljs-comment">//分解写法，便于读代码</span><br>$(<span class="hljs-string">&#x27;.test&#x27;</span>)<br>     .find(<span class="hljs-string">&#x27;.child&#x27;</span>)<br>     .addClass(<span class="hljs-string">&#x27;red&#x27;</span>)<br>     .addClass(<span class="hljs-string">&#x27;blue&#x27;</span>)<br>     .addClass(<span class="hljs-string">&#x27;green&#x27;</span>)<br>     .end()<span class="hljs-comment">// end()回退上一次选择的节点，然后进行后续操作</span><br>     .html(<span class="hljs-string">&#x27;修改test&#x27;</span>);<br></code></pre></div></td></tr></table></figure><p>jQuery提供<code>end()</code>方法使当前选择器回退到上一次选择的节点，然后对其进行操作。上面的<code>html()</code>方法最终作用在<code>.test</code>元素上。<code>end()</code>方法使得jQuery链式操作不会因为选择器的来回切换而断开，因此是<strong>“真”链式操作</strong>。</p><h2 id="读写操作"><a href="#读写操作" class="headerlink" title="读写操作"></a>读写操作</h2><p>jQuery可以使用同一个方法来完成<code>get</code>和<code>set</code>操作：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">$(<span class="hljs-string">&#x27;header&#x27;</span>).html();<span class="hljs-comment">//读取header的html内容</span><br>$(<span class="hljs-string">&#x27;header&#x27;</span>).html(<span class="hljs-string">&#x27;andy8421&#x27;</span>);<span class="hljs-comment">//设置header值为andy8421</span><br></code></pre></div></td></tr></table></figure><p>常见读写操作函数:</p><p>​    <a href="http://api.jquery.com/html/">html()</a> 取出或设置html内容</p><p>　<a href="http://api.jquery.com/text/">text()</a> 取出或设置text内容，读取时只有<strong>文本内容</strong>（不含html标签）</p><p>　<a href="http://api.jquery.com/attr/">attr()</a> </p><p>　<a href="http://api.jquery.com/width/">width()</a> </p><p>　<a href="http://api.jquery.com/height/">height()</a> </p><p>　<a href="http://api.jquery.com/val/">val()</a> 取出或设置某个<strong>表单元素</strong>的值</p><p>需要注意的是，如果结果集包含多个元素，那么赋值的时候，将对其中所有的元素赋值；取值的时候，则是<strong>只取出第一个元素的值</strong>。</p><p><strong>text()除外</strong>，它读取<strong>所有元素</strong>的text内容。</p><h3 id="html-、text-和val-的区别"><a href="#html-、text-和val-的区别" class="headerlink" title="html()、text()和val()的区别"></a>html()、text()和val()的区别</h3><ul><li><p><code>html()</code>读取<strong>已被渲染的内容</strong>，未被渲染的标签不会读取</p></li><li><p><code>text()</code>只读取<strong>文本内容</strong>，但是读取的是<strong>所有元素</strong>的文本内容</p></li><li><p><code>var()</code>操作对象是<strong>表单元素</strong>，主要用于读写表单元素的value</p></li></ul><p>举例：</p><p>index.html</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;div1&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">strong</span>&gt;</span>HelloWorld<span class="hljs-tag">&lt;/<span class="hljs-name">strong</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;div2&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">em</span>&gt;</span>/FrontEnd<span class="hljs-tag">&lt;/<span class="hljs-name">em</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;input1&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;val读取内容&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br><br>    html()是：<br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;html&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>    text()是：<br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;text&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>    val()是：<br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;val&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br><br>    input的value设为html：<br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;htmlVal&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br>    input的value设为text：<br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;textVal&quot;</span> /&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.bootcdn.net/ajax/libs/jquery/3.6.0/jquery.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;main.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>main.js</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">$(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-comment">/* 拿到文本值 */</span><br>    <span class="hljs-keyword">let</span> strHtml = $(<span class="hljs-string">&#x27;div&#x27;</span>).html();<br>    <span class="hljs-keyword">let</span> strText = $(<span class="hljs-string">&#x27;div&#x27;</span>).text();<br>    <span class="hljs-keyword">let</span> strVal = $(<span class="hljs-string">&#x27;#input1&#x27;</span>).val();<br><br>    <span class="hljs-comment">/* 设置文本值 */</span><br>    $(<span class="hljs-string">&quot;#html&quot;</span>).html(strHtml);<br>    $(<span class="hljs-string">&quot;#text&quot;</span>).text(strText);<br><br><br>    $(<span class="hljs-string">&quot;#val&quot;</span>).val(strVal);<br>    <span class="hljs-built_in">console</span>.log(strVal);<br>    <span class="hljs-built_in">console</span>.log($(<span class="hljs-string">&#x27;#val&#x27;</span>).val());<br><br>    <span class="hljs-comment">/* input的value设置为html */</span><br>    <span class="hljs-comment">// $(&quot;#htmlVal&quot;).val(strHtml);</span><br>    <span class="hljs-built_in">console</span>.log($(<span class="hljs-string">&quot;#htmlVal&quot;</span>).val(strHtml).val());<br>    <br>    <span class="hljs-comment">/* input的value设置为text */</span><br>    <span class="hljs-built_in">console</span>.log($(<span class="hljs-string">&quot;#textVal&quot;</span>).val(strText).val());<br>&#125;);<br></code></pre></div></td></tr></table></figure><p>输出结果：</p><p><img src="/2020/01/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jQuery%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/1618739381161.png" alt="1618739381161"></p><h2 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h2><h3 id="外部插入"><a href="#外部插入" class="headerlink" title="外部插入"></a><a href="https://api.jquery.com/category/manipulation/dom-insertion-outside/">外部插入</a></h3><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">$(<span class="hljs-string">&#x27;aside&#x27;</span>).insertAfter($(<span class="hljs-string">&#x27;article&#x27;</span>));<br>$(<span class="hljs-string">&#x27;article&#x27;</span>).after($(<span class="hljs-string">&#x27;aside&#x27;</span>));<br><br>$(<span class="hljs-string">&#x27;h2&#x27;</span>).insertBefore($(<span class="hljs-string">&#x27;section&#x27;</span>));<br>$(<span class="hljs-string">&#x27;section&#x27;</span>).before($(<span class="hljs-string">&#x27;h2&#x27;</span>));<br></code></pre></div></td></tr></table></figure><h3 id="内部插入"><a href="#内部插入" class="headerlink" title="内部插入"></a><a href="https://api.jquery.com/category/manipulation/dom-insertion-inside/">内部插入</a></h3><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">$(<span class="hljs-string">&#x27;footer&#x27;</span>).appendTo(<span class="hljs-built_in">document</span>.body);<br>(<span class="hljs-built_in">document</span>.body).append($(<span class="hljs-string">&#x27;footer&#x27;</span>));<span class="hljs-comment">//可用于创建元素</span><br><br>$(<span class="hljs-string">&#x27;header&#x27;</span>).prependTo(<span class="hljs-built_in">document</span>.body);<br>(<span class="hljs-built_in">document</span>.body).prepend(<span class="hljs-string">&#x27;header&#x27;</span>);<br></code></pre></div></td></tr></table></figure><p>以上内部插入和外部操作中，成对的两个代码操作效果相同。jQuery之所以这样设计是为了便于链式操作，可以灵活选择。</p><h2 id="元素的复制、删除"><a href="#元素的复制、删除" class="headerlink" title="元素的复制、删除"></a>元素的复制、删除</h2><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">$(<span class="hljs-string">&#x27;div&#x27;</span>).clone();<br><br>$(<span class="hljs-string">&#x27;div&#x27;</span>).remove();<span class="hljs-comment">//真删除</span><br>$(<span class="hljs-string">&#x27;div&#x27;</span>).detach();<span class="hljs-comment">//假删除，保留被删除元素的事件</span><br><br>$(<span class="hljs-string">&#x27;header&#x27;</span>).empty;<span class="hljs-comment">//清空header元素内容，而不删除header元素</span><br></code></pre></div></td></tr></table></figure><h2 id="用jQuery的设计思想封装DOM库"><a href="#用jQuery的设计思想封装DOM库" class="headerlink" title="用jQuery的设计思想封装DOM库"></a>用jQuery的设计思想封装DOM库</h2><p>为进一步简化手写DOM操作，我使用jQuery设计思想，即封装了DOM库。</p><p><a href="https://github.com/yichang8421/jQueryDOM/blob/master/src/jquery.js">源码连接</a></p><h3 id="获取网页元素"><a href="#获取网页元素" class="headerlink" title="获取网页元素"></a>获取网页元素</h3><p>使用jQuery的第一步，就是要得到你选中的元素，放在jQuery()（或者$()）里面。</p><p><strong>实现方法:</strong> 使用重载设计模式获取对应的元素，利用闭包，在调用方法时使用到<code>elements</code></p><h3 id="链式操作-1"><a href="#链式操作-1" class="headerlink" title="链式操作"></a>链式操作</h3><p><strong>链式操作</strong>: 选中网页元素以后，可以对它进行一系列操作，并且所有操作可以连接在一起，以链条的形式写出来.</p><p><strong>实现思想：</strong> 于每一步的jQuery操作，返回的都是一个新的jQuery对象。</p><h3 id="方法放在原型上"><a href="#方法放在原型上" class="headerlink" title="方法放在原型上"></a>方法放在原型上</h3><p><strong>优点：</strong></p><ul><li>把方法都移到jQuery原型身上，这样每次创建一个jQuery对象时，就不会再去开一块内存存放方法了。</li><li>所有创建的jQuery对象中的方法都放在原型上，这样省内存。</li></ul>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>Front end</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>排序算法——JavaScript实现</title>
    <link href="/2020/01/01/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <url>/2020/01/01/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><h2 id="选择排序O-n-2"><a href="#选择排序O-n-2" class="headerlink" title="选择排序O(n^2)"></a>选择排序O(n^2)</h2><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">//返回数列的最小值</span><br><span class="hljs-comment">//递归方法</span><br><span class="hljs-keyword">let</span> min = <span class="hljs-function">(<span class="hljs-params">number</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (number.length &gt; <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-keyword">return</span> min([number[<span class="hljs-number">0</span>], min(number.slice(<span class="hljs-number">1</span>))]);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.min.apply(<span class="hljs-literal">null</span>, number);<br>    &#125;<br>&#125;;<br><span class="hljs-comment">//循环方法</span><br><span class="hljs-comment">// let minCycle = (number) =&gt; &#123;</span><br><span class="hljs-comment">//     return number[minIndexCycle(number)];</span><br><span class="hljs-comment">// &#125;;</span><br><br><span class="hljs-comment">//选择排序</span><br><span class="hljs-comment">//递归方法</span><br><span class="hljs-keyword">let</span> minIndex = <span class="hljs-function">(<span class="hljs-params">number</span>) =&gt;</span> number.indexOf(min(number));<br><br><span class="hljs-comment">//递归方法</span><br><span class="hljs-keyword">let</span> sort = <span class="hljs-function">(<span class="hljs-params">number</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (number.length &gt; <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-keyword">let</span> index = minIndex(number);<br>        <span class="hljs-keyword">let</span> min = number[index];<br>        number.splice(index, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> [min].concat(sort(number));<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> number[<span class="hljs-number">0</span>] &lt; number[<span class="hljs-number">1</span>] ? number : number.reverse();<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">//选择排序</span><br><span class="hljs-comment">//循环方法</span><br><span class="hljs-keyword">let</span> minIndexCycle = <span class="hljs-function">(<span class="hljs-params">number</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">let</span> minIndex = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; number.length; i++) &#123;<br>        <span class="hljs-keyword">if</span> (number[i] &lt; number[minIndex])<br>            minIndex = i;<br>    &#125;<br>    <span class="hljs-keyword">return</span> minIndex;<br>&#125;;<br><br><span class="hljs-keyword">let</span> swap = <span class="hljs-function">(<span class="hljs-params">number, a, b</span>) =&gt;</span> &#123;<br>    number[a] = number[a] ^ number[b];<br>    number[b] = number[a] ^ number[b];<br>    number[a] = number[a] ^ number[b];<br>    <span class="hljs-keyword">return</span> number;<br>&#125;<br><br><span class="hljs-comment">//循环方法</span><br><span class="hljs-keyword">let</span> sortCycle = <span class="hljs-function">(<span class="hljs-params">number</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; number.length - <span class="hljs-number">1</span>; i++) &#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;------&quot;</span>);<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`i:<span class="hljs-subst">$&#123;i&#125;</span>`</span>);<br>        <span class="hljs-comment">// let tempNumber = number.slice(i);</span><br>        <span class="hljs-comment">// let minIndex = minIndexCycle(tempNumber) + i;</span><br>        <span class="hljs-comment">// 第i项及之前数列都是排好序的，只用考虑第i项之后的数列排序</span><br>        <span class="hljs-comment">// minIndexCycle(tempNumber)得到的是剔除前i项排好序数列之后的新数组中，最小数在该数组中的下标</span><br>        <span class="hljs-comment">// 由于新数组下标是重新从零开始的，要找到此最小数在number中对应的下标。应该加i。</span><br>        <span class="hljs-keyword">let</span> minIndex = minIndexCycle(number.slice(i)) + i;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`minIndex:<span class="hljs-subst">$&#123;minIndex&#125;</span>`</span>);<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`min:<span class="hljs-subst">$&#123;number[minIndex]&#125;</span>`</span>);<br>        <span class="hljs-comment">//找到number中最小数字的下标，然后将其与当前下标的数字交换位置</span><br>        <span class="hljs-keyword">if</span> (minIndex != i)<br>            swap(number, minIndex, i);<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`number:[<span class="hljs-subst">$&#123;number&#125;</span>]`</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> number;<br>&#125;;<br><br></code></pre></div></td></tr></table></figure><h2 id="快速排序O-nlog2n"><a href="#快速排序O-nlog2n" class="headerlink" title="快速排序O(nlog2n)"></a>快速排序O(nlog2n)</h2><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">//快速排序</span><br><span class="hljs-comment">//递归方法</span><br><span class="hljs-keyword">let</span> quickSort = <span class="hljs-function"><span class="hljs-params">arr</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (arr.length &lt;= <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> arr;<br>    <span class="hljs-comment">// 基准数字选择arr中间位置最大整数数(向下取整)</span><br>    <span class="hljs-keyword">let</span> pivotIndex = <span class="hljs-built_in">Math</span>.floor(arr.length / <span class="hljs-number">2</span>);<br>    <span class="hljs-comment">// 取出基准数字</span><br>    <span class="hljs-keyword">let</span> pivot = arr.splice(pivotIndex, <span class="hljs-number">1</span>)[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">let</span> left = [];<br>    <span class="hljs-keyword">let</span> right = [];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>        <span class="hljs-comment">// 如果剩余数小于基准数，则将其放入左边数组；反之放入右边数组</span><br>        <span class="hljs-keyword">if</span> (arr[i] &lt; pivot) &#123;<br>            left.push(arr[i]);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            right.push(arr[i]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> quickSort(left).concat([pivot], quickSort(right));<br>&#125;;<br><br></code></pre></div></td></tr></table></figure><h2 id="归并排序O-nlog2n"><a href="#归并排序O-nlog2n" class="headerlink" title="归并排序O(nlog2n)"></a>归并排序O(nlog2n)</h2><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 归并排序</span><br><span class="hljs-comment">// 先分解，再合并</span><br><span class="hljs-comment">// 递归方法</span><br><br><span class="hljs-comment">// 分解</span><br><span class="hljs-keyword">let</span> mergeSort = <span class="hljs-function"><span class="hljs-params">arr</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (arr.length === <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span> arr;<br>    &#125;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`----`</span>);<br>    <span class="hljs-comment">/* slice() 方法返回一个新的数组对象，这一对象是一个由 begin 和 end 决定的原数组的浅拷贝（包括 begin，不包括end）。原始数组不会被改变。*/</span><br>    <span class="hljs-keyword">let</span> left = arr.slice(<span class="hljs-number">0</span>, <span class="hljs-built_in">Math</span>.floor(arr.length / <span class="hljs-number">2</span>));<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`left:<span class="hljs-subst">$&#123;left&#125;</span>`</span>);<br>    <span class="hljs-keyword">let</span> right = arr.slice(<span class="hljs-built_in">Math</span>.floor(arr.length / <span class="hljs-number">2</span>),);<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`right:<span class="hljs-subst">$&#123;right&#125;</span>`</span>);<br>    <span class="hljs-keyword">return</span> merge(mergeSort(left), mergeSort(right));<br>&#125;;<br><br><span class="hljs-comment">// 合并</span><br><span class="hljs-keyword">let</span> merge = <span class="hljs-function">(<span class="hljs-params">left, right</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (!left.length)<br>        <span class="hljs-comment">// 当left数组已经全部拿空了，那么就直接将right数组连接到新数组</span><br>        <span class="hljs-keyword">return</span> right;<br>    <span class="hljs-keyword">if</span> (!right.length)<br>        <span class="hljs-keyword">return</span> left;<br><br>    <span class="hljs-keyword">if</span> (left[<span class="hljs-number">0</span>] &gt; right[<span class="hljs-number">0</span>]) &#123;<br>        <span class="hljs-comment">// right[0]是两个数组中的最小数，先放在左边。然后left和right剩余部分按相同方法进行合并。</span><br>        <span class="hljs-keyword">return</span> [right[<span class="hljs-number">0</span>]].concat(merge(left, right.slice(<span class="hljs-number">1</span>,)))<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> [left[<span class="hljs-number">0</span>]].concat(merge(left.slice(<span class="hljs-number">1</span>,), right));<br>    &#125;<br>    <span class="hljs-comment">// return left[0] &gt; right[0] ? [right[0]].concat(merge(left, right.slice(1))) : [left[0]].concat(merge(left.slice(1), right));</span><br>&#125;;<br></code></pre></div></td></tr></table></figure><h2 id="计数排序O-n-max"><a href="#计数排序O-n-max" class="headerlink" title="计数排序O(n+max)"></a>计数排序O(n+max)</h2><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 计数排序</span><br><span class="hljs-keyword">let</span> countSort = <span class="hljs-function"><span class="hljs-params">arr</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">let</span> count = &#123;&#125;,<br>        <span class="hljs-comment">// count用一个哈希表定义，便于计数</span><br>        max = <span class="hljs-number">0</span>,<br>        result = [];<br><br>    <span class="hljs-comment">// 遍历数组，对所有数字计数。获得哈希表count</span><br>    <span class="hljs-comment">// 这样做的目的是便于下一步循环，判断数字是否应该压入数组</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>; index &lt; arr.length; index++) &#123;<br>        <span class="hljs-keyword">if</span> (!(arr[index] <span class="hljs-keyword">in</span> count)) &#123;<br>            count[arr[index]] = <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            count[arr[index]] += <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (arr[index] &gt; max)<br>            max = arr[index];<br>    &#125;<br><br>    <span class="hljs-comment">// 遍历哈希表，从小到大依次将所有数字压入新数组</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> value = <span class="hljs-number">0</span>; value &lt;= max; value++) &#123;<br>        <span class="hljs-keyword">if</span> (value <span class="hljs-keyword">in</span> count) &#123;<br>    <span class="hljs-comment">// 将所有数字都压入新数组。count记录了几次，value就要压入几次</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; count[value]; i++) &#123;<br>                result.push(value);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><h2 id="各种排序方法的比较"><a href="#各种排序方法的比较" class="headerlink" title="各种排序方法的比较"></a>各种排序方法的比较</h2><p><img src="/2020/01/01/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.jpeg"></p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>Front end</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>实践篇-—JS对象基本用法</title>
    <link href="/2019/11/29/JS%E5%AF%B9%E8%B1%A1%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/"/>
    <url>/2019/11/29/JS%E5%AF%B9%E8%B1%A1%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="JS对象基本用法"><a href="#JS对象基本用法" class="headerlink" title="JS对象基本用法"></a>JS对象基本用法</h1><h2 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h2><ol><li>声明对象的两种语法</li><li>如何删除对象的属性</li><li>如何查看对象的属性</li><li>如何修改或增加对象的属性</li><li>‘name’ in obj和obj.hasOwnProperty(‘name’) 的区别</li></ol><h2 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL;DR"></a>TL;DR</h2><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 删</span><br><span class="hljs-keyword">delete</span> obj[<span class="hljs-string">&#x27;name&#x27;</span>]<br><span class="hljs-string">&#x27;name&#x27;</span> <span class="hljs-keyword">in</span> obj <span class="hljs-comment">//查是否含有name属性</span><br>obj.hasOwnProperty(<span class="hljs-string">&#x27;name&#x27;</span>)  <span class="hljs-comment">//查name属性是否时自由属性</span><br><br><span class="hljs-comment">// 查</span><br><span class="hljs-built_in">Object</span>.keys(obj)<br><span class="hljs-built_in">console</span>.dir(obj)<br>obj[<span class="hljs-string">&#x27;name&#x27;</span>]<br>obj.name <span class="hljs-comment">// 记住这里的 name 是字符串</span><br>obj[name]  <span class="hljs-comment">// 记住这里的 name 是变量</span><br><br><span class="hljs-comment">// 改和增</span><br>obj[<span class="hljs-string">&#x27;name&#x27;</span>] = <span class="hljs-string">&#x27;jack&#x27;</span><span class="hljs-comment">//改自身</span><br><span class="hljs-built_in">Object</span>.assign(obj, &#123;<span class="hljs-attr">age</span>:<span class="hljs-number">18</span>, ...&#125;) <span class="hljs-comment">//批量改自身 </span><br><span class="hljs-built_in">Object</span>.prototype[<span class="hljs-string">&#x27;toString&#x27;</span>] = <span class="hljs-string">&#x27;xxx&#x27;</span><span class="hljs-comment">//改共有属性 </span><br><span class="hljs-keyword">let</span> obj = <span class="hljs-built_in">Object</span>.create(common)<span class="hljs-comment">//改原型 </span><br></code></pre></div></td></tr></table></figure><h2 id="对象的声明"><a href="#对象的声明" class="headerlink" title="对象的声明"></a>对象的声明</h2><h3 id="键值对"><a href="#键值对" class="headerlink" title="键值对"></a>键值对</h3><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> obj = &#123;<span class="hljs-string">&#x27;name&#x27;</span>:<span class="hljs-string">&#x27;andy8421&#x27;</span>,<span class="hljs-string">&#x27;age&#x27;</span>:<span class="hljs-number">18</span>&#125;;<br><span class="hljs-keyword">let</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>&#123;<span class="hljs-string">&#x27;name&#x27;</span>:<span class="hljs-string">&#x27;andy8421&#x27;</span>&#125;;<br><br><span class="hljs-comment">//以变量做为属性名</span><br><span class="hljs-keyword">let</span> x = <span class="hljs-string">&#x27;name&#x27;</span>;<br><span class="hljs-keyword">let</span> obj = &#123;[x]:<span class="hljs-string">&#x27;andy8421&#x27;</span>&#125;<span class="hljs-comment">//key值是变量x，x为&#x27;name&#x27;</span><br></code></pre></div></td></tr></table></figure><p>★ <strong>不能使用</strong><code>let obj = &#123;x:&#39;andy8421&#39;&#125;;</code>，这样得到的key值为字符串x，不是变量x。</p><ul><li>键名是任意字符组成的字符串，不是标识符</li><li>引号可以省略。若省略引号，则只能写标识符</li><li>省略引号，键名仍然是字符串</li></ul><h3 id="对象的隐藏属性"><a href="#对象的隐藏属性" class="headerlink" title="对象的隐藏属性"></a>对象的隐藏属性</h3><ol><li><p>JS中每一个对象都有一个隐藏属性（<code>__proto__</code>）</p></li><li><p>这个隐藏属性储存着<strong>共有属性所组成对象</strong>的地址</p></li><li><p>这个<strong>共有属性组成的对象</strong>叫原型</p></li><li><p>隐藏属性存储着原型的地址</p></li></ol><h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h3><ol><li><strong>每个对象</strong>都有原型<ol><li>obj的原型就是一个对象</li><li><code>obj.__proto__</code>存着这个对象的地址</li><li>这个对象（即原型）里有toString/valueOf/constructor等属性（即共有属性）</li></ol></li><li>原型里存着对象的共有属性</li><li>对象的原型也是对象</li><li>所以对象的原型也由原型<ol><li>obj的原型，即<code>obj.__proto__</code>，为所有对象的原型</li><li>这个原型包含所有对象的共有属性，是对象的<strong>根</strong></li><li>这个原型也有原型（对象的根的原型），但是值为null。<code>obj.__proto__.__proto__===null</code>(浏览器查不到这个属性，因为值为null)</li></ol></li></ol><p><img src="/2019/11/29/JS%E5%AF%B9%E8%B1%A1%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/js%E5%8E%9F%E5%9E%8B%E9%93%BE%EF%BC%88%E8%A1%A5%E5%85%85%EF%BC%89.jpg"></p><p>图中，#8421和#1024分别指向的就是Object和Array两个原型，它们分别含有toString()和push()，这两个方法并不是obj和arr自身的属性，而是obj和arr两个对象的原型<code>obj.__proto__</code>和<code>arr.__proto__</code>的属性，称为共有属性。</p><h2 id="对象属性的增删改查操作"><a href="#对象属性的增删改查操作" class="headerlink" title="对象属性的增删改查操作"></a>对象属性的增删改查操作</h2><h3 id="删除对象的属性"><a href="#删除对象的属性" class="headerlink" title="删除对象的属性"></a>删除对象的属性</h3><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> obj = &#123;<span class="hljs-attr">key1</span>:<span class="hljs-string">&#x27;value1&#x27;</span>,<span class="hljs-string">&#x27;key2&#x27;</span>:<span class="hljs-string">`value2`</span>&#125;;<br><br><span class="hljs-keyword">delete</span> obj.key1;<span class="hljs-comment">//正确删除对象的属性方法</span><br></code></pre></div></td></tr></table></figure><p>★ <strong>不能使用</strong><code>obj.key1 = undefined;</code>。它只是将obj的key1值设置为undefined，<strong>并不能删除</strong>obj的key1属性。</p><h3 id="查看对象的属性（读）"><a href="#查看对象的属性（读）" class="headerlink" title="查看对象的属性（读）"></a>查看对象的属性（读）</h3><p><code>in</code>判断对象<strong>是否含有</strong>某个属性（一般用于判断属性是否被删除）：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;xxx&#x27;</span> <span class="hljs-keyword">in</span> obj;<span class="hljs-comment">//return:false表示obj不含有xxx属性。（反之含有）</span><br><br><span class="hljs-string">&#x27;xxx&#x27;</span> <span class="hljs-keyword">in</span> obj &amp;&amp; obj.xxx;<span class="hljs-comment">//return:undefined表示obj含有xxx属性，但是属性值为undefined。</span><br><span class="hljs-comment">//如果return:false则表示同上一句，不赘述。</span><br><span class="hljs-comment">//这证明了为什么删除属性xxx不能使用obj.key1 = undefined;</span><br></code></pre></div></td></tr></table></figure><p>使用<code>in</code>时，前面待判断key值<strong>引号不能省</strong>，否则表示变量xxx。</p><p>证明: 对象的根存在原型，且该原型值为null：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> obj = &#123;&#125;;<br><br><span class="hljs-string">&#x27;__proto__&#x27;</span> <span class="hljs-keyword">in</span> obj.__proto__;<span class="hljs-comment">//return:true;</span><br>obj.__proto__.__proto__===<span class="hljs-literal">null</span>;<span class="hljs-comment">//return:true;</span><br></code></pre></div></td></tr></table></figure><p>查看属性的键值对：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> obj = &#123;<span class="hljs-attr">key1</span>:<span class="hljs-string">&#x27;value1&#x27;</span>,<span class="hljs-string">&#x27;key2&#x27;</span>:<span class="hljs-string">`value2`</span>&#125;;<br><br><span class="hljs-comment">//查看自身属性</span><br><span class="hljs-built_in">Object</span>.values(obj);<span class="hljs-comment">//return:obj的所有属性值</span><br><span class="hljs-built_in">Object</span>.keys(obj);<span class="hljs-comment">//return:obj的所有key值</span><br><span class="hljs-built_in">Object</span>.entries(obj);<span class="hljs-comment">//return:obj的所有由键值对组成的数组</span><br><br><span class="hljs-comment">//查看自身属性和共有属性</span><br><span class="hljs-built_in">console</span>.dir(obj);<br>obj.__proto__;<span class="hljs-comment">//不规范，不推荐</span><br></code></pre></div></td></tr></table></figure><p>判断一个属性是<strong>自身属性</strong>还是共有属性：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">obj.hasOwnProperty(<span class="hljs-string">&#x27;key1&#x27;</span>);<span class="hljs-comment">//true</span><br>obj.hasOwnProperty(<span class="hljs-string">&#x27;toString&#x27;</span>);<span class="hljs-comment">//false</span><br></code></pre></div></td></tr></table></figure><p>★ <strong>不能使用</strong><code>&#39;xxx&#39; in obj;</code>。它只是判断对象<em>是否含有</em>某个属性，不能判断是否为自有属性。</p><p>查看单个属性的key值：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> obj = &#123;<span class="hljs-attr">key1</span>:<span class="hljs-string">&#x27;value1&#x27;</span>,<span class="hljs-string">&#x27;key2&#x27;</span>:<span class="hljs-string">`value2`</span>&#125;;<br><br><span class="hljs-comment">/* 等价写法 */</span><br><span class="hljs-comment">//中括号语法：</span><br>obj[<span class="hljs-string">&#x27;key1&#x27;</span>];<br><span class="hljs-comment">//点语法：</span><br>obj.key1;<br></code></pre></div></td></tr></table></figure><p>★ <strong>错误语法：</strong><code>obj[key1];</code>，这表示变量key1，而不是字符串key1。</p><h3 id="增加或修改对象的属性（写）"><a href="#增加或修改对象的属性（写）" class="headerlink" title="增加或修改对象的属性（写）"></a>增加或修改对象的属性（写）</h3><p>直接赋值：</p><h2 id="‘name’-in-obj和onj-hasOwnProperty-‘mame’-的区别"><a href="#‘name’-in-obj和onj-hasOwnProperty-‘mame’-的区别" class="headerlink" title="‘name’ in obj和onj.hasOwnProperty(‘mame’)的区别"></a>‘name’ in obj和onj.hasOwnProperty(‘mame’)的区别</h2><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> obj = &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;andy8421&#x27;</span>&#125; ;<span class="hljs-comment">// name 是字符串</span><br>obj.name = <span class="hljs-string">&#x27;andy8421&#x27;</span>;<span class="hljs-comment">// name 是字符串</span><br>obj[<span class="hljs-string">&#x27;name&#x27;</span>] = <span class="hljs-string">&#x27;andy8421&#x27;</span>; <br>obj[name] = <span class="hljs-string">&#x27;andy8421&#x27;</span>; <span class="hljs-comment">// 错，此处name为变量</span><br>obj[<span class="hljs-string">&#x27;na&#x27;</span>+<span class="hljs-string">&#x27;me&#x27;</span>] = <span class="hljs-string">&#x27;andy8421&#x27;</span>;<br><br><span class="hljs-keyword">let</span> key = <span class="hljs-string">&#x27;name&#x27;</span>; obj[key] = <span class="hljs-string">&#x27;andy8421&#x27;</span>;<br><span class="hljs-keyword">let</span> key = <span class="hljs-string">&#x27;name&#x27;</span>; obj.key = <span class="hljs-string">&#x27;andy8421&#x27;</span>; <span class="hljs-comment">// 错，这表示给obj增加一个属性key，值为andy8421。</span><br></code></pre></div></td></tr></table></figure><p>批量赋值：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">Object</span>.assign(obj, &#123;<span class="hljs-attr">age</span>: <span class="hljs-number">18</span>, <span class="hljs-attr">gender</span>: <span class="hljs-string">&#x27;man&#x27;</span>&#125;);<br></code></pre></div></td></tr></table></figure><h4 id="修改或增加共有属性"><a href="#修改或增加共有属性" class="headerlink" title="修改或增加共有属性"></a>修改或增加共有属性</h4><ul><li>JS默认设定共有属性为<strong>只读</strong>属性。</li><li>无法通过对象自身修改或增加共有属性（修改最终指作用于对象本身，不影响原型）</li></ul><p>强行修该原型的属性的方法：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">obj.__proto__.toString = <span class="hljs-string">&#x27;xxx&#x27;</span>;<span class="hljs-comment">// 不推荐用 __proto__</span><br><span class="hljs-built_in">Object</span>.prototype.toString = <span class="hljs-string">&#x27;xxx&#x27;</span>;<br></code></pre></div></td></tr></table></figure><p>修改对象原型的方法（<strong>修改原型链</strong>）：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">//不推荐使用__proto__</span><br><span class="hljs-comment">//推荐使用Object.create</span><br><span class="hljs-keyword">let</span> obj = <span class="hljs-built_in">Object</span>.create(common);<span class="hljs-comment">//以common为原型创建对象obj</span><br>obj.key = <span class="hljs-string">&#x27;value&#x27;</span>;<br><br><span class="hljs-comment">//或者</span><br><span class="hljs-keyword">let</span> obj = <span class="hljs-built_in">Object</span>.create(common,&#123;<br>    <span class="hljs-attr">key</span>:&#123;<span class="hljs-attr">value</span>:<span class="hljs-string">&#x27;value&#x27;</span>&#125;<br>    ...<br>&#125;);<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>Front end</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript继承</title>
    <link href="/2019/10/29/JavaScript%E7%BB%A7%E6%89%BF/"/>
    <url>/2019/10/29/JavaScript%E7%BB%A7%E6%89%BF/</url>
    
    <content type="html"><![CDATA[<h1 id="JavaScript继承"><a href="#JavaScript继承" class="headerlink" title="JavaScript继承"></a>JavaScript继承</h1><p>谈OOP怎么可能不提继承呢😄！在<a href>原型链</a>中，已经介绍，OOP语言支持两种继承方式：<code>接口继承</code>和<code>实现继承</code>。接口继承只继承方法签名，而实现继承则继承实际的方法。 在 <code>ECMAScript</code> 中无法实现接口继承。<code>ECMAScript</code> 只支持实现继承，而且其实现继承主要是依靠原型链 来实现的。</p><p>《JavaScript高级程序设计（4th）》中介绍了介绍原型链、构造函数继承、组合继承、原型式继承、寄生式继承、寄生组合式继承等6种方法。</p><p>但是通过细心研读可以发现，书中真正推荐使用继承方法只有两个：组合继承（combination inheritance）或寄生组合式继承，以及<code>class</code>关键字</p><h2 id="（寄生）组合继承"><a href="#（寄生）组合继承" class="headerlink" title="（寄生）组合继承"></a>（寄生）组合继承</h2><p>组合继承（combination inheritance）又称伪经典继承（pseudo classical inheritance），它使用原型链实现对原型属性和方法的继承，而通过构造函数实现对实例属性的继承。</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs JavaScript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Parent</span>(<span class="hljs-params">name1</span>)</span>&#123;<br>  <span class="hljs-built_in">this</span>.name1 = name1;<br>&#125;<br>Parent.prototype.pMethod = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name1);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Child</span>(<span class="hljs-params">name2, name1</span>)</span>&#123;<br>    <span class="hljs-comment">// 调用构造函数</span><br>    <span class="hljs-comment">// inherit instance properties</span><br>    Parent.call(<span class="hljs-built_in">this</span>, name1) ;<br>    <span class="hljs-built_in">this</span>.name2 = name2;<br>&#125;<br><br><span class="hljs-keyword">const</span> empty = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;&#125;<br><span class="hljs-comment">// 调用构造函数</span><br><span class="hljs-comment">// inherit instance properties</span><br>empty.prototype = Parent.prototype;<br><span class="hljs-comment">// inherit methods</span><br>Child.prototype = <span class="hljs-keyword">new</span> empty();<br><span class="hljs-comment">// Child.prototype.__proto__ = Parent.prototype ;</span><br><br><br>Child.prototype.cMethod = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name2);<br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li>共用方法写在 <code>Parent.prototype</code> 中，通过原型链实现继承</li><li>非共用属性（<code>name1</code>）放在构造函数中，让每一个实例都有自己的副本</li><li>组合继承方式调用了两次构造函数，一次是创建子类 <code>Child</code> 的原型 <code>prototype</code> 时，一次是在子类的构造函数中借用构造函数时。这样可能得到一些没用的实例属性，同时复杂的构造函数可能会影像性能。</li></ul><p>为了优化这个过程，就出现了寄生组合继承模式：把<code>new</code>关键字换成 <code>Object.create()</code> 方法即可</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs JavaScript"><span class="hljs-comment">// Child.prototype = new Parent();</span><br>Child.prototype = <span class="hljs-built_in">Object</span>.create(Parent.prototype);<br>Child.prototype.constructor = Child;<br>Child.prototype.childMethod = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;&#125;;<br></code></pre></div></td></tr></table></figure><h2 id="基于-class-关键字继承"><a href="#基于-class-关键字继承" class="headerlink" title="基于 class 关键字继承"></a>基于 class 关键字继承</h2><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs JavaScript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parent</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name1</span>)</span>&#123;<br>        <span class="hljs-built_in">this</span>.name1 = name1;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">pMethod</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name1);<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Parent</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name2, name1</span>)</span>&#123;<br>        <span class="hljs-comment">// inherit instance properties</span><br>        <span class="hljs-built_in">super</span>(name1) <span class="hljs-comment">// 调用parent构造函数</span><br>        <span class="hljs-built_in">this</span>.name2 = name2;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">cMethod</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name2);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>派生类的方法可以通过 <code>super</code> 关键字引用它们的原型。这个关键字只能在派生类中使用，而且仅<br>限于类构造函数、实例方法和静态方法内部。在类构造函数中使用 <code>super</code> 可以调用父类构造函数。 </p><p>不能在调用 <code>super</code> 之前使用<code>this</code>，否则会抛出 <code>ReferenceError</code> </p><h2 id="总结：重要继承模式"><a href="#总结：重要继承模式" class="headerlink" title="总结：重要继承模式"></a>总结：重要继承模式</h2><ul><li>原型链继承 : 得到方法<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Parent</span>(<span class="hljs-params"></span>)</span>&#123;&#125;;<br>Parent.prototype.test = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;&#125;;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Child</span>(<span class="hljs-params"></span>)</span>&#123;&#125;;<br>Child.prototype = <span class="hljs-keyword">new</span> Parent(); <span class="hljs-comment">// 子类型的原型指向父类型实例</span><br>Child.prototype.constructor = Child<br><span class="hljs-keyword">var</span> child = <span class="hljs-keyword">new</span> Child(); <span class="hljs-comment">//有test()</span><br></code></pre></div></td></tr></table></figure></li><li>借用构造函数 : inherit instance properties<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Parent</span>(<span class="hljs-params">xxx</span>)</span>&#123;<span class="hljs-built_in">this</span>.xxx = xxx&#125;<br>Parent.prototype.test = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;&#125;;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Child</span>(<span class="hljs-params">xxx,yyy</span>)</span>&#123;<br>    Parent.call(<span class="hljs-built_in">this</span>, xxx);<span class="hljs-comment">//借用构造函数   this.Parent(xxx)</span><br>&#125;<br><span class="hljs-keyword">var</span> child = <span class="hljs-keyword">new</span> Child(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>);  <span class="hljs-comment">//child.xxx为&#x27;a&#x27;, 但child没有test()</span><br></code></pre></div></td></tr></table></figure></li><li>组合<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Parent</span>(<span class="hljs-params">xxx</span>)</span>&#123;<span class="hljs-built_in">this</span>.xxx = xxx&#125;<br>Parent.prototype.test = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;&#125;;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Child</span>(<span class="hljs-params">xxx,yyy</span>)</span>&#123;<br>    Parent.call(<span class="hljs-built_in">this</span>, xxx);<span class="hljs-comment">//借用构造函数   this.Parent(xxx)</span><br>&#125;<br>Child.prototype = <span class="hljs-keyword">new</span> Parent(); <span class="hljs-comment">//得到test()</span><br><span class="hljs-keyword">var</span> child = <span class="hljs-keyword">new</span> Child(); <span class="hljs-comment">//child.xxx为&#x27;a&#x27;, 也有test()</span><br></code></pre></div></td></tr></table></figure></li></ul><ul><li><p>原型式继承—— <a href="%5BObject.create(">Object.create()</a> - JavaScript | MDN (mozilla.org)](<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create</a>)) 的内部逻辑 </p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">object</span>(<span class="hljs-params">o</span>) </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">F</span>(<span class="hljs-params"></span>) </span>&#123;&#125;<br>    F.prototype = o;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> F();<br>&#125;<br></code></pre></div></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>Front end</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavsScript属性类型</title>
    <link href="/2019/10/20/JavaScript%E5%B1%9E%E6%80%A7%E7%B1%BB%E5%9E%8B/"/>
    <url>/2019/10/20/JavaScript%E5%B1%9E%E6%80%A7%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="JavsScript属性类型"><a href="#JavsScript属性类型" class="headerlink" title="JavsScript属性类型"></a>JavsScript属性类型</h1><h2 id="数据属性"><a href="#数据属性" class="headerlink" title="数据属性"></a>数据属性</h2><p>数据属性包含一个数值的位置，这个位置可以读取和写入数值。它有4个描述其行为的特性：<br>    <code>[[Configurable]]</code>：表示能否通过 delete 删除属性从而重新定义属性，默认值为true<br>    <code>[[Enumerable]]</code>：表示能否通过 for-in 循环返回属性。默认值为true<br>    <code>[[Writable]]</code>：表示能否修改属性的值。默认值为true<br>    <code>[[Value]]</code>：包含这个属性的数据值。默认值为undefined<br>（具体细节详见《JavaScript高级程序设计（第4版）》第139页）<br>在ES5中，要修改属性默认的特性必须使用<code>Objext.defineProperty(obj, prop, descriptor)</code>方法。其中描述符对象（descriptor）的属相必须是：configurable，enumerable，writable和value。</p><h2 id="访问器属性"><a href="#访问器属性" class="headerlink" title="访问器属性"></a>访问器属性</h2><p>访问器属性不包含数据值，而是包含一个getter属性和一个setter属性(但这两个属性并不是非要同时设定)。在读取访问器属性时，会调用 getter 函数，这个函数负责返回有效的值；在写入访问器属性时，会调用setter 函数并传入新值，这个函数负责决定如何处理数据。访问器属性有如下 4 个特性。<br>    <code>[[Configurable]]</code>：表示能否通过 delete 删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为数据属性。对于直接在对象上定义的属性，这个特性的默认值为true。<br>    <code>[[Enumerable]]</code>：表示能否通过 for-in 循环返回属性。对于直接在对象上定义的属性，这个特性的默认值为 true。<br>    <code>[[Get]]</code>：在读取属性时调用的函数。默认值为 undefined。<br>    <code>[[Set]]</code>：在写入属性时调用的函数。默认值为 undefined。<br>访问器属性不能直接定义，必须使用Object.defineProperty()来定义。</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> book=&#123;<br>    <span class="hljs-attr">_year</span>:<span class="hljs-number">2004</span>,<span class="hljs-comment">//_year是通过对象方法访问的属性。</span><br>     <span class="hljs-attr">edition</span>:<span class="hljs-number">1</span><br>&#125;;<br><span class="hljs-built_in">Object</span>.defineProperty(book,<span class="hljs-string">&quot;year&quot;</span>,&#123;<span class="hljs-comment">//year是一个访问器属性，包含一个getter函数和setter函数。</span><br>    <span class="hljs-attr">get</span>:  <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<span class="hljs-comment">//读取属性时调用的函数，设置get表示允许读，此处表示以this._year的值返回this.year的值</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>._year;<br>    &#125;,<br>    <span class="hljs-attr">set</span>:  <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">newValue</span>)</span>&#123;<span class="hljs-comment">//在写入属性时调用的函数，设置set表示允许写入，即允许对原对象属性做相关操作</span><br>        <span class="hljs-keyword">if</span>(newValue &gt; <span class="hljs-number">2004</span>)&#123;<br>            <span class="hljs-built_in">this</span>._year = newValue;<br>            <span class="hljs-built_in">this</span>.edition += newValue - <span class="hljs-number">2004</span>;<br>        &#125;<br>    &#125;<br>&#125;);<br>book.year=<span class="hljs-number">2005</span>;<span class="hljs-comment">//把year属性修改为2005会导致_year变成2005，而edition变成2</span><br><span class="hljs-built_in">console</span>.log(book._year + <span class="hljs-string">&#x27;年出第&#x27;</span> + book.edition + <span class="hljs-string">&#x27;版&#x27;</span>);<span class="hljs-comment">//2005年出第2版</span><br></code></pre></div></td></tr></table></figure><p>以上代码创建了一个 book 对象，并给它定义两个默认的属性： _year和edition。_year前面的下划线是一种常用的记号，用于表示只能通过对象方法访问的属性。还定义了一个访问器属性year，包含一个getter函数和一个setter函数。getter函数返回_year的值，setter函数通过计算来确定正确的版本。因此，把 year属性修改为 2005会导致_year变成 2005，而 edition变为 2。这是使用访问器属性的常见方式，即设置一个属性的值会导致其他属性发生变化。具体测试过程见自己总结的CH6Attributies.js</p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>Front end</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript对象</title>
    <link href="/2019/07/29/JavaScript%E5%AF%B9%E8%B1%A1/"/>
    <url>/2019/07/29/JavaScript%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="JavaScript对象"><a href="#JavaScript对象" class="headerlink" title="JavaScript对象"></a>JavaScript对象</h1><p>OOP似乎是编程领域绝对避不开的话题😄。我个人的理解面向对象就是对问题的抽象，将问题抽象成一个个小的模块分而治之，模块之间的关系尽量单一清晰，这样代码在扩展和维护的时候所花费的精力最小，也就是所谓的高内聚，低耦合。之所以它并不容易掌握，就是这个抽象能力是需要通过各种复杂的问题不断训练的。很多时候我们只是想着将写出来的代码进行复用，不要写出重复的代码，但其实最重要的是对问题的抽象，划分出合理的模块和设计模块之间的耦合关系，代码复用只是这个过程中自然而然产生的现象，我们应该明白问题的本质。</p><p>JavaScript并不像一些强类型语言那样使用class继承，而是基于原型的方式继承。从ES6开始，出现了<code>class</code>关键字，这让JavaScript看看起来更像面向对象的编程语言。但是，实际上ES6的<code>class</code>关键字不过是原型继承的语法糖而已。</p><h2 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h2><h3 id="①-工厂模式-Factory-Pattern-创建类对象"><a href="#①-工厂模式-Factory-Pattern-创建类对象" class="headerlink" title="① 工厂模式(Factory Pattern)创建类对象"></a>① 工厂模式(Factory Pattern)创建类对象</h3><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Car</span>(<span class="hljs-params">color,doors,oil</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> tempCar = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();<br>     tempCar.color = <span class="hljs-string">&#x27;red&#x27;</span>;<br>     tempCar.doors = <span class="hljs-number">4</span>;<br>     tempCar.oil = <span class="hljs-string">&#x27;10%&#x27;</span>;<br>     tempCar.showOil = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>          alert(<span class="hljs-built_in">this</span>.oil);<br>     &#125;;<br>     <span class="hljs-keyword">return</span> tempCar;<br>&#125;<br><br><span class="hljs-keyword">let</span> car = Car(<span class="hljs-string">&#x27;red&#x27;</span>,<span class="hljs-number">4</span>,<span class="hljs-number">75</span>%);<br></code></pre></div></td></tr></table></figure><ul><li> 工厂模式创建对象非常<strong>容易理解</strong>，将创建对象，添加属性的过程封装为一个函数，属性值作为函数的参数传入，当我们想要一个对象的时候，执行这个函数即可。</li><li> 但是工厂模式有一个<strong>缺点</strong>，就是所有有其创建的实例都是使用用<code>Object</code>构造的，不易区分。</li></ul><h3 id="②-构造函数-constructor-创建类"><a href="#②-构造函数-constructor-创建类" class="headerlink" title="② 构造函数(constructor)创建类"></a>② 构造函数(constructor)创建类</h3><ul><li>构造函数相比工厂函数的区别在于:构造函数方法的目的是创建模版，使用了<code>this</code>关键字。</li></ul><p>与工厂模式相比，构造函数方法<strong>优点</strong>是<strong>没有显式地创建对象</strong>，而是直接将属性和方法赋值给了<code>this</code>对象，在构造函数内部，<code>this</code>指向构造出来的内部对象。此外，这种方法没有<code>return</code>语句,构造函数默认返回this，即新实例对象 。其次构造函数创建的对象<strong>可识别</strong>。</p><p>调用函数时，构造函数创建类<strong>一定会使用</strong><code>new</code>操作符。</p><ul><li>构造函数没有返回值，这一点类似于一些语言创建类的方法（例如Java、C++和Python都以 class 关键字来创建类，都没有return关键字）<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Vehicle</span>(<span class="hljs-params">vCholor,vDoors,vOil</span>)</span>&#123;<br>    <span class="hljs-built_in">this</span>.color = vCholor;<br>    <span class="hljs-built_in">this</span>.doors = vDoors;<br>    <span class="hljs-built_in">this</span>.oil = vOil;<br>   <span class="hljs-built_in">this</span>.showOil = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    alert(<span class="hljs-built_in">this</span>.oil);<br>    &#125;;<br>&#125;<br><br><span class="hljs-keyword">let</span> vehicle1 = <span class="hljs-keyword">new</span> Vehicle(<span class="hljs-string">&#x27;red&#x27;</span>,<span class="hljs-number">4</span>,<span class="hljs-string">&#x27;75%&#x27;</span>);<br><br><span class="hljs-built_in">console</span>.log(vehicle1.constructor === Vehicle);    <span class="hljs-comment">//true</span><br><span class="hljs-built_in">console</span>.log(vehicle1 <span class="hljs-keyword">instanceof</span> Vehicle);   <span class="hljs-comment">//true</span><br></code></pre></div></td></tr></table></figure></li></ul><p>当然，构造函数也有<strong>缺点</strong>：会将方法在每个实例上都创建一遍。</p><h3 id="③-基于原型-构造函数创建类对象"><a href="#③-基于原型-构造函数创建类对象" class="headerlink" title="③ 基于原型+构造函数创建类对象"></a>③ 基于原型+构造函数创建类对象</h3><p>这种方法完全基于JavaScript原型机制创建，体现出原型继承思想的精髓。</p><ul><li>每创建一个函数就有一个prototype（原型）属性，这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。如果按照字面意思来理解，那么 prototype 就是通过调用构造函数而创建的那个对象实例的原型对象。使用原型对象的好处是可以让所有对象实例共享它所包含的属性和方法。<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params">name,age</span>) </span>&#123;<br>    <span class="hljs-built_in">this</span>.name = name;<br>    <span class="hljs-built_in">this</span>.age = age;<br>    <span class="hljs-built_in">this</span>.frients = [<span class="hljs-string">&#x27;JackieChan&#x27;</span>, <span class="hljs-string">&#x27;EasonChan&#x27;</span>];<br>&#125;;<br>Person.prototype = &#123;<br>    <span class="hljs-attr">constructor</span>: Person,<br><span class="hljs-attr">job</span>: <span class="hljs-string">&quot;Software Engineer&quot;</span>,<br>sayName () &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.name;<br>    &#125;<br>&#125;;<br><span class="hljs-keyword">let</span> person1 = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;andy8421&quot;</span>, <span class="hljs-number">18</span>);<br><span class="hljs-keyword">let</span> person2 = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;googleplex&quot;</span>, <span class="hljs-number">25</span>);<br><span class="hljs-comment">// 也可以使用Object.create()方法创建实例</span><br></code></pre></div></td></tr></table></figure>使用这种方法是有一个关键点：引用类型<strong>不要</strong>放到原型上，例如上代码中<code>this.frients = [&#39;JackieChan&#39;, &#39;EasonChan&#39;];</code>不能放到<code>Person.prototype</code>中，否则会出现修改冲突：当person1修改friends时，person2的friends也会被修改。这也是为什么一般不单独使用原型模式创建对象，而是使用原型+构造函数组合模式创建的原因。</li></ul><h3 id="④-class关键字"><a href="#④-class关键字" class="headerlink" title="④ class关键字"></a>④ class关键字</h3><p>从ES6开始出现<code>class</code>关键字，它使得JavaScript看起来更像面向对象的编程语言。然而实质上，<code>class</code>关键字是基于原型+构造函数创建类对象的一个<code>语法糖</code>而已。</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name,age</span>)</span>&#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    <span class="hljs-built_in">this</span>.frients = [<span class="hljs-string">&#x27;JackieChan&#x27;</span>, <span class="hljs-string">&#x27;EasonChan&#x27;</span>];<br>    &#125;<br>    job = <span class="hljs-string">&quot;Software Engineer&quot;</span>;<br>sayName () &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.name;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">let</span> person1 = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;andy8421&quot;</span>, <span class="hljs-number">18</span>);<br><span class="hljs-keyword">let</span> person2 = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;googleplex&quot;</span>, <span class="hljs-number">25</span>);<br><span class="hljs-comment">// 也可以使用Object.create()方法创建实例</span><br></code></pre></div></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="对象的创建模式"><a href="#对象的创建模式" class="headerlink" title="对象的创建模式"></a>对象的创建模式</h3><ul><li><p>Object构造函数模式</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;&#125;;<br>obj.name = <span class="hljs-string">&#x27;Tom&#x27;</span><br>obj.setName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name</span>)</span>&#123;<span class="hljs-built_in">this</span>.name=name&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>对象字面量模式</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;<br>  <span class="hljs-attr">name</span> : <span class="hljs-string">&#x27;Tom&#x27;</span>,<br>  <span class="hljs-attr">setName</span> : <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name</span>)</span>&#123;<span class="hljs-built_in">this</span>.name = name&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>构造函数模式</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params">name, age</span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.name = name;<br>  <span class="hljs-built_in">this</span>.age = age;<br>  <span class="hljs-built_in">this</span>.setName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name</span>)</span>&#123;<span class="hljs-built_in">this</span>.name=name;&#125;;<br>&#125;<br><span class="hljs-keyword">new</span> Person(<span class="hljs-string">&#x27;tom&#x27;</span>, <span class="hljs-number">12</span>);<br></code></pre></div></td></tr></table></figure></li><li><p>构造函数+原型的组合模式</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params">name, age</span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.name = name;<br>  <span class="hljs-built_in">this</span>.age = age;<br>&#125;<br>Person.prototype.setName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name</span>)</span>&#123;<span class="hljs-built_in">this</span>.name=name;&#125;;<br><span class="hljs-keyword">new</span> Person(<span class="hljs-string">&#x27;tom&#x27;</span>, <span class="hljs-number">12</span>);<br></code></pre></div></td></tr></table></figure></li><li><p>class关键字</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span> </span>&#123;&#125;<br><br><span class="hljs-comment">// 构造函数的类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bar</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;&#125;<br>&#125;<br><br><span class="hljs-comment">// 获取函数的类 </span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Baz</span> </span>&#123;<br><span class="hljs-keyword">get</span> <span class="hljs-title">myBaz</span>() &#123;&#125;<br>&#125;<br><br><span class="hljs-comment">//静态方法的类 </span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Qux</span> </span>&#123;<br><span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-title">myQux</span>(<span class="hljs-params"></span>)</span> &#123;&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="OOP的特点"><a href="#OOP的特点" class="headerlink" title="OOP的特点"></a>OOP的特点</h3></li></ul><ul><li>面向对象（OOP）的三大基本特性</li></ul><blockquote><p>封装：隐藏对象的属性和实现细节，仅对外公开接口，控制程序中属性读和修改的访问级。将数据与操作数据的源代码进行有机结合，形成‘类’。其中的数据和函数都是类的成员。<br>继承：使子类具有父类的属性。<br>多态：同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果。</p></blockquote><ul><li>面向对象语言的四个基本准则：</li></ul><blockquote><p>抽象：忽略主题中与当前目标无关的那些方面，以便更充分地注意与当前目标有关的方面。<br>继承: 使得子类具有父类的属性和方法或者重新定义、追加属性和方法等。<br>封装: 隐藏对象的属性和实现细节，仅对外公开接口，控制在程序中属性的读和修改的访问级别<br>多态: 接口可以有多种不同的实现方式</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>Front end</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>原型链</title>
    <link href="/2019/07/25/%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    <url>/2019/07/25/%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
    
    <content type="html"><![CDATA[<p>.</p><!--more--><h3 id="显式原型和隐式原型基本概念"><a href="#显式原型和隐式原型基本概念" class="headerlink" title="显式原型和隐式原型基本概念"></a>显式原型和隐式原型基本概念</h3><ul><li><p>所有的构造函数(对象)都有一个属性:</p><ul><li><code>prototype</code> : 显式原型(属性)，默认指向它的原型对象。显示原型在定义函数时自动添加，一般可以进行人为操作。</li><li>每个原型对象中有一个属性：constructor，默认指向这个函数对象</li></ul></li><li><p>由函数对象创建的实例对象都有一个属性:</p><ul><li><code>[[Prototype]]</code>(实际中是<code>__proto__</code>) : 隐式原型(属性)，默认指向它构造函数对象的原型对象。隐式原型在创建对象时自动添加，它是内部指针，一般禁止对其进行直接操作。<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params"></span>)</span>&#123;<br>&#125;<br><br>Person.prototype.name = <span class="hljs-string">&#x27;Nicholas&#x27;</span>;<br>Person.prototype.age = <span class="hljs-number">29</span>;<br>Person.prototype.job = <span class="hljs-string">&#x27;Software Engineer&#x27;</span>;<br>Person.prototype.sayName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name);<br>&#125;;<br><br><span class="hljs-keyword">var</span> person1 = <span class="hljs-keyword">new</span> Person();<br><span class="hljs-keyword">var</span> person2 = <span class="hljs-keyword">new</span> Person();<br><span class="hljs-built_in">console</span>.log(person1.sayName === person2.sayName);    <span class="hljs-comment">//true</span><br></code></pre></div></td></tr></table></figure><img src="/2019/07/25/%E5%8E%9F%E5%9E%8B%E9%93%BE/%E6%98%BE%E7%A4%BA%E5%8E%9F%E5%9E%8B%E5%92%8C%E9%9A%90%E5%BC%8F%E5%8E%9F%E5%9E%8B.png" alt="enter description here"></li></ul></li></ul><p><strong>显式原型和隐形原型的关系</strong>：构造函数的显式原型的值和它实例对象的隐式原型的值相同,都指向构造函数的原型对象。</p><h3 id="显式原型和隐式原型的生成过程"><a href="#显式原型和隐式原型的生成过程" class="headerlink" title="显式原型和隐式原型的生成过程"></a>显式原型和隐式原型的生成过程</h3><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">//定义构造函数</span><br>   <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Fn</span>(<span class="hljs-params"></span>) </span>&#123;   <span class="hljs-comment">// 内部语句: this.prototype = &#123;&#125;;</span><br>   &#125;<br><br>   <span class="hljs-comment">// 1. 每个函数function都有一个prototype，即显式原型, 默认指向一个空的Object对象</span><br>   <span class="hljs-built_in">console</span>.log(Fn.prototype);<br><br>   <span class="hljs-comment">// 2. 每个实例对象都有一个__proto__，即隐式原型</span><br>   <span class="hljs-keyword">var</span> fn = <span class="hljs-keyword">new</span> Fn();  <span class="hljs-comment">// 内部语句: this.__proto__ = Fn.prototype</span><br>   <span class="hljs-built_in">console</span>.log(fn.__proto__);<br><br>   <span class="hljs-comment">// 3. 对象的隐式原型的值为其对应构造函数的显式原型的值（构造函数的显式原型对象 === 其构造函数实例对象的隐式原型对象）</span><br>   <span class="hljs-built_in">console</span>.log(Fn.prototype === fn.__proto__); <span class="hljs-comment">// true</span><br><br>   <span class="hljs-comment">//给原型添加方法</span><br>   Fn.prototype.test = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>       <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;test()&#x27;</span>);<br>   &#125;;<br>   <span class="hljs-comment">//通过实例调用原型的方法</span><br>   fn.test();<br></code></pre></div></td></tr></table></figure><p>以上过程的内存解析：<br><img src="/2019/07/25/%E5%8E%9F%E5%9E%8B%E9%93%BE/%E5%8E%9F%E5%9E%8B%E5%86%85%E5%AD%98%E8%A7%A3%E6%9E%90.png" alt="原型内存解析"></p><p><strong>显示原型和隐式原型</strong></p><ol><li>每创建一个函数，该函数就有一个prototype，即显式原型属性（简称显式原型），指向一个空的Object对象（原型对象）</li><li>每给函数创建一个实例对象，该对象就有一个__proto__（书写上写作[[prototype]]）, 即隐式原型属性（简称隐式原型），其值为其对应构造函数的显式原型的值。简而言之，隐式原型和显式原型中保存的地址值是相同的，都指向原型对象。ES5之前的版本，一般不宜对__proto__做直接操作。</li><li>对象的隐式原型的值为其对应构造函数显式原型的值</li><li>对于函数Function()，它有一个prototype，该函数自身的实例对象Function有一个__proto__。它们都指向原型对象。简而言之，Function函数的显式原型和该函数自己创建的隐式原型的值相同（其他函数并不存在这一点特征）。</li><li><strong>函数所有实例的隐式原型__proto__的值都等于该函数显式原型prototype的值，并等于原型对象的地址。</strong></li></ol><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Fn</span>(<span class="hljs-params"></span>) </span>&#123;<br>     <span class="hljs-comment">//浏览器引擎内部自动添加语句：this.prototype = &#123; &#125;;</span><br>&#125;<br><span class="hljs-built_in">console</span>.log(Fn.prototype);  <span class="hljs-comment">//一个Object实例</span><br><span class="hljs-keyword">var</span> fn = <span class="hljs-keyword">new</span> Fn();<br><span class="hljs-built_in">console</span>.log(fn.__proto__);     <span class="hljs-comment">//内部语句：this.__proto__ = Fn.prototype</span><br><span class="hljs-built_in">console</span>.log(Fn.prototype === fn.__proto__);     <span class="hljs-comment">//true</span><br><br><span class="hljs-comment">//给原型对象添加方法</span><br>Fn.prototype.test = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;test&#x27;</span>);<br>&#125;<br>fn.test();      <span class="hljs-comment">//test。这一步是通过实例对象调用原型对象的方法。当实例对象中没有外部属性时，浏览器自动根据__proto__的值，即原型对象的地址，来寻找原型对象中的相关属性。</span><br><br><span class="hljs-built_in">console</span>.log(fn.__proto__ === Fn.prototype); <span class="hljs-comment">//true</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Function</span>.__proto__ === <span class="hljs-built_in">Function</span>.prototype); <span class="hljs-comment">//true</span><br><span class="hljs-built_in">console</span>.log(Fn.__proto__ === Fn.prototype);  <span class="hljs-comment">//false</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.prototype.__proto__);       <span class="hljs-comment">//null</span><br></code></pre></div></td></tr></table></figure><h1 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h1><p>原型链（隐式原型属性链）：访问一个对象属性时，先在自身属性中查找，可以找到就返回该属性值；若没有找到，则沿着__proto__这条链依次向上查找；若果在Object原型对象（原型链的尽头）仍没有找到该属性，则返回undefined。</p><p>但是JavaScript设定：Object的原型对象指向null</p><p>许多面向对象语言都支持两种继承方式：<code>接口继承</code>和<code>实现继承</code>。接口继承只继承方法签名，而实现继承则继承实际的方法。由于函数没有签名，在 ECMAScript中无法实现接口继承。ECMAScript只支持实现继承，而且其实现继承主要是依靠原型链（又称隐式原型链）来实现的。</p><p><strong>主要思想</strong>：利用原型让一个引用类型继承另一个引用类型的属性和方法。<br><strong>依据</strong>：每一个构造函数都有一个原型对象，原型对象包含一个指向构造函数的指针（<code>constructor</code>），而函数的实例对象都存在一个指向原型对象的指针（<code>__proto__</code>）。假如实例所指向的原型对象本身又是另一个构造函数的实例对象（称另一个类的实例），那么此时原型对象（记为原型对象1）中就包含一个指向另一个原型对象（记为原型对象2）的指针，相应的，另一个原型对象包含一个指向另一个构造函数的指针。进一步可知，原实例对象与原型对象2的关系是：原实例对象的隐式原型的隐式原型指向原型对象2。事实上，原型对象2是原型对象1的父类型，原型对象1是原实例对象的父类型。<br><strong>原型链的作用</strong>：访问对象属性</p><ul><li>访问一个对象的属性时，<br>① 先在实例对象自身属性中查找，看是否有该属性，若找到则直接返回该属性<br>② 如果没有找到, 再沿着<code>__proto__</code>这条链(即原型链)向上查找, 直到找到则返回该属性<br>③ 若始终没有找到，这种沿着原型链向上游查找也不是无限制的。JS中，一切对象都是Object()的实例对象，所以，它的原型对象将作为查找的终点。如果最终在Object()的原型对象Object.prototype中仍没有找到该属性, 则返回undefined（这个对象再没有实际指向了，它的隐式原型<code>Object.prototype.__proto__</code>值为null，是个空指针）<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">//创建父类</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params">name, age</span>) </span>&#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.age = age;<br>&#125;<br><br><span class="hljs-comment">//创建子类</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Student</span>(<span class="hljs-params">name, age, sex</span>) </span>&#123;<br>    Person.call(<span class="hljs-built_in">this</span>, name, age);  <span class="hljs-comment">// 提取父类的属性</span><br>    <span class="hljs-built_in">this</span>.sex = sex; <span class="hljs-comment">//子类自己添加sex属性</span><br>&#125;<br><br>    Student.prototype = <span class="hljs-keyword">new</span> Person();  <span class="hljs-comment">// 真正实现继承</span><br>    Student.prototype.constructor = Student;  <span class="hljs-comment">//修正constructor属性</span><br><br><span class="hljs-comment">//为Student创建一个实例对象girl</span><br><span class="hljs-keyword">var</span> girl = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;silybily&quot;</span>, <span class="hljs-number">26</span>, <span class="hljs-string">&quot;female&quot;</span>);<br><br><span class="hljs-comment">//检验：</span><br><span class="hljs-built_in">console</span>.log(girl);<br>girl.__proto__ === Student.prototype;  <span class="hljs-comment">//true</span><br>girl.__proto__.__proto__ ===  Person.prototype;  <span class="hljs-comment">//true</span><br>girl.__proto__.__proto__.__proto__ === <span class="hljs-built_in">Object</span>.prototype;<span class="hljs-comment">//true</span><br>girl.__proto__.__proto__.__proto__.__proto__ === <span class="hljs-literal">null</span>;  <span class="hljs-comment">//true</span><br><br><span class="hljs-built_in">console</span>.log(girl.name);   <span class="hljs-comment">//silybily</span><br><span class="hljs-built_in">console</span>.log(girl.hobby);  <span class="hljs-comment">//undefined</span><br></code></pre></div></td></tr></table></figure><img src="/2019/07/25/%E5%8E%9F%E5%9E%8B%E9%93%BE/%E5%8E%9F%E5%9E%8B%E9%93%BE.png" alt="原型链"><br>有一点需要特别注意的是：构造函数本身，首先是一个对象，理解了这一点，上面的过成就不难理解了</li></ul><h1 id="探索instanceof"><a href="#探索instanceof" class="headerlink" title="探索instanceof"></a>探索instanceof</h1><p><strong>作用</strong>：判断函数的显式原型是否在另一个对象的原型链上<br><strong>语法</strong>：<code>A instanceof B</code> 判断<code>B函数的显式原型</code>是否在<code>A对象</code>的原型链上。如果存在则返回true，否则返回false</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">//案例1</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Foo</span>(<span class="hljs-params"></span>) </span>&#123;  &#125;<br><span class="hljs-keyword">var</span> f1 = <span class="hljs-keyword">new</span> Foo();<br><span class="hljs-built_in">console</span>.log(f1 <span class="hljs-keyword">instanceof</span> Foo);  <span class="hljs-comment">// true</span><br><span class="hljs-built_in">console</span>.log(f1 <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Object</span>);  <span class="hljs-comment">// true</span><br></code></pre></div></td></tr></table></figure><p>由<code>function Foo() &#123;  &#125;</code>，构造函数Foo()的显式原型指向一个空的Object原型对象{ }<br>由<code>var f1 = new Foo();</code>，声明了一个变量f1指向函数Foo()的实例对象<br>由以上两步可知，<code>Foo.prototype === f1.__proto__ === &#123; &#125;</code>因此Foo()的显式原型在对象f1的原型链上<br>Object是任何实例的构造函数，显然在f1的原型链上</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">//案例二</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Function</span>); <span class="hljs-comment">// true</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Object</span>); <span class="hljs-comment">// true</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Function</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Function</span>); <span class="hljs-comment">// true</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Function</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Object</span>); <span class="hljs-comment">// true</span><br></code></pre></div></td></tr></table></figure><p>这个是怎么一回事呢？仍要回头看instanceof得定义：A instanceof B判断A的原型链上是否存在B.prototype。而在JavaScript中，Object和Function之间的关系可以用一张图来说明：<br><img src="/2019/07/25/%E5%8E%9F%E5%9E%8B%E9%93%BE/Function%E5%92%8CObject.png" alt="enter description here"><br>从上图中抽离Function和Object的关系，即：<br> <img src="/2019/07/25/%E5%8E%9F%E5%9E%8B%E9%93%BE/%E6%8A%BD%E7%A6%BBFunction%E5%92%8CObject%E7%9A%84%E5%85%B3%E7%B3%BB%E5%9B%BE.png" alt="enter description here"><br>根据该图①，再来看一下代码就一目了然了：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">//①构造器Function的构造器是它自身</span><br><span class="hljs-built_in">Function</span>.constructor=== <span class="hljs-built_in">Function</span>;  <span class="hljs-comment">//true</span><br><br><span class="hljs-comment">//②构造器Object的构造器是Function（由此可知所有构造器的constructor都指向Function）</span><br><span class="hljs-built_in">Object</span>.constructor === <span class="hljs-built_in">Function</span>;  <span class="hljs-comment">//true</span><br><br><span class="hljs-comment">//③构造器Function的__proto__是一个特殊的匿名函数function() &#123;&#125;</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Function</span>.__proto__);  <span class="hljs-comment">//function() &#123;&#125;</span><br><br><span class="hljs-comment">//④这个特殊的匿名函数的__proto__指向Object的prototype原型。</span><br><span class="hljs-built_in">Function</span>.__proto__.__proto__ === <span class="hljs-built_in">Object</span>.prototype;  <span class="hljs-comment">//true</span><br><br><span class="hljs-comment">//⑤Object的__proto__指向Function的prototype，也就是上面③中所述的特殊匿名函数</span><br><span class="hljs-built_in">Object</span>.__proto__ === <span class="hljs-built_in">Function</span>.prototype;  <span class="hljs-comment">//true</span><br><span class="hljs-built_in">Function</span>.prototype === <span class="hljs-built_in">Function</span>.__proto__;  <span class="hljs-comment">//true</span><br></code></pre></div></td></tr></table></figure><p>如果看完以上，你还觉得上面的关系看晕了的话，只需要记住下面两个最重要的关系，其他关系就可以推导出来了：</p><p>1、所有的构造器的constructor都指向Function</p><p>2、Function的prototype指向一个特殊匿名函数，而这个特殊匿名函数的__proto__指向Object.prototype</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>显式原型与隐式原型的关系<ul><li>函数的prototype: 定义函数时被自动赋值, 原型对象的值默认为{}</li><li>实例对象的__proto__: 在创建实例对象时被自动添加, 并赋值为构造函数的prototype值</li><li>原型对象即为当前实例对象的父对象</li></ul></li><li>原型链<ul><li>所有的实例对象都有__proto__属性, 它指向的就是原型对象</li><li>这样通过__proto__属性就形成了一个链的结构—-&gt;原型链</li><li>当给对象属性赋值时不会使用原型链, 而只是在当前对象中进行操作</li><li>当查找对象内部的属性/方法时, js引擎自动沿着这个原型链查找</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>Front end</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS小结</title>
    <link href="/2019/06/28/CSS%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    <url>/2019/06/28/CSS%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="CSS小结"><a href="#CSS小结" class="headerlink" title="CSS小结"></a>CSS小结</h1><h3 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL;DR"></a>TL;DR</h3><p><strong>防止margin合并的方法</strong>：</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-comment">/* 防止同级元素发生margin合并： */</span><br><span class="hljs-selector-class">.chiled</span>&#123;<br>    <span class="hljs-attribute">display</span>:inline-block;<br>&#125;<br><br><span class="hljs-comment">/* 防止子元素和父级元素发生margin合并 */</span><br><span class="hljs-selector-class">.parent</span>&#123;<br>  <span class="hljs-comment">/* 方法一：父级元素添加border（top或bottom） */</span><br>    <span class="hljs-attribute">border-top</span>:<span class="hljs-number">1px</span> solid red;<br>  <span class="hljs-comment">/* 方法二：父级元素添加padding */</span><br>    <span class="hljs-attribute">padding</span>:<span class="hljs-number">1px</span>;<br>  <span class="hljs-comment">/* 方法三：父级元素添加overflow:hidden; */</span><br>    <span class="hljs-attribute">overflow</span>:hidden;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>float 布局</strong></p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-comment">/*避免元素脱离文档流。使用float布局时，此选择器必须写*/</span><br><span class="hljs-selector-class">.clearfix</span>&#123;<br>    <span class="hljs-attribute">content</span>:<span class="hljs-string">&#x27;&#x27;</span>;<br> <span class="hljs-attribute">display</span>:block;<br>    <span class="hljs-attribute">clear</span>:both;<br>&#125;<br><br><span class="hljs-comment">/*设置float布局*/</span><br><span class="hljs-selector-class">.floatelement</span>&#123;<br>    <span class="hljs-attribute">float</span><span class="hljs-selector-pseudo">:left</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>flex控制元素水平垂直居中</strong></p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span>&#123;<br>  <span class="hljs-attribute">display</span>:flex;<br>  <span class="hljs-attribute">justify-content</span>:center;<br>  <span class="hljs-attribute">align-items</span>:center;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100vh</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="CSS动画"><a href="#CSS动画" class="headerlink" title="CSS动画"></a>CSS动画</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/transition"><code>transition</code></a>可以为一个元素在不同状态之间切换的时候定义不同的<strong>过渡动画</strong>效果。比如在不同的伪元素之间切换，像是 <code>:hover</code>，<code>:active</code> 或者通过 JavaScript 实现的状态变化。</p><p>伪代码举例：</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.heart</span>&#123;<br>     <span class="hljs-attribute">transition</span>:all <span class="hljs-number">1s</span>;<br>     <span class="hljs-comment">/* transition定义:hover的过度动画为1s内完成全部动作 */</span><br>&#125;<br><br><span class="hljs-selector-class">.heart</span><span class="hljs-selector-pseudo">:hover</span>&#123;<br>    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">scale</span>(<span class="hljs-number">1.2</span>);<br>    <span class="hljs-comment">/* 缩放或扩大 */</span><br>    <span class="hljs-comment">/* transform: translate(50px); */</span><br>    <span class="hljs-comment">/* 位移*/</span><br>    <span class="hljs-comment">/* transform: rotate(-135deg); */</span><br>    <span class="hljs-comment">/* 旋转*/</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/animation"><code>animation</code></a>定义了元素在<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/@keyframes"><strong>关键帧</strong>（<code>@keyframes</code>）</a>之间变化的参数，间接控制动画效果。</p><p>伪代码举例：</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.heart</span>&#123;<br>    <span class="hljs-attribute">animation</span>:.<span class="hljs-number">5s</span> heart infinite alternate;<br>    / * <span class="hljs-attribute">animation</span>定义heart关键帧之间变化的动画效果在<span class="hljs-number">0.5s</span>以内完成（周期<span class="hljs-number">0.5s</span>），infinite表示动画效果无限次循环，alternate表示在关键帧之间循环往复 */<br>&#125;<br><br><span class="hljs-keyword">@keyframes</span> heart&#123;<br>    <span class="hljs-number">0%</span>&#123;<br>        <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">scale</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-number">50%</span>&#123;<br>        <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">scale</span>(<span class="hljs-number">1.2</span>)<br>    &#125;<br>    <span class="hljs-number">100%</span>&#123;<br>        <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">scale</span>(<span class="hljs-number">1.5</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/* @keyframes heart&#123;</span><br><span class="hljs-comment">    from&#123;</span><br><span class="hljs-comment">        transform: scale(1);</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">    to&#123;</span><br><span class="hljs-comment">        transform: scale(1.5);</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">&#125; */</span><br><span class="hljs-comment">/* from先当于0%，to相当于100% */</span><br></code></pre></div></td></tr></table></figure><h3 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h3><p><a href="https://yichang8421.github.io/css-demo-HeartSheep/">用纯CSS制作红心（transition配合:hover）</a></p><p>源码：<a href="https://github.com/yichang8421/css-demo-HeartSheep/blob/main/index.html">https://github.com/yichang8421/css-demo-HeartSheep/blob/main/index.html</a></p><p><a href="https://yichang8421.github.io/BeatingHeart/">用纯CSS制作跳动的心（animation）</a></p><p>源码：<a href="https://github.com/yichang8421/BeatingHeart">https://github.com/yichang8421/BeatingHeart</a></p><h2 id="浏览器渲染过程"><a href="#浏览器渲染过程" class="headerlink" title="浏览器渲染过程"></a>浏览器渲染过程</h2><p>参考：<a href="https://developer.mozilla.org/zh-CN/docs/Web/Performance/How_browsers_work">渲染页面：浏览器的工作原理</a></p><p><strong>解析</strong>：</p><ol><li>构建DOM树：处理HTML标记并构造DOM树。</li><li>构建CSSOM树：处理CSS并构建CSSOM树。</li></ol><p><strong>渲染</strong>：</p><ol start="3"><li><p>构建Render树：将DOM和CSSOM组合成一个Render树。</p></li><li><p>Layout布局：在渲染树上运行布局以计算每个节点的几何体。例如，文档流、盒模型、计算大小和位置</p></li><li><p>Paint：将各个节点边框颜色、文字颜色、阴影等绘制到屏幕上。</p></li><li><p>Compose合成：根据层叠关系展示画面。当文档的各个部分以不同的层绘制，相互重叠时，必须进行合成，以确保它们以正确的顺序绘制到屏幕上，并正确显示内容。</p></li></ol><p>使用js更新样式时，浏览器有三种更新方式：</p><p><img src="/2019/06/28/CSS%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/1615733900881.png" alt="1615733900881"></p><h3 id="CSS动画优化总结"><a href="#CSS动画优化总结" class="headerlink" title="CSS动画优化总结"></a>CSS动画优化总结</h3><p>参考：<a href="https://developers.google.com/web/fundamentals/performance/rendering/optimize-javascript-execution">https://developers.google.com/web/fundamentals/performance/rendering/optimize-javascript-execution</a></p><p>​    <strong>JS优化</strong>：<code>setTimeout</code>/<code>setInterval</code> =&gt; <code>requestAnimationFrame</code></p><p>   <strong>CSS优化</strong>：<code>left</code>/<code>right</code>/<code>top</code>/<code>bottom</code> =&gt; <code>transform:translate</code></p><h2 id="文档流"><a href="#文档流" class="headerlink" title="文档流"></a>文档流</h2><p>inline 从左到右，超过部分会分割换行。宽度由其内inline元素的宽度之和决定。高度由<strong>行高</strong>间接确定，一般设置的只是inline的可视高度。</p><p>block 从上到小，独占一行。宽度为auto。高度为其内文档流元素的高度之和决定。</p><p>（经验：**尽量不要写width: 100%**）</p><p>inline-block  从左到右，会换行但是元素成块不会分割跨行。</p><p>文档流超出边框时overflow，一般只使用<code>overflew: auto;</code></p><p>overflew: visible；</p><p>overflew: hidden;</p><p>overflew: auto;</p><p>overflew: scroll;  横纵向都有滚动条，这个值可以完全被auto替代。</p><h3 id="脱离文档流"><a href="#脱离文档流" class="headerlink" title="脱离文档流"></a>脱离文档流</h3><p>元素脱离文档流的方法：</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-comment">/*方法一：position设为absolute或fixed*/</span><br><span class="hljs-attribute">position</span>: absolute;<br><span class="hljs-comment">/*方法二：*/</span><br><span class="hljs-attribute">float</span>: left;<br></code></pre></div></td></tr></table></figure><h2 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h2><p>盒模型是网页布局的基础，它制定了元素如何在页面中显示。</p><ul><li><p>css中盒模型按boder-sizing的不同分为content-box和border-box。</p></li><li><p>二者的区别是content-box宽度只包含content（内容）；而border-box宽度包含border（边框）、padding（内边距）、content（内容）。</p></li><li><p>当没有指定border和padding值时，二者是相同的。</p></li></ul><p>实际开发中使用border-box更多。</p><h3 id="margin合并"><a href="#margin合并" class="headerlink" title="margin合并"></a>margin合并</h3><p>元素设置margin值时可能会出现合并问题：</p><ul><li><p>margin合并问题只出现在两个元素<strong>垂直方向</strong>上同时设置margin时，水平方向同时设置margin<strong>不会</strong>出现此问题。</p></li><li><p>当垂直方向上兄弟元素同时设置上下margin时，则兄弟元素的上下margin会重合。</p></li><li><p>当父级元素和孩子元素同时设置上下margin时，则父级元素会和其<strong>第一个</strong>孩子元素以及<strong>最后一个</strong>孩子元素发生margin重合。</p></li></ul><p><strong>防止margin合并的方法</strong>：</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-comment">/* 防止同级元素发生margin合并： */</span><br><span class="hljs-selector-class">.chiled</span>&#123;<br>    <span class="hljs-attribute">display</span>:inline-block;<br>&#125;<br><br><span class="hljs-comment">/* 防止子元素和父级元素发生margin合并 */</span><br><span class="hljs-selector-class">.parent</span>&#123;<br>  <span class="hljs-comment">/* 方法一：父级元素添加border（top或bottom） */</span><br>    <span class="hljs-attribute">border-top</span>:<span class="hljs-number">1px</span> solid red;<br>  <span class="hljs-comment">/* 方法二：父级元素添加padding */</span><br>    <span class="hljs-attribute">padding</span>:<span class="hljs-number">1px</span>;<br>  <span class="hljs-comment">/* 方法三：父级元素添加overflow:hidden; */</span><br>    <span class="hljs-attribute">overflow</span>:hidden;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux常用命令——增删改查</title>
    <link href="/2019/06/20/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <url>/2019/06/20/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux常用命令"><a href="#Linux常用命令" class="headerlink" title="Linux常用命令"></a>Linux常用命令</h1><h1 id="start"><a href="#start" class="headerlink" title="start"></a>start</h1><p>脚本文件：</p><p><a href="https://zh.wikipedia.org/wiki/Shebang">什么是shebang？</a></p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-meta">#!/usr/bin/env sh//shebang，用于指定脚本解释器。表示使用env程序搜索路径找到脚本文件，同时使用shall解释器执行这个脚本文件。env即environment</span><br>mkdir <span class="hljs-variable">$1</span>//创建文件夹，文件夹名为代传参数.<span class="hljs-variable">$1</span>表示待传参数<br><span class="hljs-built_in">cd</span> <span class="hljs-variable">$1</span>//进入到用户设置的文件夹中<br>touch index.html style.css main.js//创建三个文件<br><br><span class="hljs-built_in">echo</span> -e <span class="hljs-string">&quot;&lt;!DOCTYPE html&gt;\n&lt;h1&gt;标题&lt;/h1&gt;&quot;</span> &gt;&gt; index.html//设置index.html的内容<br></code></pre></div></td></tr></table></figure><p>命令行操作：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">touch 脚本文件//创建脚本文件（可以不设置扩展名）<br>start 脚本文件//使用默认软件打开（未设置扩展名时，此命令将执行失败）<br>code 脚本文件//使用vscode打开脚本文件<br>chmod +x 脚本文件//为脚本文件添加可执行权限（Windows下此句无用途）<br>./脚本文件  <span class="hljs-built_in">test</span>//执行脚本文件<br><br>/* 或者使用当前的shall解释器执行脚本文件 */<br>sh 脚本文件 <span class="hljs-built_in">test</span><br><br>/* 如果脚本文件中添加了shebang申明，同时将脚本文件路径加入到PATH环境变量中，也可以将脚本文件直接作为一个命令执行 */<br>脚本文件 <span class="hljs-built_in">test</span><br></code></pre></div></td></tr></table></figure><p><strong>命令的本质是可执行脚本文件（可执行程序）</strong>。</p><p>使用<code>which</code>可以查看命令对应的<strong>可执行程序</strong>的位置</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">which</span> 脚本文件<br></code></pre></div></td></tr></table></figure><h1 id="命令行增删该查"><a href="#命令行增删该查" class="headerlink" title="命令行增删该查"></a>命令行增删该查</h1><h2 id="命令行缩写"><a href="#命令行缩写" class="headerlink" title="命令行缩写"></a>命令行缩写</h2><table><thead><tr><th>命令</th><th>含义</th><th>命令</th><th>含义</th></tr></thead><tbody><tr><td>mk</td><td>make</td><td>ls</td><td>list</td></tr><tr><td>mv</td><td>move</td><td>ln</td><td>link</td></tr><tr><td>rm</td><td>remove</td><td>find</td><td>find</td></tr><tr><td>cp</td><td>copy</td><td>cd</td><td>change directory</td></tr><tr><td>pwd</td><td>print work directory</td><td>cat</td><td>concatenate</td></tr></tbody></table><h2 id="查：查看文件"><a href="#查：查看文件" class="headerlink" title="查：查看文件"></a>查：查看文件</h2><p>pwd 查看文件目录绝对路径</p><p>（绝对路径是所有以/开头的路径。特例~也是绝对路径，它是<code>/c/User/</code>的缩写）</p><p>cat 查看文件的全部内容</p><p>head 查看文件开始的一部分内容  选项-n设置查看行数</p><p>tail 查看文件末尾的一部分内容 选项-n设置查看的行数</p><p>less 按页查看文件内容</p><p>ls 查看当前路径下的文件</p><p>​    -l 选项为长格式查看，包含文件日期等</p><h2 id="增：创建文件"><a href="#增：创建文件" class="headerlink" title="增：创建文件"></a>增：创建文件</h2><p>touch 创建空文件</p><p>echo [文件内容] &gt; [文件名] 创建带内容的文件</p><p>echo [文件内容] &gt;&gt; [文件名] 为已存在的文件追加内容</p><p>​    -e 选项激活转移字符</p><p>mkdir 创建目录</p><p>​    -p 选项创嵌套目录</p><p>cp 复制文件</p><p>​    -r 选项复制文件夹</p><p>例：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">touch 1.txt//创建文件1.txt<br><span class="hljs-built_in">echo</span> hi &gt; 1.txt//创建文件1.txt。内容是“hi”<br><span class="hljs-built_in">echo</span> hihi &gt;&gt; 1.txt//为1.txt增加内容“hihi”<br><span class="hljs-built_in">echo</span> -e <span class="hljs-string">&quot;1\n2&quot;</span> &gt; 1.txt//创建1.txt。内容是“1（换行）2”.此命令的1.txt会覆盖之前的1.txt<br>cp 1.txt 2.txt//将1.txt的内容复制到2.txt（如果2.txt不存在就创建一个和1.txt内容完全相同的2.txt）<br>cp -r a b//将a文件夹的内容复制到b文件夹（若b文件夹不存在则创建b文件夹）<br>mkdir a//创建a文件夹<br>mkdir -p a/b/c//创建a/b/c文件路径<br>touch 3.txt 4.txt//创建3.txt文件和4.txt文件<br>mkdir c d//创建c、d两个文件夹<br></code></pre></div></td></tr></table></figure><h2 id="删：删除文件"><a href="#删：删除文件" class="headerlink" title="删：删除文件"></a>删：删除文件</h2><p>rm 删除文件</p><p>​    -r 选项删除文件夹</p><p>​    -rf 强制删除文件(夹)</p><h2 id="改：对文件进行相应修改"><a href="#改：对文件进行相应修改" class="headerlink" title="改：对文件进行相应修改"></a>改：对文件进行相应修改</h2><h3 id="追加文件内容"><a href="#追加文件内容" class="headerlink" title="追加文件内容"></a>追加文件内容</h3><p>使用echo追加文件内容：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> hi &gt; 1.txt//创建文件1.txt。内容是“hi”<br><span class="hljs-built_in">echo</span> hihi &gt;&gt; 1.txt//为1.txt增加内容“hihi”<br></code></pre></div></td></tr></table></figure><h3 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h3><p>用<code>start</code> 命令使用默认软件打开</p><h3 id="清空文件内容"><a href="#清空文件内容" class="headerlink" title="清空文件内容"></a>清空文件内容</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;&#x27;</span> &gt; 1.txt //将1.txt内容清空（当1.txt本身不存在时，创建空文件1.txt）<br></code></pre></div></td></tr></table></figure><h3 id="移动文件目录"><a href="#移动文件目录" class="headerlink" title="移动文件目录"></a>移动文件目录</h3><p>mv  [文件]  [文件夹/文件路径]</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">mv 1.txt get-demo-1 //将1.txt移动到get-demo-1文件夹<br>mv mv get-demo-1/1.txt . //将get-demo-1中的1.txt移到当前目录<br></code></pre></div></td></tr></table></figure><h3 id="重命名文件"><a href="#重命名文件" class="headerlink" title="重命名文件"></a>重命名文件</h3><figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">mv</span> <span class="hljs-number">1</span>.txt <span class="hljs-number">2</span>.txt //将<span class="hljs-number">1</span>.txt文件名改为<span class="hljs-number">2</span>.txt<br></code></pre></div></td></tr></table></figure><h3 id="更行文件的最后更新时间"><a href="#更行文件的最后更新时间" class="headerlink" title="更行文件的最后更新时间"></a>更行文件的最后更新时间</h3><figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">touch</span> <span class="hljs-number">1</span>.txt//当<span class="hljs-number">1</span>.txt存在时，此命令更新<span class="hljs-number">1</span>.txt最新更新时间<br></code></pre></div></td></tr></table></figure><h2 id="脚本文件"><a href="#脚本文件" class="headerlink" title="脚本文件"></a>脚本文件</h2><ul><li>查看前一条命令执行情况</li></ul><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">echo $?<br><span class="hljs-regexp">/* 如果上一题命令执行成功则返回0；如果失败则返回非0 */</span><br></code></pre></div></td></tr></table></figure><ul><li><code>&amp;&amp;</code>操作</li></ul><p>只有当<code>&amp;&amp;</code>前一条命令执行成功，<code>&amp;&amp;</code>后一条命令才能执行。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">touch test.txt<br>rm test.txt &amp;&amp; <span class="hljs-built_in">echo</span> $?<br>/* 执行结果：0。 */<br></code></pre></div></td></tr></table></figure><ul><li><code>;</code>操作</li></ul><p>命令之间相互分开，各自执行各自的。不论其他命令是否执行成功，每条命令都执行。</p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>阶乘计算升级版</title>
    <link href="/2019/06/20/%E9%98%B6%E4%B9%98%E8%AE%A1%E7%AE%97%E5%8D%87%E7%BA%A7%E7%89%88/"/>
    <url>/2019/06/20/%E9%98%B6%E4%B9%98%E8%AE%A1%E7%AE%97%E5%8D%87%E7%BA%A7%E7%89%88/</url>
    
    <content type="html"><![CDATA[<p>本题目出自于拼题A，基础编程题6-10. 阶乘计算升级版 (20 分)</p><p>该题要求实现一个打印非负整数阶乘的函数。<br>函数接口定义：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Print_Factorial</span> <span class="hljs-params">( <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N )</span></span>;<br></code></pre></div></td></tr></table></figure><p>其中N是用户传入的参数，其值不超过1000。如果N是非负整数，则该函数必须在一行中打印出N!的值，否则打印“Invalid input”。<br>裁判测试程序样例：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Print_Factorial</span> <span class="hljs-params">( <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N )</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> N;<br><br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;N);<br>    Print_Factorial(N);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/* 你的代码将被嵌在这里 */</span><br></code></pre></div></td></tr></table></figure><p>输入样例：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">15</span><br></code></pre></div></td></tr></table></figure><p>输出样例：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1307674368000</span><br></code></pre></div></td></tr></table></figure><p><img src="/2019/06/20/%E9%98%B6%E4%B9%98%E8%AE%A1%E7%AE%97%E5%8D%87%E7%BA%A7%E7%89%88/%E9%98%B6%E4%B9%98%E8%AE%A1%E7%AE%97%E5%8D%87%E7%BA%A7%E7%89%88%E9%80%9A%E8%BF%87%E7%8E%87.png" alt="题目通过率"></p><p>这道题目的通过率仅为0.13，属于较难的题目。其难点主要在于：</p><ol><li>需要要计算大数乘法。由于int类型的范围包含4个字节，排除最高位符号位，其十进制最大可表示的数字是2,147,483,647‬（即2的31次方-1），超过该数就会出现栈溢出问题。用计算器计算一下可以发现，12！= 479,001,600 &lt;‬ 2,147,483,647,它用最简单的递归或者循环来做，没有问题。但是13！= 6,227,020,800 &gt; 2,147,483,647‬,出现栈溢出。</li><li>必须要使用数组来逐位计算数字乘法，同时考虑进位问题。</li></ol><p>解题思路：<br>① 定义一个数组result[ ]用来装阶乘结果。考虑N最大可以取1000，而1000^1000=10^3000 &gt;&gt; 1000!，因此将数组的长度设为3000位绰绰有余。<br>数组result[ ]的角标由小到大可以依次表示结果的低位到高位，最终输出结果，由大角标到小角标输出即可。<br>② 分别定义两个指针i和h，i表示当前运存所处的位置，j表示当前运算结果最高位的位置。<br>③ 每次做乘法，都是用当前阶乘元素n与当前位置i的值做乘法，同时，加上前一位保存的进位数carry。运算结果保存在outcome中。每次结束，指针i向后移动一位,继续计算乘积和加法，直到i与h重合，该轮乘法计算结束。<br>③ 如果运算至最高位（i与h重合）时，carry&gt;0，则需要向更高位进位，因此h向后移动。具体移动多少位，由carry的值决定(carry的值可能大于10)。</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Print_Factorial</span> <span class="hljs-params">( <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N )</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(N&lt;<span class="hljs-number">0</span>||N&gt;<span class="hljs-number">1000</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Invalid input&quot;</span>);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(N==<span class="hljs-number">0</span>||N==<span class="hljs-number">1</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-comment">//定义结果数组用于保存阶乘结果</span><br>        <span class="hljs-keyword">int</span> result[<span class="hljs-number">3000</span>]=&#123;<span class="hljs-number">0</span>&#125;;<br>        result[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> i,n,h=<span class="hljs-number">0</span>,carry=<span class="hljs-number">0</span>,outcome=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(n=<span class="hljs-number">2</span>; n&lt;=N; ++n)&#123;<br>            <span class="hljs-comment">// 当前n值与当前运算结果逐位做乘法,注意还需要加上之前得到的进位数carry</span><br>            <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;=h; ++i)&#123;<br>                outcome = result[i] * n + carry;<br>                <span class="hljs-comment">// 保存低位数字</span><br>                result[i] = outcome % <span class="hljs-number">10</span>;<br>                carry = outcome / <span class="hljs-number">10</span>;<br>            &#125;<br>            <span class="hljs-comment">// 最高位出现进位(carry&gt;0)时，需要将h向后移动一位</span><br>            <span class="hljs-keyword">for</span>(;carry;)&#123;<br>                ++h;<br>                result[h] = carry %<span class="hljs-number">10</span> ;<br>                carry /= <span class="hljs-number">10</span>;<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 由高到底逐位输出最终结果</span><br>        <span class="hljs-keyword">for</span>(i=h; i&gt;=<span class="hljs-number">0</span>; --i)&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,result[i]);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>运行结果如下：<br><img src="/2019/06/20/%E9%98%B6%E4%B9%98%E8%AE%A1%E7%AE%97%E5%8D%87%E7%BA%A7%E7%89%88/%E6%A0%B7%E4%BE%8B1.png" alt="enter description here"><br>计算1000的阶乘没有问题：<br><img src="/2019/06/20/%E9%98%B6%E4%B9%98%E8%AE%A1%E7%AE%97%E5%8D%87%E7%BA%A7%E7%89%88/%E6%A0%B7%E4%BE%8B2.png" alt="enter description here"><br>提交结果完全正确：<br><img src="/2019/06/20/%E9%98%B6%E4%B9%98%E8%AE%A1%E7%AE%97%E5%8D%87%E7%BA%A7%E7%89%88/%E6%88%90%E7%BB%A9.png" alt="enter description here"></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>乘法运算</tag>
      
      <tag>C/C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git常用命令</title>
    <link href="/2019/06/01/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <url>/2019/06/01/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="git常用命令"><a href="#git常用命令" class="headerlink" title="git常用命令"></a>git常用命令</h1><h2 id="git本地仓库"><a href="#git本地仓库" class="headerlink" title="git本地仓库"></a>git本地仓库</h2><p>初始化文件目录，在当前文件路径中添加.git文件</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">git init<br></code></pre></div></td></tr></table></figure><p>声明哪些变动需要commit    （the modification to be committed）</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">git add<br></code></pre></div></td></tr></table></figure><p><strong>.gitignore文件</strong>    文件内容表明哪些变动不需要commit    (the modification not to be committed)</p><p>示例</p><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk"><span class="hljs-regexp">/.cache/</span><br><span class="hljs-regexp">/node_modules/</span><br></code></pre></div></td></tr></table></figure><h3 id="将文件变动提交到本地仓库"><a href="#将文件变动提交到本地仓库" class="headerlink" title="将文件变动提交到本地仓库"></a>将文件变动提交到本地仓库</h3><p>将add后的变动提交到本地仓库（不常用），将目前代码复制一份到.git目录</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">git commit -m&quot;[版本描述]&quot;<br></code></pre></div></td></tr></table></figure><p>先打开代码，然后手动添加变动情况描述，最后将add后的代码提交到本地仓库——.git目录（常用）</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">git commit -v<br></code></pre></div></td></tr></table></figure><p>查看提交的所有分支的历史版本</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">git log<br></code></pre></div></td></tr></table></figure><p>查看所有分支的所有操作，包括所有commit和reset</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">git reflog<br></code></pre></div></td></tr></table></figure><h3 id="回滚版本"><a href="#回滚版本" class="headerlink" title="回滚版本"></a>回滚版本</h3><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">git reset --hard [版本号]切换代码版本<br></code></pre></div></td></tr></table></figure><p>一定要确保已经把所有add过的代码都commit了。因为这个操作会使所有add过而没有commit的文件消失。</p><p>版本号只要保证具有唯一性即可，对版本号的长度没有要求。</p><h3 id="分支操作"><a href="#分支操作" class="headerlink" title="分支操作"></a>分支操作</h3><p>创建分支x（新的时间线）</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">git branch x<br></code></pre></div></td></tr></table></figure><p>基于本地仓库里最新一次 commit（提交），创建一个新的分支 x</p><p>将当前分支切换到分支x</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">git checkout x<br></code></pre></div></td></tr></table></figure><p>切换分支的前提是，当前分支没有未commit的文件。</p><p><strong>会让当前目录的内容变成本地仓库里 x 分支的最新内容（可能会删除当前目录里的一些文件）</strong></p><p>查看当前分支情况，前面带*号的为当前所在分支</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">git branch<br></code></pre></div></td></tr></table></figure><h2 id="分支合并"><a href="#分支合并" class="headerlink" title="分支合并"></a>分支合并</h2><p>将x分支合并到当前分支</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">git merge x<br></code></pre></div></td></tr></table></figure><h3 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h3><ul><li><p>出现<strong>CONFLICT</strong>时，需要手动解决代码冲突，然后再add+commit</p></li><li><ol><li><p>使用<code>git status -sb</code>命令查看哪些文件出现冲突</p></li><li><p>次打开每个冲突文件</p></li><li><p>搜索出现====的部分</p></li><li><p>在上下个代码中手动调整需要修改的部分</p></li><li><p>删除不用的代码、&gt;&gt;&gt;&gt;、&lt;&lt;&lt;&lt;及====</p></li><li><p><code>git add</code>冲突文件</p></li><li><p>使用<code>git status -sb</code>命令查看出现冲突的文件情况，直到所有冲突全部解决完</p></li><li><p>运行<code>git commit</code></p></li><li><p>分支合并之后删除无用分支：<code>git branch -d x</code></p></li></ol></li></ul><p><strong>当误删了分支时怎么办？</strong></p><p>1.使用<code>git log -g</code> 找回之前commit分支的版本号<br>2.使用<code>git branch [自定义分支名] [分支版本号]</code>命令重新命名这个分支<br>3.检查文件是否存在</p><h2 id="push到远程仓库"><a href="#push到远程仓库" class="headerlink" title="push到远程仓库"></a>push到远程仓库</h2><h3 id="①-生成ssh-key-只做第一次，一劳永逸"><a href="#①-生成ssh-key-只做第一次，一劳永逸" class="headerlink" title="① 生成ssh key(只做第一次，一劳永逸)"></a>① 生成ssh key(只做第一次，一劳永逸)</h3><p>密钥分为公钥（id_rsa.pub）和私钥(id_rsa)</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 生成密钥</span><br>ssh-keygen -t rsa -b 4096 -c <br><span class="hljs-meta">#</span><span class="bash"> 查看公钥内容</span><br>cat ~/.ssh/id_rsa.pub<br><span class="hljs-meta">#</span><span class="bash"> 测试配置是否成功</span><br>ssh -T git@github.com<br></code></pre></div></td></tr></table></figure><p>使用ssh地址的好处是不用每次都输入密码。</p><h3 id="②-上传代码（经常做）"><a href="#②-上传代码（经常做）" class="headerlink" title="② 上传代码（经常做）"></a>② 上传代码（经常做）</h3><ol><li><p>新建GitHub repository，复制ssh地址</p></li><li><p>本地添加远程参考地址</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">git remote add origin git@xxxx<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 查看本地添加的远程仓库地址</span><br>git remote -v<br><span class="hljs-meta">#</span><span class="bash"> 删除远程仓库地址</span><br>git remote remove [name]<br></code></pre></div></td></tr></table></figure></li><li><p>(第一次)push到远程仓库</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">git push -u origin master<br></code></pre></div></td></tr></table></figure></li><li><p>(此步可能需要)当远程代码有修改时，在push之前还要进行pull操作</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">git pull origin master<br></code></pre></div></td></tr></table></figure></li><li><p>(非第一次)push</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">git push<br></code></pre></div></td></tr></table></figure></li></ol><h3 id="③-下载代码"><a href="#③-下载代码" class="headerlink" title="③ 下载代码"></a>③ 下载代码</h3><figure class="highlight crmsh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs crmsh">git <span class="hljs-keyword">clone</span> <span class="hljs-title">git</span>@xxxx<br></code></pre></div></td></tr></table></figure><h2 id="git-高级操作"><a href="#git-高级操作" class="headerlink" title="git 高级操作"></a>git 高级操作</h2><h3 id="自定义命令简写"><a href="#自定义命令简写" class="headerlink" title="自定义命令简写"></a>自定义命令简写</h3><p>举例：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">touch ~/.bashrc<br>echo &#x27;alias ga = &quot;git add&quot;&#x27; &gt;&gt; ~/.bashrc<br>source ~/.bashrc<br></code></pre></div></td></tr></table></figure><p>执行这三行代码之后就可以用 <code>ga</code> 代替 <code>git add</code>了</p><h3 id="其他高级操作"><a href="#其他高级操作" class="headerlink" title="其他高级操作"></a>其他高级操作</h3><p>将未提交的修改保存起来</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">git stash<br></code></pre></div></td></tr></table></figure><p>将保存而未提交的修改拉出来</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">git stash pop<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
