<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>浅析MVC</title>
    <link href="/2021/06/28/%E6%B5%85%E6%9E%90MVC/"/>
    <url>/2021/06/28/%E6%B5%85%E6%9E%90MVC/</url>
    
    <content type="html"><![CDATA[<h1 id="浅析MVC"><a href="#浅析MVC" class="headerlink" title="浅析MVC"></a>浅析MVC</h1><h2 id="MVC的三个对象"><a href="#MVC的三个对象" class="headerlink" title="MVC的三个对象"></a>MVC的三个对象</h2><p><strong>MVC</strong> **(Model-View-Controller)**是一种软件设计模式，它把软件设计分成三大模块：模型（Model）、视图（View）、控制器（Controller）。这样重构的代码：</p><ol><li>简化了后续对程序的修改和扩展简化，避免出现<em>意大利面条式</em>的代码</li><li>并使某一部分代码能够重复利用</li><li>同时，这一设计模式通过对复杂度的简化，使程序结构更加直观易于理解和维护。</li></ol><ul><li><strong>模型（Model）</strong> - 负责存放和处理（增删改查）数据。一般与Conterller存在耦合，M从<code>服务器</code>拿到数据后一般会通过<strong>eventBus</strong>传给Controller</li></ul><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> $ <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;jquery&#x27;</span>;<br><br><span class="hljs-keyword">const</span> eventBus = $(<span class="hljs-built_in">window</span>);<br><br><span class="hljs-keyword">const</span> m = &#123;<br>    <span class="hljs-comment">// 服务器获得的数据</span><br>    <span class="hljs-attr">data</span>:&#123;&#125;,<br>    <span class="hljs-comment">// 对数据进行增删改查</span><br>    <span class="hljs-function"><span class="hljs-title">create</span>(<span class="hljs-params"></span>)</span>&#123;&#125;,<br>    <span class="hljs-function"><span class="hljs-title">delete</span>(<span class="hljs-params"></span>)</span>&#123;&#125;,<br>    <span class="hljs-function"><span class="hljs-title">update</span>(<span class="hljs-params">data</span>)</span>&#123;<br>        <span class="hljs-comment">/* 调用m.update()时，通过eventBus.trigger()触发事件，而Conterller通过</span><br><span class="hljs-comment">        eventBus.on()来监听这个事件，以实现对象间通信 */</span><br>        <span class="hljs-built_in">Object</span>.assign(m.data, data);<span class="hljs-comment">//将data全部拷贝/覆盖给m.data</span><br>        eventBus.trigger(<span class="hljs-string">&#x27;m已更新&#x27;</span>);<span class="hljs-comment">//触发‘m已更新’这个事件</span><br>    &#125;,<br>    <span class="hljs-function"><span class="hljs-title">get</span>(<span class="hljs-params"></span>)</span>&#123;&#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><ul><li><strong>视图（View）</strong> - 负责所有UI界面</li></ul><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> v = &#123;<br>    <span class="hljs-attr">el</span>: <span class="hljs-literal">null</span>,<span class="hljs-comment">//待渲染元素</span><br>    <span class="hljs-attr">html</span>: <span class="hljs-string">`&lt;!--  要显示浏览器页面的内容  --&gt;`</span>,<br>    <span class="hljs-function"><span class="hljs-title">init</span>(<span class="hljs-params">container</span>)</span>&#123;<br>        <span class="hljs-comment">// 初始化带渲染元素</span><br>        v.el = $(container);<br>    &#125;,<br>    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params">data</span>)</span>&#123;<br>        <span class="hljs-comment">// 渲染元素</span><br>        <span class="hljs-keyword">if</span>(v.el.children) v.el.empty();   <span class="hljs-comment">// 如果v.el原来有内容，则先清空</span><br>        <span class="hljs-comment">//...然后重新渲染v.el</span><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><ul><li><strong>控制器（Controller）</strong>- 负责监听和处理View事件，同时监听Model数据变化（通过<strong>eventBus</strong>）</li></ul><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> c = &#123;<br>    <span class="hljs-function"><span class="hljs-title">init</span>(<span class="hljs-params">el</span>)</span>&#123;<br>        v.init(el);<br>        <span class="hljs-comment">// 第一次渲染</span><br>        v.render(data);<span class="hljs-comment">/* view = render(data)方式让render只在</span><br><span class="hljs-comment">        该更新的地方更新 */</span> <br>        c.autoBindEvents();<br>        eventBus.on(<span class="hljs-string">&#x27;m已更新&#x27;</span>,<span class="hljs-function">()=&gt;</span>&#123;<br>           <span class="hljs-comment">// eventBus监听‘m已更新’事件，每当该事件触发，就重新渲染</span><br>           v.render(data); <br>        &#125;);<br>    &#125;,<br>    <span class="hljs-attr">events</span>:&#123; <span class="hljs-comment">/* 一般使用哈希表存储 */</span> &#125;,<br>    <span class="hljs-function"><span class="hljs-title">method</span>(<span class="hljs-params"></span>)</span>&#123;&#125;,<br>    <span class="hljs-function"><span class="hljs-title">autoBindEvents</span>(<span class="hljs-params"></span>)</span>&#123;&#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>由于，v和c耦合度较高，一般将二者合为一个对象<strong>View</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> $ <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;jquery&#x27;</span>;<br><br><span class="hljs-keyword">const</span> eventBus = $(<span class="hljs-built_in">window</span>);<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">View</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">eventBus</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">options</span>)</span> &#123;<br>        <span class="hljs-built_in">super</span>();<span class="hljs-comment">/* 调用 super()会调用父类构造函数，并将返回的实例</span><br><span class="hljs-comment">        赋值给 this。不能在调用 super()之前引用 this。 */</span><br>        <span class="hljs-built_in">Object</span>.assign(<span class="hljs-built_in">this</span>,options);<br><br>        <span class="hljs-built_in">this</span>.el = $(<span class="hljs-built_in">this</span>.el);<br>        <span class="hljs-built_in">this</span>.render(<span class="hljs-built_in">this</span>.data);<br>        <span class="hljs-built_in">this</span>.autoBindEvents();<br>        <span class="hljs-built_in">this</span>.on(<span class="hljs-string">&#x27;m已更新&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-comment">// 继承eventBus的on方法</span><br>            <span class="hljs-built_in">this</span>.render(<span class="hljs-built_in">this</span>.data);<br>        &#125;);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-title">autoBindEvents</span>(<span class="hljs-params"></span>)</span> &#123;&#125;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> View;<br></code></pre></div></td></tr></table></figure><h2 id="EventBus-实现对象间通信"><a href="#EventBus-实现对象间通信" class="headerlink" title="EventBus 实现对象间通信"></a>EventBus 实现对象间通信</h2><p>EventBus就是一个以事件为驱动的消息服务总线，用来实现组件/对象之间的通信。</p><p>这样做的原理是：EventBus有三个关键的 API：on（监听事件），trigger（触发事件）或$emit（vue中）,off（取消监听)</p><p>以上c和m之间的通信就是使用EventBus的一个例子。</p><p>实际工作中一般不用<code>const eventBus = $(window);</code>，因为这样写不利于调用和后期代码维护。一般单独封装一个EventBus类进行解耦。</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> $ <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;jquery&quot;</span>;<br><br><span class="hljs-comment">//解耦EventBus</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EventBus</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-built_in">this</span>._eventBus = $(<span class="hljs-built_in">window</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-title">on</span>(<span class="hljs-params">eventName, fn</span>)</span> &#123;<br>        <span class="hljs-keyword">return</span>  <span class="hljs-built_in">this</span>._eventBus.on(eventName, fn);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-title">trigger</span>(<span class="hljs-params">eventName, fn</span>)</span> &#123;<br>       <span class="hljs-keyword">return</span>  <span class="hljs-built_in">this</span>._eventBus.trigger(eventName, fn);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-title">off</span>(<span class="hljs-params">eventName, fn</span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>._eventBus.off(eventName, fn);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> EventBus;<br></code></pre></div></td></tr></table></figure><h2 id="表驱动编程（Table-Driven-Approach）"><a href="#表驱动编程（Table-Driven-Approach）" class="headerlink" title="表驱动编程（Table-Driven Approach）"></a>表驱动编程（Table-Driven Approach）</h2><p>首先看一段冗余代码：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> $ <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;jquery&quot;</span>;<br><br><span class="hljs-keyword">const</span> testEl = $(<span class="hljs-built_in">window</span>);<br><br><span class="hljs-keyword">const</span> v = &#123;<br>    <span class="hljs-attr">el</span>: testEl,<br>    <span class="hljs-function"><span class="hljs-title">bindEvents</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-comment">// 重复代码过多</span><br>        v.cntnr.on(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-string">&quot;#add1&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>            data += <span class="hljs-number">1</span>;<br>        &#125;);<br><br>        v.cntnr.on(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-string">&quot;#minus1&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>            data -= <span class="hljs-number">1</span>;<br>        &#125;);<br><br>        v.cntnr.on(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-string">&quot;#multiply2&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>            data &lt;&lt;= <span class="hljs-number">1</span>;<br>        &#125;);<br>        v.cntnr.on(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-string">&quot;#divide2&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>            data &gt;&gt;= <span class="hljs-number">1</span>;<br>        &#125;);<br>    &#125;<br>&#125;;<br><br>v.bindEvents();<br></code></pre></div></td></tr></table></figure><p>以上这种绑定事件的方法有如下缺点：</p><ol><li>代码重复性：bindEvents方法明显存在大量重复代码，可以进一步提炼</li><li>可扩展性差：如果改变事件响应函数，就要改变bindEvents()方法，非常不方便</li><li>代码多的时候，不易读，主要程序逻辑被淹没在一些没用的冗余代码中</li></ol><p>表驱动编程：</p><p>为解决上面这些问题，可以将代码发生变化的那一部分（一般是数据部分）放到表中，一般使用哈希表。而其他不变的部分（一般是逻辑部分），单独封装。这样后期维护只需要对表进行响应修改即可。</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> $ <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;jquery&quot;</span>;<br><br><span class="hljs-keyword">const</span> testEl = $(<span class="hljs-built_in">window</span>);<br><br><span class="hljs-keyword">const</span> v = &#123;<br>    <span class="hljs-attr">el</span>:testEl,<br>    <span class="hljs-attr">events</span>:&#123;<br>    <span class="hljs-comment">// 数据部分（变化的部分）</span><br>        <span class="hljs-string">&#x27;click #add1&#x27;</span>: <span class="hljs-string">&#x27;add&#x27;</span>,<br>        <span class="hljs-string">&#x27;click #minus1&#x27;</span>: <span class="hljs-string">&#x27;minus&#x27;</span>,<br>        <span class="hljs-string">&#x27;click #mul2&#x27;</span>: <span class="hljs-string">&#x27;mul&#x27;</span>,<br>        <span class="hljs-string">&#x27;click #divide2&#x27;</span>: <span class="hljs-string">&#x27;divide&#x27;</span>,<br>&#125;,<br>        <br>    <span class="hljs-comment">// 逻辑部分（不变的部分）</span><br>    <span class="hljs-function"><span class="hljs-title">add</span>(<span class="hljs-params"></span>)</span> &#123;<br>        data += <span class="hljs-number">1</span>;<br>    &#125;,<br>    <span class="hljs-function"><span class="hljs-title">minus</span>(<span class="hljs-params"></span>)</span> &#123;<br>        data -= <span class="hljs-number">1</span>;<br>    &#125;,<br>    <span class="hljs-function"><span class="hljs-title">mul</span>(<span class="hljs-params"></span>)</span> &#123;<br>        data &lt;&lt;= <span class="hljs-number">1</span>;<br>    &#125;,<br>    <span class="hljs-function"><span class="hljs-title">divide</span>(<span class="hljs-params"></span>)</span> &#123;<br>        data &gt;&gt;= <span class="hljs-number">1</span>;<br>    &#125;,<br>    <span class="hljs-function"><span class="hljs-title">autoBindEvents</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> v.events)&#123;<br>            <span class="hljs-keyword">const</span> value = v[v.events[key]];<br>            <span class="hljs-keyword">const</span> spaceIndex = key.indexOf(<span class="hljs-string">&#x27; &#x27;</span>);<br>            <span class="hljs-keyword">const</span> part1 = key.slice(<span class="hljs-number">0</span>,spaceIndex);<br>            <span class="hljs-keyword">const</span> part2 = key.slice(spaceIndex+<span class="hljs-number">1</span>);<br>            v.el.on(part1,part2,value);<br>        &#125;<br>&#125;<br>&#125;;<br>    <br>v.autoBindEvents();<br></code></pre></div></td></tr></table></figure><p>表驱动编程的意义在于实现了<strong>逻辑与数据的分离。</strong></p><p>相应的，表驱动编程有以下<strong>优点</strong>：</p><ol><li>提高代码可读性。代码简化到：只需要看“表”，就能知道程序是干什么的。</li><li>减少重复代码</li><li>增加代码可扩展性，比较方便。同时更易于控制复杂度</li></ol><h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><p>模块化是指解决一个复杂问题时自顶向下逐层把系统划分成若干模块的过程，有多种属性，分别反映其内部特性。模块化设计，简单地说就是程序的编写不是一开始就逐条录入计算机语句和指令，而是首先用主程序、子程序、子过程等框架把软件的主要结构和流程描述出来，并定义和调试好各个框架之间的输入、输出链接关系逐步求精的结果是得到一系列以功能块为单位的算法描述。以功能块为单位进行程序设计，实现其求解算法的方法称为模块化。</p><p>模块化的<strong>目的</strong>是为了降低程序复杂度，使程序设计、调试和维护等操作简单化。</p><p>以上封装m、v、c，解耦EventBus，以及表驱动编程的例子都体现了模块化的思想。</p><p>模块化具有以下<strong>优点</strong>：</p><ol><li><p>控制了程序设计的复杂性。</p></li><li><p>提高了代码的重用性。</p></li><li><p>易于维护和功能扩充。</p></li><li><p>有利于团队开发。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>this和call/apply/bind</title>
    <link href="/2021/06/06/this%E5%92%8Ccall%E3%80%81apply%E3%80%81bind/"/>
    <url>/2021/06/06/this%E5%92%8Ccall%E3%80%81apply%E3%80%81bind/</url>
    
    <content type="html"><![CDATA[<h1 id="this和call-apply-bind"><a href="#this和call-apply-bind" class="headerlink" title="this和call/apply/bind"></a>this和call/apply/bind</h1><p>概括的说，call、apply、bind的用途是指定函数调用时所引用上下文对象（context object）的值，即<strong>this的值</strong>。</p><h2 id="深入理解this"><a href="#深入理解this" class="headerlink" title="深入理解this"></a>深入理解this</h2><h3 id="普通函数的this"><a href="#普通函数的this" class="headerlink" title="普通函数的this"></a>普通函数的this</h3><p>在最普通的函数调用中，this引用的是把函数当成方法调用的上下文对象，此时this值就是window。或者说，在网页的全局上下文中调用函数时，this指向window。</p><p>举例：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> hero = <span class="hljs-string">&#x27;Jackie Chan&#x27;</span>;<br><span class="hljs-comment">//window.hero = &#x27;Jackie Chan&#x27;;</span><br><br><span class="hljs-keyword">let</span> person = &#123;<br>    <span class="hljs-attr">hero</span>:<span class="hljs-string">&#x27;Eason Chan&#x27;</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myHero</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.hero;<br>&#125;<br><br>myHero();<span class="hljs-comment">//&#x27;Jackie Chan&#x27;</span><br><br>person.myHero = myHero;<br>person.myHero();<span class="hljs-comment">//&#x27;Eason Chan&#x27;</span><br></code></pre></div></td></tr></table></figure><p>定义在全局上下文中的函数 <code>myHero()</code>引用了 <code>this</code> 对象。这个 this 到底引用哪个对象必须到<br>函数被调用时才能确定。 </p><p>若想只调用<code>myHero()</code>就得到person.hero值，则可以使用call设定this指向：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs JavaScript">myhero();<span class="hljs-comment">//&#x27;Jackie Chan&#x27;</span><br>myHero.call(person,);<span class="hljs-comment">//&#x27;Eason Chan&#x27;</span><br><br>myHero.call(<span class="hljs-literal">null</span>,);<span class="hljs-comment">//&#x27;Jackie Chan&#x27;</span><br>myHero.call(<span class="hljs-literal">undefined</span>,);<span class="hljs-comment">//&#x27;Jackie Chan&#x27;</span><br>myHero.call(<span class="hljs-string">&#x27;&#x27;</span>,);<span class="hljs-comment">//undefined</span><br>...<br>myHero.call([其他falsy值],);  <span class="hljs-comment">//undefined</span><br></code></pre></div></td></tr></table></figure><p>浏览器里有一条规则：如果传的 context 是 null 或 undefined（不包括其他falsy值），那么 window 对象就是默认的 context（严格模式下默认 context 是 undefined），因此会出现第三行代码以后的结果。</p><h3 id="箭头函数的this"><a href="#箭头函数的this" class="headerlink" title="箭头函数的this"></a>箭头函数的this</h3><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> hero = <span class="hljs-string">&#x27;Jackie Chan&#x27;</span>;<br><span class="hljs-comment">//window.hero = &#x27;Jackie Chan&#x27;;</span><br><br><span class="hljs-keyword">let</span> person = &#123;<br>    <span class="hljs-attr">hero</span>:<span class="hljs-string">&#x27;Eason Chan&#x27;</span><br>&#125;;<br><br><span class="hljs-keyword">let</span> myHero = <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">this</span>.hero;<br><br>myHero();<span class="hljs-comment">//&#x27;Jackie Chan&#x27;</span><br><br>person.myHero = myHero;<br>person.myHero();<span class="hljs-comment">//&#x27;Jackie Chan&#x27;</span><br></code></pre></div></td></tr></table></figure><p>在箭头函数中，this 引用的是定义箭头函数的上下文。 由于箭头函数<code>myHero</code>是在全局作用域中定义的，所以this指向的都是window。</p><p>注意：<em><strong>箭头函数的this是固定的，不能被call/apply/bind修改。</strong></em></p><h3 id="闭包中的this"><a href="#闭包中的this" class="headerlink" title="闭包中的this"></a>闭包中的this</h3><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs JavaScript"><span class="hljs-keyword">var</span> color = <span class="hljs-string">&#x27;red&#x27;</span>;<br><span class="hljs-comment">// window.color = &#x27;red&#x27;;</span><br><br><span class="hljs-keyword">let</span> obj = &#123;<br>    <span class="hljs-attr">color</span>: <span class="hljs-string">&#x27;blue&#x27;</span>,<br>    <span class="hljs-function"><span class="hljs-title">sayColor</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">color</span>(<span class="hljs-params"></span>)</span>&#123;<br>         <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.color;   <br>        &#125;<br>&#125;<br>&#125;;<br><br>obj.sayColor()();<span class="hljs-comment">// &#x27;red&#x27;</span><br></code></pre></div></td></tr></table></figure><p>以上代码中，全局变量<code>color</code>和函数<code>color()</code>构成闭包。</p><p>具体解释：见<a href="https://yichang8421.github.io/2021/06/01/%E9%97%AD%E5%8C%85/">《闭包》</a></p><p>要想使<code>obj.sayColor()();</code>返回obj的blue，则应该让<code>obj.color</code>和函数<code>color()</code>构成闭包。可将this保存到闭包可以访问的另一个变量that中：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> color = <span class="hljs-string">&#x27;red&#x27;</span>;<br><span class="hljs-comment">// window.color = &#x27;red&#x27;;</span><br><br><span class="hljs-keyword">let</span> obj = &#123;<br>    <span class="hljs-attr">color</span>: <span class="hljs-string">&#x27;blue&#x27;</span>,<br>    <span class="hljs-function"><span class="hljs-title">sayColor</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">let</span> that = <span class="hljs-built_in">this</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">color</span>(<span class="hljs-params"></span>)</span>&#123;<br>         <span class="hljs-keyword">return</span> that.color;   <br>        &#125;<br>&#125;<br>&#125;;<br><br>obj.sayColor()();<span class="hljs-comment">// &#x27;blue&#x27;</span><br></code></pre></div></td></tr></table></figure><h3 id="回调函数中的this"><a href="#回调函数中的this" class="headerlink" title="回调函数中的this"></a>回调函数中的this</h3><p>回调函数中的this指向window。</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> hero = <span class="hljs-string">&#x27;Jackie Chan&#x27;</span>;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">peoplesHero</span>(<span class="hljs-params">fn</span>)</span>&#123;<br>fn();<br>    <span class="hljs-keyword">return</span> hero;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myHero</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-keyword">var</span> hero = <span class="hljs-string">&#x27;Eason Chan&#x27;</span>;<br>    <span class="hljs-keyword">return</span> hero;<br>&#125;<br><br>peoplesHero(myHero);<span class="hljs-comment">//&#x27;Jackie Chan&#x27;</span><br><br><span class="hljs-comment">//以上为同步回调，代码等价于：</span><br><span class="hljs-keyword">var</span> hero = <span class="hljs-string">&#x27;Jackie Chan&#x27;</span>;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">peoplesHero</span>(<span class="hljs-params"></span>)</span>&#123;<br>(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myHero</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-keyword">var</span> hero = <span class="hljs-string">&#x27;Eason Chan&#x27;</span>;<br>    <span class="hljs-keyword">return</span> hero;<br>&#125;)();<br>    <span class="hljs-keyword">return</span> hero;<br>&#125;<br><br>peoplesHero();<span class="hljs-comment">//&#x27;Jackie Chan&#x27;</span><br></code></pre></div></td></tr></table></figure><h2 id="call"><a href="#call" class="headerlink" title="call"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/call">call</a></h2><p><code>call()</code> 方法使用一个指定的 <code>this</code> 值和单独给出的一个或多个参数来调用一个函数。</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span>.call(thisArg, arg1, arg2, ...)<br></code></pre></div></td></tr></table></figure><p>代码举例在<strong>普通函数的this</strong>小节已经介绍，不再赘述。</p><p>注意：<strong>正确的函数调用方式是使用call/apply/bind指定this.</strong></p><h2 id="apply"><a href="#apply" class="headerlink" title="apply"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/apply">apply</a></h2><p><code>apply()</code> 方法调用一个具有给定<code>this</code>值的函数，以及以一个数组（或<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Indexed_collections#working_with_array-like_objects">类数组对象</a>）的形式提供的参数。</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span>.apply(thisArg, [argsArray])<br></code></pre></div></td></tr></table></figure><p><strong>注意：</strong>call()方法的作用和 apply() 方法非常非常类似，区别就是<code>call()</code>方法接受的是<strong>参数列表</strong>，而<code>apply()</code>方法接受的是<strong>一个参数数组</strong>。</p><h2 id="bind"><a href="#bind" class="headerlink" title="bind"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind">bind</a></h2><p><code>bind()</code> 方法创建一个<strong>新的函数</strong>，在 <code>bind()</code> 被调用时，这个新函数的 <code>this</code> 被指定为 <code>bind()</code> 的第一个参数，而其余参数将作为新函数的参数，供调用时使用。</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span>.bind(thisArg[, arg1[, arg2[, ...]]])<br></code></pre></div></td></tr></table></figure><p>举例：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> hero = <span class="hljs-string">&#x27;Jackie Chan&#x27;</span>;<br><span class="hljs-comment">//window.hero = &#x27;Jackie Chan&#x27;;</span><br><br><span class="hljs-keyword">let</span> person = &#123;<br>    <span class="hljs-attr">hero</span>:<span class="hljs-string">&#x27;Eason Chan&#x27;</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myHero</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.hero;<br>&#125;<br><br><span class="hljs-keyword">var</span> sayHero = myHero.bind(person);<br><span class="hljs-built_in">console</span>.log(sayHero);<span class="hljs-comment">//ƒ myHero()&#123; return this.hero; &#125;</span><br><br>myHero();<span class="hljs-comment">//&#x27;Jackie Chan&#x27;</span><br>sayHero();<span class="hljs-comment">//&#x27;Eason Chan&#x27;</span><br></code></pre></div></td></tr></table></figure><h2 id="call-apply-bind的应用场景"><a href="#call-apply-bind的应用场景" class="headerlink" title="call/apply/bind的应用场景"></a>call/apply/bind的应用场景</h2><p>参考：<a href="https://www.jianshu.com/p/bc541afad6ee">call、apply和bind方法的用法以及区别 - 简书</a></p><ul><li>求数组中的最大和最小值</li></ul><figure class="highlight jsx"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jsx"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">89</span>,<span class="hljs-number">46</span>]<br><span class="hljs-keyword">var</span> max = <span class="hljs-built_in">Math</span>.max.apply(<span class="hljs-literal">null</span>,arr)<span class="hljs-comment">//89</span><br><span class="hljs-keyword">var</span> min = <span class="hljs-built_in">Math</span>.min.apply(<span class="hljs-literal">null</span>,arr)<span class="hljs-comment">//1</span><br></code></pre></div></td></tr></table></figure><ul><li>将类数组转化为数组</li></ul><figure class="highlight jsx"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jsx"><span class="hljs-keyword">var</span> trueArr = <span class="hljs-built_in">Array</span>.prototype.slice.call(arrayLike)<br></code></pre></div></td></tr></table></figure><ul><li>数组追加</li></ul><figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp"><span class="hljs-keyword">var</span> arr1 = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];<br><span class="hljs-keyword">var</span> arr2 = [<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>];<br><span class="hljs-keyword">var</span> total = [].push.apply(arr1, arr2);<span class="hljs-comment">//6</span><br><span class="hljs-comment">// arr1 [1, 2, 3, 4, 5, 6]</span><br><span class="hljs-comment">// arr2 [4,5,6]</span><br></code></pre></div></td></tr></table></figure><ul><li>判断变量类型</li></ul><figure class="highlight jsx"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isArray</span>(<span class="hljs-params">obj</span>)</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.prototype.toString.call(obj) == <span class="hljs-string">&#x27;[object Array]&#x27;</span>;<br>&#125;<br>isArray([]) <span class="hljs-comment">// true</span><br>isArray(<span class="hljs-string">&#x27;dot&#x27;</span>) <span class="hljs-comment">// false</span><br></code></pre></div></td></tr></table></figure><ul><li>利用call和apply做继承</li></ul><figure class="highlight jsx"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params">name,age</span>)</span>&#123;<br>    <span class="hljs-comment">// 这里的this都指向实例</span><br>    <span class="hljs-built_in">this</span>.name = name<br>    <span class="hljs-built_in">this</span>.age = age<br>    <span class="hljs-built_in">this</span>.sayAge = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.age)<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Female</span>(<span class="hljs-params"></span>)</span>&#123;<br>    Person.apply(<span class="hljs-built_in">this</span>,<span class="hljs-built_in">arguments</span>)<span class="hljs-comment">//将父元素所有方法在这里执行一遍就继承了</span><br>&#125;<br><span class="hljs-keyword">var</span> dot = <span class="hljs-keyword">new</span> Female(<span class="hljs-string">&#x27;Dot&#x27;</span>,<span class="hljs-number">2</span>)<br></code></pre></div></td></tr></table></figure><ul><li>使用 log 代理 console.log</li></ul><figure class="highlight jsx"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">log</span>(<span class="hljs-params"></span>)</span>&#123;<br>  <span class="hljs-built_in">console</span>.log.apply(<span class="hljs-built_in">console</span>, <span class="hljs-built_in">arguments</span>);<br>&#125;<br><span class="hljs-comment">// 当然也有更方便的 var log = console.log()</span><br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>闭包</title>
    <link href="/2021/06/01/%E9%97%AD%E5%8C%85/"/>
    <url>/2021/06/01/%E9%97%AD%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><h2 id="闭包是什么？"><a href="#闭包是什么？" class="headerlink" title="闭包是什么？"></a>闭包是什么？</h2><p>一个函数和对其周围状态的引用捆绑在一起，或者说函数被引用包围，这样的组合就是闭包。闭包让我们可以在一个内层函数中访问到其外层函数的作用域。</p><p>「函数」和「函数内部能访问到的变量」（也叫环境）的总和，就是一个闭包。</p><p>举例：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">init</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> name = <span class="hljs-string">&quot;andy8421&quot;</span>; <span class="hljs-comment">// name 是一个被 init 创建的局部变量</span><br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">displayName</span>(<span class="hljs-params"></span>) </span>&#123; <br>        alert(name);                <br>        <span class="hljs-comment">//displayName使用了父函数中声明的变量name，二者共同构成一个闭包。</span><br>  &#125;<br>   <span class="hljs-keyword">return</span> displayName;<br>&#125;<br><br><span class="hljs-keyword">let</span> myDetail = init();<br>myDetail();<br></code></pre></div></td></tr></table></figure><p><strong>注意</strong>，最后两句和<code>init()();</code>这种调用方法并不相同，后者并没有发挥闭包保存内部变量的作用，这不叫使用了闭包。</p><p>举例：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">a</span>(<span class="hljs-params"></span>)</span>&#123;<br><span class="hljs-keyword">let</span> m=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">let</span> n=<span class="hljs-number">2</span>;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">c</span>(<span class="hljs-params"></span>)</span>&#123;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">`m:<span class="hljs-subst">$&#123;m&#125;</span>`</span>);<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">`n:<span class="hljs-subst">$&#123;n&#125;</span>`</span>);<br>m++;<br>n++;<br>&#125;<br><span class="hljs-keyword">return</span> c;<br>&#125;;<br><br>a()();<span class="hljs-comment">//m:1, n:2</span><br>a()();<span class="hljs-comment">//m:1, n:2</span><br>a()();<span class="hljs-comment">//m:1, n:2</span><br><br><span class="hljs-keyword">let</span> f = a();<br>f();<span class="hljs-comment">//m:1, n:2</span><br>f();<span class="hljs-comment">//m:2, n:3</span><br>f();<span class="hljs-comment">//m:3, n:4</span><br></code></pre></div></td></tr></table></figure><h2 id="闭包的作用是什么？"><a href="#闭包的作用是什么？" class="headerlink" title="闭包的作用是什么？"></a>闭包的作用是什么？</h2><ol><li>访问块级作用域、封装私有变量、模拟私有方法</li></ol><p>举例：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)&#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>        <span class="hljs-built_in">console</span>.log(i);<br>    &#125;,<span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-comment">//控制台打印0，1，2，3，4</span><br></code></pre></div></td></tr></table></figure><p>当计时器（私有方法）开始执行时，for循环已经结束，每一次的<code>i</code>都是该次所在的块（块级作用域）中的<code>i</code>，所以打印的是当时的<code>i</code>（私有变量）值。</p><p>以上代码相当于：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)&#123;<br>    <span class="hljs-keyword">let</span> j=i<br>    <span class="hljs-comment">//const j=i</span><br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>        <span class="hljs-built_in">console</span>.log(j);<br>    &#125;,<span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-comment">//控制台打印0，1，2，3，4</span><br></code></pre></div></td></tr></table></figure><p>此处详细解释见：<a href="https://yichang8421.github.io/2021/03/28/JS%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E6%97%B6%E6%9C%BA/"><strong>JS函数的执行时机</strong></a></p><ol start="2"><li>暴露操作函数而隐藏局部变量</li></ol><p>有时，直接使用全局变量很不妥，会出先某些安全问题。我们不能直接访问这些变量，此时就要用到闭包来隐藏局部变量，而仅暴露一个访问器（函数）来间接访问这些变量。</p><p>​    详见：<a href="https://fangyinghang.com/closures-in-js/">JS 中的闭包是什么？</a></p><h2 id="闭包中的this对象"><a href="#闭包中的this对象" class="headerlink" title="闭包中的this对象"></a>闭包中的this对象</h2><p>问题引入：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> color = <span class="hljs-string">&#x27;red&#x27;</span>;<br><span class="hljs-comment">// window.color = &#x27;red&#x27;;</span><br><br><span class="hljs-keyword">let</span> obj = &#123;<br>    <span class="hljs-attr">color</span>: <span class="hljs-string">&#x27;blue&#x27;</span>,<br>    <span class="hljs-function"><span class="hljs-title">sayColor</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">color</span>(<span class="hljs-params"></span>)</span>&#123;<br>         <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.color;   <br>        &#125;<br>&#125;<br>&#125;;<br><br>obj.sayColor()();<span class="hljs-comment">// &#x27;red&#x27;</span><br></code></pre></div></td></tr></table></figure><p>为什么<code>obj.sayColor()();</code>返回的是window.color的值red,而不是obj的blue?</p><p>以上代码中，首先创建了一个全局变量color，之后又创建了包含color属性的对象obj。obj对象还包含一个名为sayColor的函数，而这个函数本身又返回的是一个函数color()。</p><p>由于函数内部的代码在访问变量时，会沿作用域链查找变量。当函数执行完毕后，局部活动对象会被销毁，内存中就只剩下全局作用域。因此<strong>内部函数永远不可能直接访问外部函数的this和arguments变量</strong>。</p><p>当执行<code>obj.sayColor()</code>后，在函数<code>color()</code>所处的执行上下文中，局部活动对象obj已经被销毁。此时<code>color()</code>只能访问全局作用域中的color变量。</p><p>以上代码中，全局变量<code>color</code>和函数<code>color()</code>构成闭包。</p><p>要想使<code>obj.sayColor()();</code>返回obj的blue，则应该让<code>obj.color</code>和函数<code>color()</code>构成闭包。</p><p>解决方法：</p><p>将this保存到闭包可以访问的另一个变量that中：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> color = <span class="hljs-string">&#x27;red&#x27;</span>;<br><span class="hljs-comment">// window.color = &#x27;red&#x27;;</span><br><br><span class="hljs-keyword">let</span> obj = &#123;<br>    <span class="hljs-attr">color</span>: <span class="hljs-string">&#x27;blue&#x27;</span>,<br>    <span class="hljs-function"><span class="hljs-title">sayColor</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">let</span> that = <span class="hljs-built_in">this</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">color</span>(<span class="hljs-params"></span>)</span>&#123;<br>         <span class="hljs-keyword">return</span> that.color;   <br>        &#125;<br>&#125;<br>&#125;;<br><br>obj.sayColor()();<span class="hljs-comment">// &#x27;blue&#x27;</span><br></code></pre></div></td></tr></table></figure><p>尽管当执行<code>obj.Color()</code>后，其执行上下文的作用域已经被销毁，但函数<code>color()</code>仍然引用了外部函数sayColor的变量(即this)，所以他的活动对象obj仍然保存在内存中，进而obj.color仍然可以访问到。</p><p><em>obj是在color()最终执行完毕才被销毁的。</em></p><h2 id="闭包的缺点是什么？"><a href="#闭包的缺点是什么？" class="headerlink" title="闭包的缺点是什么？"></a>闭包的缺点是什么？</h2><ol><li>因为闭包会保留它们包含函数的作用域，所以比其他函数更占用内存。过度使用闭<br>包可能导致内存过度占用 。</li><li>闭包会在父函数外部改变父函数内部变量的值</li></ol>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS函数的执行时机</title>
    <link href="/2021/03/28/JS%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E6%97%B6%E6%9C%BA/"/>
    <url>/2021/03/28/JS%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E6%97%B6%E6%9C%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="JS函数的执行时机"><a href="#JS函数的执行时机" class="headerlink" title="JS函数的执行时机"></a>JS函数的执行时机</h1><h2 id="问题引入（五个5问题）："><a href="#问题引入（五个5问题）：" class="headerlink" title="问题引入（五个5问题）："></a>问题引入（五个5问题）：</h2><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)&#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>        <span class="hljs-built_in">console</span>.log(i)<br>    &#125;,<span class="hljs-number">0</span>)<br>&#125;<br><span class="hljs-comment">//控制台打印五个5</span><br><span class="hljs-comment">//return为浏览器输出的，不关心。下文不再赘述。</span><br></code></pre></div></td></tr></table></figure><p>为什么控制台打印出了五个5，而不是0、1、2、3、4，<strong>why</strong>？</p><h2 id="深入理解JS函数的执行时机"><a href="#深入理解JS函数的执行时机" class="headerlink" title="深入理解JS函数的执行时机"></a>深入理解JS函数的执行时机</h2><p>输出以上结果的前提是：</p><p>① <code>var</code>声明使得<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/var#%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87"><strong>变量提升</strong></a>。使用var命令声明，同时<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/var#description">给未声明的变量赋值, 则执行赋值后, 该变量会被隐式地创建为全局变量（成为全局对象的属性)</a>。</p><p>因此，此代码中，for循环的i被提升为全局变量（<strong>for循环全程只有一个变量i</strong>）。</p><p>以上代码等价于：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> i<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)&#123;<br>   ...<br>&#125;<br></code></pre></div></td></tr></table></figure><p>感觉这个代码比较啰嗦，以下均使用for循环内部的<code>var</code>命令来声明全局的<code>i</code>。</p><p>② JavaScript是一门<strong>单线程语言</strong>。每一个任务只能按顺序依次进行。</p><p>上述代码中的<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout">window.setTimeout</a>设置了一个<strong>定时器</strong>，该定时器在一段时期后（可以理解为之前的任务完成后）才执行一个函数或指定的一段代码。</p><p>因此在执行<code>setTimeout(()=&gt;&#123;console.log(i);&#125;,0);</code>时，for循环已经结束，此时i的值为5.</p><p>所以此时每次执行的<code>console.log(i);</code>结果都为5。</p><p><strong>通俗的理解</strong>，在当前任务还没有完成时，就安排了下一个任务，而下一个任务的进行需要上一个任务得到的结果（这里前后两个任务分别是for循环和计时器）。那么JS会先把当前任务完成，然后再开始完成下一个任务。此时，下一个任务用到的数据应该是当前任务（for循环）完成之后（<strong>have done</strong>）的数据，而不是正在完成（<strong>v.ing</strong>）的数据。</p><h3 id="异步任务"><a href="#异步任务" class="headerlink" title="异步任务"></a><a href="https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Asynchronous">异步任务</a></h3><p>通常来说，程序都是顺序执行，同一时刻只会发生一件事。如果一个函数依赖于另一个函数的结果，它只能等待那个函数结束才能继续执行，从用户的角度来说，整个程序才算运行完毕。</p><p>使用<strong>异步函数</strong>可以设置函数队列的执行顺序。JS中最基本的异步函数有：</p><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout">window.setTimeout</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/WindowOrWorkerGlobalScope/setInterval">window.setInterval</a></li></ul><h2 id="灵活使用-TL-DR"><a href="#灵活使用-TL-DR" class="headerlink" title="灵活使用(TL;DR)"></a>灵活使用(TL;DR)</h2><p>如何打出想要的0-4？</p><p><strong>理解关键点</strong>：只要 ①在局部作用域中<strong>创造</strong>它的<strong>局部变量<code>i</code><strong>（方法一） 或者 ②在</strong>局部作用域</strong>中<strong>使用</strong>全局变量<code>i</code>（方法二和方法三）就能够达到目的。</p><p><strong>方法一</strong>（for循环内部使用let声明）：</p><p>可以将var声明改为<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/let"><code>let</code></a>声明。它能声明一个块级作用域的本地变量。</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)&#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>        <span class="hljs-built_in">console</span>.log(i);<br>    &#125;,<span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-comment">//控制台打印0，1，2，3，4</span><br></code></pre></div></td></tr></table></figure><p>let肯定不能放在for循环外面，上文已经解释。</p><p>此时，尽管计时器开始执行时，for循环已经结束，但每一次的<code>i</code>都是该次所在的块中的<code>i</code>，所以打印的是当时的i值。</p><p>注意，此时<strong>for循环将产生六个局部变量i</strong>，分别是0，1，2，3，4，5。</p><p>同样的道理，也可以在for循环中<strong>单独声明</strong>一个变量j（使用let或const）。此代码比较无聊，但对于理解方法一有帮助：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)&#123;<br>    <span class="hljs-keyword">let</span> j=i<br>    <span class="hljs-comment">//const j=i</span><br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>        <span class="hljs-built_in">console</span>.log(j);<br>    &#125;,<span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-comment">//控制台打印0，1，2，3，4</span><br></code></pre></div></td></tr></table></figure><p><strong>方法二</strong>（立即执行函数）：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)&#123;<br>    !<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">i</span>)</span>&#123;<br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>        <span class="hljs-built_in">console</span>.log(i)<br>    &#125;,<span class="hljs-number">0</span>)<br>    &#125;(i)<br>&#125;<br><span class="hljs-comment">//控制台打印0，1，2，3，4</span><br></code></pre></div></td></tr></table></figure><p>使用立即执行函数可以创造一个局部作用域，进而达到想要的效果：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">!<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>       <span class="hljs-comment">/*</span><br><span class="hljs-comment">       局部作用域。</span><br><span class="hljs-comment">       */</span><br>   &#125;()<br></code></pre></div></td></tr></table></figure><p><strong>方法三</strong>（setTimeout函数传参）：</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout">window.setTimeout</a>的第三个参数用于设定function的参数</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)&#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">i</span>)</span>&#123;<br>        <span class="hljs-built_in">console</span>.log(i)<br>    &#125;,<span class="hljs-number">0</span>,i)<br>&#125;<br><span class="hljs-comment">//控制台打印0，1，2，3，4</span><br></code></pre></div></td></tr></table></figure><p>此时，每一次进入for循环，第三个参数都告诉计时器：不用等for循环完成，你现在就能拿到i值给你的function执行了。所以每一次都能直接打印出当次的i值。</p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
