<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>this和call/apply/bind</title>
    <link href="/2021/06/06/this%E5%92%8Ccall%E3%80%81apply%E3%80%81bind/"/>
    <url>/2021/06/06/this%E5%92%8Ccall%E3%80%81apply%E3%80%81bind/</url>
    
    <content type="html"><![CDATA[<h1 id="this和call-apply-bind"><a href="#this和call-apply-bind" class="headerlink" title="this和call/apply/bind"></a>this和call/apply/bind</h1><p>概括的说，call、apply、bind的用途是指定函数调用时所引用上下文对象（context object）的值，即<strong>this的值</strong>。</p><h2 id="深入理解this"><a href="#深入理解this" class="headerlink" title="深入理解this"></a>深入理解this</h2><h3 id="普通函数的this"><a href="#普通函数的this" class="headerlink" title="普通函数的this"></a>普通函数的this</h3><p>在最普通的函数调用中，this引用的是把函数当成方法调用的上下文对象，此时this值就是window。或者说，在网页的全局上下文中调用函数时，this指向window。</p><p>举例：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> hero = <span class="hljs-string">&#x27;Jackie Chan&#x27;</span>;<br><span class="hljs-comment">//window.hero = &#x27;Jackie Chan&#x27;;</span><br><br><span class="hljs-keyword">let</span> person = &#123;<br>    <span class="hljs-attr">hero</span>:<span class="hljs-string">&#x27;Eason Chan&#x27;</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myHero</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.hero;<br>&#125;<br><br>myHero();<span class="hljs-comment">//&#x27;Jackie Chan&#x27;</span><br><br>person.myHero = myHero;<br>person.myHero();<span class="hljs-comment">//&#x27;Eason Chan&#x27;</span><br></code></pre></div></td></tr></table></figure><p>定义在全局上下文中的函数 <code>myHero()</code>引用了 <code>this</code> 对象。这个 this 到底引用哪个对象必须到<br>函数被调用时才能确定。 </p><p>若想只调用<code>myHero()</code>就得到person.hero值，则可以使用call设定this指向：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs JavaScript">myhero();<span class="hljs-comment">//&#x27;Jackie Chan&#x27;</span><br>myHero.call(person,);<span class="hljs-comment">//&#x27;Eason Chan&#x27;</span><br><br>myHero.call(<span class="hljs-literal">null</span>,);<span class="hljs-comment">//&#x27;Jackie Chan&#x27;</span><br>myHero.call(<span class="hljs-literal">undefined</span>,);<span class="hljs-comment">//&#x27;Jackie Chan&#x27;</span><br>myHero.call(<span class="hljs-string">&#x27;&#x27;</span>,);<span class="hljs-comment">//undefined</span><br>...<br>myHero.call([其他falsy值],);  <span class="hljs-comment">//undefined</span><br></code></pre></div></td></tr></table></figure><p>浏览器里有一条规则：如果传的 context 是 null 或 undefined（不包括其他falsy值），那么 window 对象就是默认的 context（严格模式下默认 context 是 undefined），因此会出现第三行代码以后的结果。</p><h3 id="箭头函数的this"><a href="#箭头函数的this" class="headerlink" title="箭头函数的this"></a>箭头函数的this</h3><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> hero = <span class="hljs-string">&#x27;Jackie Chan&#x27;</span>;<br><span class="hljs-comment">//window.hero = &#x27;Jackie Chan&#x27;;</span><br><br><span class="hljs-keyword">let</span> person = &#123;<br>    <span class="hljs-attr">hero</span>:<span class="hljs-string">&#x27;Eason Chan&#x27;</span><br>&#125;;<br><br><span class="hljs-keyword">let</span> myHero = <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">this</span>.hero;<br><br>myHero();<span class="hljs-comment">//&#x27;Jackie Chan&#x27;</span><br><br>person.myHero = myHero;<br>person.myHero();<span class="hljs-comment">//&#x27;Jackie Chan&#x27;</span><br></code></pre></div></td></tr></table></figure><p>在箭头函数中，this 引用的是定义箭头函数的上下文。 由于箭头函数<code>myHero</code>是在全局作用域中定义的，所以this指向的都是window。</p><p>注意：<em><strong>箭头函数的this是固定的，不能被call/apply/bind修改。</strong></em></p><h3 id="闭包中的this"><a href="#闭包中的this" class="headerlink" title="闭包中的this"></a>闭包中的this</h3><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs JavaScript"><span class="hljs-keyword">var</span> color = <span class="hljs-string">&#x27;red&#x27;</span>;<br><span class="hljs-comment">// window.color = &#x27;red&#x27;;</span><br><br><span class="hljs-keyword">let</span> obj = &#123;<br>    <span class="hljs-attr">color</span>: <span class="hljs-string">&#x27;blue&#x27;</span>,<br>    <span class="hljs-function"><span class="hljs-title">sayColor</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">color</span>(<span class="hljs-params"></span>)</span>&#123;<br>         <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.color;   <br>        &#125;<br>&#125;<br>&#125;;<br><br>obj.sayColor()();<span class="hljs-comment">// &#x27;red&#x27;</span><br></code></pre></div></td></tr></table></figure><p>以上代码中，全局变量<code>color</code>和函数<code>color()</code>构成闭包。</p><p>具体解释：见<a href="https://yichang8421.github.io/2021/06/01/%E9%97%AD%E5%8C%85/">《闭包》</a></p><p>要想使<code>obj.sayColor()();</code>返回obj的blue，则应该让<code>obj.color</code>和函数<code>color()</code>构成闭包。可将this保存到闭包可以访问的另一个变量that中：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> color = <span class="hljs-string">&#x27;red&#x27;</span>;<br><span class="hljs-comment">// window.color = &#x27;red&#x27;;</span><br><br><span class="hljs-keyword">let</span> obj = &#123;<br>    <span class="hljs-attr">color</span>: <span class="hljs-string">&#x27;blue&#x27;</span>,<br>    <span class="hljs-function"><span class="hljs-title">sayColor</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">let</span> that = <span class="hljs-built_in">this</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">color</span>(<span class="hljs-params"></span>)</span>&#123;<br>         <span class="hljs-keyword">return</span> that.color;   <br>        &#125;<br>&#125;<br>&#125;;<br><br>obj.sayColor()();<span class="hljs-comment">// &#x27;blue&#x27;</span><br></code></pre></div></td></tr></table></figure><h3 id="回调函数中的this"><a href="#回调函数中的this" class="headerlink" title="回调函数中的this"></a>回调函数中的this</h3><p>回调函数中的this指向window。</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> hero = <span class="hljs-string">&#x27;Jackie Chan&#x27;</span>;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">peoplesHero</span>(<span class="hljs-params">fn</span>)</span>&#123;<br>fn();<br>    <span class="hljs-keyword">return</span> hero;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myHero</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-keyword">var</span> hero = <span class="hljs-string">&#x27;Eason Chan&#x27;</span>;<br>    <span class="hljs-keyword">return</span> hero;<br>&#125;<br><br>peoplesHero(myHero);<span class="hljs-comment">//&#x27;Jackie Chan&#x27;</span><br><br><span class="hljs-comment">//以上为同步回调，代码等价于：</span><br><span class="hljs-keyword">var</span> hero = <span class="hljs-string">&#x27;Jackie Chan&#x27;</span>;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">peoplesHero</span>(<span class="hljs-params"></span>)</span>&#123;<br>(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myHero</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-keyword">var</span> hero = <span class="hljs-string">&#x27;Eason Chan&#x27;</span>;<br>    <span class="hljs-keyword">return</span> hero;<br>&#125;)();<br>    <span class="hljs-keyword">return</span> hero;<br>&#125;<br><br>peoplesHero();<span class="hljs-comment">//&#x27;Jackie Chan&#x27;</span><br></code></pre></div></td></tr></table></figure><h2 id="call"><a href="#call" class="headerlink" title="call"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/call">call</a></h2><p><code>call()</code> 方法使用一个指定的 <code>this</code> 值和单独给出的一个或多个参数来调用一个函数。</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span>.call(thisArg, arg1, arg2, ...)<br></code></pre></div></td></tr></table></figure><p>代码举例在<strong>普通函数的this</strong>小节已经介绍，不再赘述。</p><p>注意：<strong>正确的函数调用方式是使用call/apply/bind指定this.</strong></p><h2 id="apply"><a href="#apply" class="headerlink" title="apply"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/apply">apply</a></h2><p><code>apply()</code> 方法调用一个具有给定<code>this</code>值的函数，以及以一个数组（或<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Indexed_collections#working_with_array-like_objects">类数组对象</a>）的形式提供的参数。</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span>.apply(thisArg, [argsArray])<br></code></pre></div></td></tr></table></figure><p><strong>注意：</strong>call()方法的作用和 apply() 方法非常非常类似，区别就是<code>call()</code>方法接受的是<strong>参数列表</strong>，而<code>apply()</code>方法接受的是<strong>一个参数数组</strong>。</p><h2 id="bind"><a href="#bind" class="headerlink" title="bind"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind">bind</a></h2><p><code>bind()</code> 方法创建一个<strong>新的函数</strong>，在 <code>bind()</code> 被调用时，这个新函数的 <code>this</code> 被指定为 <code>bind()</code> 的第一个参数，而其余参数将作为新函数的参数，供调用时使用。</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span>.bind(thisArg[, arg1[, arg2[, ...]]])<br></code></pre></div></td></tr></table></figure><p>举例：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> hero = <span class="hljs-string">&#x27;Jackie Chan&#x27;</span>;<br><span class="hljs-comment">//window.hero = &#x27;Jackie Chan&#x27;;</span><br><br><span class="hljs-keyword">let</span> person = &#123;<br>    <span class="hljs-attr">hero</span>:<span class="hljs-string">&#x27;Eason Chan&#x27;</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myHero</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.hero;<br>&#125;<br><br><span class="hljs-keyword">var</span> sayHero = myHero.bind(person);<br><span class="hljs-built_in">console</span>.log(sayHero);<span class="hljs-comment">//ƒ myHero()&#123; return this.hero; &#125;</span><br><br>myHero();<span class="hljs-comment">//&#x27;Jackie Chan&#x27;</span><br>sayHero();<span class="hljs-comment">//&#x27;Eason Chan&#x27;</span><br></code></pre></div></td></tr></table></figure><h2 id="call-apply-bind的应用场景"><a href="#call-apply-bind的应用场景" class="headerlink" title="call/apply/bind的应用场景"></a>call/apply/bind的应用场景</h2><p>参考：<a href="https://www.jianshu.com/p/bc541afad6ee">call、apply和bind方法的用法以及区别 - 简书</a></p><ul><li>求数组中的最大和最小值</li></ul><figure class="highlight jsx"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jsx"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">89</span>,<span class="hljs-number">46</span>]<br><span class="hljs-keyword">var</span> max = <span class="hljs-built_in">Math</span>.max.apply(<span class="hljs-literal">null</span>,arr)<span class="hljs-comment">//89</span><br><span class="hljs-keyword">var</span> min = <span class="hljs-built_in">Math</span>.min.apply(<span class="hljs-literal">null</span>,arr)<span class="hljs-comment">//1</span><br></code></pre></div></td></tr></table></figure><ul><li>将类数组转化为数组</li></ul><figure class="highlight jsx"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jsx"><span class="hljs-keyword">var</span> trueArr = <span class="hljs-built_in">Array</span>.prototype.slice.call(arrayLike)<br></code></pre></div></td></tr></table></figure><ul><li>数组追加</li></ul><figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp"><span class="hljs-keyword">var</span> arr1 = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];<br><span class="hljs-keyword">var</span> arr2 = [<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>];<br><span class="hljs-keyword">var</span> total = [].push.apply(arr1, arr2);<span class="hljs-comment">//6</span><br><span class="hljs-comment">// arr1 [1, 2, 3, 4, 5, 6]</span><br><span class="hljs-comment">// arr2 [4,5,6]</span><br></code></pre></div></td></tr></table></figure><ul><li>判断变量类型</li></ul><figure class="highlight jsx"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isArray</span>(<span class="hljs-params">obj</span>)</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.prototype.toString.call(obj) == <span class="hljs-string">&#x27;[object Array]&#x27;</span>;<br>&#125;<br>isArray([]) <span class="hljs-comment">// true</span><br>isArray(<span class="hljs-string">&#x27;dot&#x27;</span>) <span class="hljs-comment">// false</span><br></code></pre></div></td></tr></table></figure><ul><li>利用call和apply做继承</li></ul><figure class="highlight jsx"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params">name,age</span>)</span>&#123;<br>    <span class="hljs-comment">// 这里的this都指向实例</span><br>    <span class="hljs-built_in">this</span>.name = name<br>    <span class="hljs-built_in">this</span>.age = age<br>    <span class="hljs-built_in">this</span>.sayAge = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.age)<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Female</span>(<span class="hljs-params"></span>)</span>&#123;<br>    Person.apply(<span class="hljs-built_in">this</span>,<span class="hljs-built_in">arguments</span>)<span class="hljs-comment">//将父元素所有方法在这里执行一遍就继承了</span><br>&#125;<br><span class="hljs-keyword">var</span> dot = <span class="hljs-keyword">new</span> Female(<span class="hljs-string">&#x27;Dot&#x27;</span>,<span class="hljs-number">2</span>)<br></code></pre></div></td></tr></table></figure><ul><li>使用 log 代理 console.log</li></ul><figure class="highlight jsx"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">log</span>(<span class="hljs-params"></span>)</span>&#123;<br>  <span class="hljs-built_in">console</span>.log.apply(<span class="hljs-built_in">console</span>, <span class="hljs-built_in">arguments</span>);<br>&#125;<br><span class="hljs-comment">// 当然也有更方便的 var log = console.log()</span><br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>闭包</title>
    <link href="/2021/06/01/%E9%97%AD%E5%8C%85/"/>
    <url>/2021/06/01/%E9%97%AD%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><h2 id="闭包是什么？"><a href="#闭包是什么？" class="headerlink" title="闭包是什么？"></a>闭包是什么？</h2><p>一个函数和对其周围状态的引用捆绑在一起，或者说函数被引用包围，这样的组合就是闭包。闭包让我们可以在一个内层函数中访问到其外层函数的作用域。</p><p>「函数」和「函数内部能访问到的变量」（也叫环境）的总和，就是一个闭包。</p><p>举例：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">init</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> name = <span class="hljs-string">&quot;andy8421&quot;</span>; <span class="hljs-comment">// name 是一个被 init 创建的局部变量</span><br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">displayName</span>(<span class="hljs-params"></span>) </span>&#123; <br>        alert(name);                <br>        <span class="hljs-comment">//displayName使用了父函数中声明的变量name，二者共同构成一个闭包。</span><br>  &#125;<br>   <span class="hljs-keyword">return</span> displayName;<br>&#125;<br><br><span class="hljs-keyword">let</span> myDetail = init();<br>myDetail();<br></code></pre></div></td></tr></table></figure><p><strong>注意</strong>，最后两句和<code>init()();</code>这种调用方法并不相同，后者并没有发挥闭包保存内部变量的作用，这不叫使用了闭包。</p><p>举例：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">a</span>(<span class="hljs-params"></span>)</span>&#123;<br><span class="hljs-keyword">let</span> m=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">let</span> n=<span class="hljs-number">2</span>;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">c</span>(<span class="hljs-params"></span>)</span>&#123;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">`m:<span class="hljs-subst">$&#123;m&#125;</span>`</span>);<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">`n:<span class="hljs-subst">$&#123;n&#125;</span>`</span>);<br>m++;<br>n++;<br>&#125;<br><span class="hljs-keyword">return</span> c;<br>&#125;;<br><br>a()();<span class="hljs-comment">//m:1, n:2</span><br>a()();<span class="hljs-comment">//m:1, n:2</span><br>a()();<span class="hljs-comment">//m:1, n:2</span><br><br><span class="hljs-keyword">let</span> f = a();<br>f();<span class="hljs-comment">//m:1, n:2</span><br>f();<span class="hljs-comment">//m:2, n:3</span><br>f();<span class="hljs-comment">//m:3, n:4</span><br></code></pre></div></td></tr></table></figure><h2 id="闭包的作用是什么？"><a href="#闭包的作用是什么？" class="headerlink" title="闭包的作用是什么？"></a>闭包的作用是什么？</h2><ol><li>访问块级作用域、封装私有变量、模拟私有方法</li></ol><p>举例：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)&#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>        <span class="hljs-built_in">console</span>.log(i);<br>    &#125;,<span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-comment">//控制台打印0，1，2，3，4</span><br></code></pre></div></td></tr></table></figure><p>当计时器（私有方法）开始执行时，for循环已经结束，每一次的<code>i</code>都是该次所在的块（块级作用域）中的<code>i</code>，所以打印的是当时的<code>i</code>（私有变量）值。</p><p>以上代码相当于：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)&#123;<br>    <span class="hljs-keyword">let</span> j=i<br>    <span class="hljs-comment">//const j=i</span><br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>        <span class="hljs-built_in">console</span>.log(j);<br>    &#125;,<span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-comment">//控制台打印0，1，2，3，4</span><br></code></pre></div></td></tr></table></figure><p>此处详细解释见：<a href="https://yichang8421.github.io/2021/03/28/JS%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E6%97%B6%E6%9C%BA/"><strong>JS函数的执行时机</strong></a></p><ol start="2"><li>暴露操作函数而隐藏局部变量</li></ol><p>有时，直接使用全局变量很不妥，会出先某些安全问题。我们不能直接访问这些变量，此时就要用到闭包来隐藏局部变量，而仅暴露一个访问器（函数）来间接访问这些变量。</p><p>​    详见：<a href="https://fangyinghang.com/closures-in-js/">JS 中的闭包是什么？</a></p><h2 id="闭包中的this对象"><a href="#闭包中的this对象" class="headerlink" title="闭包中的this对象"></a>闭包中的this对象</h2><p>问题引入：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> color = <span class="hljs-string">&#x27;red&#x27;</span>;<br><span class="hljs-comment">// window.color = &#x27;red&#x27;;</span><br><br><span class="hljs-keyword">let</span> obj = &#123;<br>    <span class="hljs-attr">color</span>: <span class="hljs-string">&#x27;blue&#x27;</span>,<br>    <span class="hljs-function"><span class="hljs-title">sayColor</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">color</span>(<span class="hljs-params"></span>)</span>&#123;<br>         <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.color;   <br>        &#125;<br>&#125;<br>&#125;;<br><br>obj.sayColor()();<span class="hljs-comment">// &#x27;red&#x27;</span><br></code></pre></div></td></tr></table></figure><p>为什么<code>obj.sayColor()();</code>返回的是window.color的值red,而不是obj的blue?</p><p>以上代码中，首先创建了一个全局变量color，之后又创建了包含color属性的对象obj。obj对象还包含一个名为sayColor的函数，而这个函数本身又返回的是一个函数color()。</p><p>由于函数内部的代码在访问变量时，会沿作用域链查找变量。当函数执行完毕后，局部活动对象会被销毁，内存中就只剩下全局作用域。因此<strong>内部函数永远不可能直接访问外部函数的this和arguments变量</strong>。</p><p>当执行<code>obj.sayColor()</code>后，在函数<code>color()</code>所处的执行上下文中，局部活动对象obj已经被销毁。此时<code>color()</code>只能访问全局作用域中的color变量。</p><p>以上代码中，全局变量<code>color</code>和函数<code>color()</code>构成闭包。</p><p>要想使<code>obj.sayColor()();</code>返回obj的blue，则应该让<code>obj.color</code>和函数<code>color()</code>构成闭包。</p><p>解决方法：</p><p>将this保存到闭包可以访问的另一个变量that中：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> color = <span class="hljs-string">&#x27;red&#x27;</span>;<br><span class="hljs-comment">// window.color = &#x27;red&#x27;;</span><br><br><span class="hljs-keyword">let</span> obj = &#123;<br>    <span class="hljs-attr">color</span>: <span class="hljs-string">&#x27;blue&#x27;</span>,<br>    <span class="hljs-function"><span class="hljs-title">sayColor</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">let</span> that = <span class="hljs-built_in">this</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">color</span>(<span class="hljs-params"></span>)</span>&#123;<br>         <span class="hljs-keyword">return</span> that.color;   <br>        &#125;<br>&#125;<br>&#125;;<br><br>obj.sayColor()();<span class="hljs-comment">// &#x27;blue&#x27;</span><br></code></pre></div></td></tr></table></figure><p>尽管当执行<code>obj.Color()</code>后，其执行上下文的作用域已经被销毁，但函数<code>color()</code>仍然引用了外部函数sayColor的变量(即this)，所以他的活动对象obj仍然保存在内存中，进而obj.color仍然可以访问到。</p><p><em>obj是在color()最终执行完毕才被销毁的。</em></p><h2 id="闭包的缺点是什么？"><a href="#闭包的缺点是什么？" class="headerlink" title="闭包的缺点是什么？"></a>闭包的缺点是什么？</h2><ol><li>因为闭包会保留它们包含函数的作用域，所以比其他函数更占用内存。过度使用闭<br>包可能导致内存过度占用 。</li><li>闭包会在父函数外部改变父函数内部变量的值</li></ol>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS函数的执行时机</title>
    <link href="/2021/03/28/JS%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E6%97%B6%E6%9C%BA/"/>
    <url>/2021/03/28/JS%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E6%97%B6%E6%9C%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="JS函数的执行时机"><a href="#JS函数的执行时机" class="headerlink" title="JS函数的执行时机"></a>JS函数的执行时机</h1><h2 id="问题引入（五个5问题）："><a href="#问题引入（五个5问题）：" class="headerlink" title="问题引入（五个5问题）："></a>问题引入（五个5问题）：</h2><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)&#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>        <span class="hljs-built_in">console</span>.log(i)<br>    &#125;,<span class="hljs-number">0</span>)<br>&#125;<br><span class="hljs-comment">//控制台打印五个5</span><br><span class="hljs-comment">//return为浏览器输出的，不关心。下文不再赘述。</span><br></code></pre></div></td></tr></table></figure><p>为什么控制台打印出了五个5，而不是0、1、2、3、4，<strong>why</strong>？</p><h2 id="深入理解JS函数的执行时机"><a href="#深入理解JS函数的执行时机" class="headerlink" title="深入理解JS函数的执行时机"></a>深入理解JS函数的执行时机</h2><p>输出以上结果的前提是：</p><p>① <code>var</code>声明使得<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/var#%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87"><strong>变量提升</strong></a>。使用var命令声明，同时<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/var#description">给未声明的变量赋值, 则执行赋值后, 该变量会被隐式地创建为全局变量（成为全局对象的属性)</a>。</p><p>因此，此代码中，for循环的i被提升为全局变量（<strong>for循环全程只有一个变量i</strong>）。</p><p>以上代码等价于：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> i<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)&#123;<br>   ...<br>&#125;<br></code></pre></div></td></tr></table></figure><p>感觉这个代码比较啰嗦，以下均使用for循环内部的<code>var</code>命令来声明全局的<code>i</code>。</p><p>② JavaScript是一门<strong>单线程语言</strong>。每一个任务只能按顺序依次进行。</p><p>上述代码中的<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout">window.setTimeout</a>设置了一个<strong>定时器</strong>，该定时器在一段时期后（可以理解为之前的任务完成后）才执行一个函数或指定的一段代码。</p><p>因此在执行<code>setTimeout(()=&gt;&#123;console.log(i);&#125;,0);</code>时，for循环已经结束，此时i的值为5.</p><p>所以此时每次执行的<code>console.log(i);</code>结果都为5。</p><p><strong>通俗的理解</strong>，在当前任务还没有完成时，就安排了下一个任务，而下一个任务的进行需要上一个任务得到的结果（这里前后两个任务分别是for循环和计时器）。那么JS会先把当前任务完成，然后再开始完成下一个任务。此时，下一个任务用到的数据应该是当前任务（for循环）完成之后（<strong>have done</strong>）的数据，而不是正在完成（<strong>v.ing</strong>）的数据。</p><h3 id="异步任务"><a href="#异步任务" class="headerlink" title="异步任务"></a><a href="https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Asynchronous">异步任务</a></h3><p>通常来说，程序都是顺序执行，同一时刻只会发生一件事。如果一个函数依赖于另一个函数的结果，它只能等待那个函数结束才能继续执行，从用户的角度来说，整个程序才算运行完毕。</p><p>使用<strong>异步函数</strong>可以设置函数队列的执行顺序。JS中最基本的异步函数有：</p><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout">window.setTimeout</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/WindowOrWorkerGlobalScope/setInterval">window.setInterval</a></li></ul><h2 id="灵活使用-TL-DR"><a href="#灵活使用-TL-DR" class="headerlink" title="灵活使用(TL;DR)"></a>灵活使用(TL;DR)</h2><p>如何打出想要的0-4？</p><p><strong>理解关键点</strong>：只要 ①在局部作用域中<strong>创造</strong>它的<strong>局部变量<code>i</code><strong>（方法一） 或者 ②在</strong>局部作用域</strong>中<strong>使用</strong>全局变量<code>i</code>（方法二和方法三）就能够达到目的。</p><p><strong>方法一</strong>（for循环内部使用let声明）：</p><p>可以将var声明改为<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/let"><code>let</code></a>声明。它能声明一个块级作用域的本地变量。</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)&#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>        <span class="hljs-built_in">console</span>.log(i);<br>    &#125;,<span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-comment">//控制台打印0，1，2，3，4</span><br></code></pre></div></td></tr></table></figure><p>let肯定不能放在for循环外面，上文已经解释。</p><p>此时，尽管计时器开始执行时，for循环已经结束，但每一次的<code>i</code>都是该次所在的块中的<code>i</code>，所以打印的是当时的i值。</p><p>注意，此时<strong>for循环将产生六个局部变量i</strong>，分别是0，1，2，3，4，5。</p><p>同样的道理，也可以在for循环中<strong>单独声明</strong>一个变量j（使用let或const）。此代码比较无聊，但对于理解方法一有帮助：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)&#123;<br>    <span class="hljs-keyword">let</span> j=i<br>    <span class="hljs-comment">//const j=i</span><br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>        <span class="hljs-built_in">console</span>.log(j);<br>    &#125;,<span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-comment">//控制台打印0，1，2，3，4</span><br></code></pre></div></td></tr></table></figure><p><strong>方法二</strong>（立即执行函数）：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)&#123;<br>    !<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">i</span>)</span>&#123;<br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>        <span class="hljs-built_in">console</span>.log(i)<br>    &#125;,<span class="hljs-number">0</span>)<br>    &#125;(i)<br>&#125;<br><span class="hljs-comment">//控制台打印0，1，2，3，4</span><br></code></pre></div></td></tr></table></figure><p>使用立即执行函数可以创造一个局部作用域，进而达到想要的效果：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">!<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>       <span class="hljs-comment">/*</span><br><span class="hljs-comment">       局部作用域。</span><br><span class="hljs-comment">       */</span><br>   &#125;()<br></code></pre></div></td></tr></table></figure><p><strong>方法三</strong>（setTimeout函数传参）：</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout">window.setTimeout</a>的第三个参数用于设定function的参数</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)&#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">i</span>)</span>&#123;<br>        <span class="hljs-built_in">console</span>.log(i)<br>    &#125;,<span class="hljs-number">0</span>,i)<br>&#125;<br><span class="hljs-comment">//控制台打印0，1，2，3，4</span><br></code></pre></div></td></tr></table></figure><p>此时，每一次进入for循环，第三个参数都告诉计时器：不用等for循环完成，你现在就能拿到i值给你的function执行了。所以每一次都能直接打印出当次的i值。</p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
